कंप्यूटर विज्ञान और इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर व्याख्यान के जावा प्रो। देबासीस सामंता विभाग में प्रोग्रामिंग - 37 प्रदर्शन - XIII आइए अब हम एप्लेट प्रोग्रामिंग से संबंधित कुछ महत्वपूर्ण तथ्यों का त्वरित प्रदर्शन करें।
इसलिए, इस प्रदर्शन में हम आपको विभिन्न तरीकों के बारे में कुछ चीजें प्रदर्शित करने जा रहे हैं जिन्हें एक एप्लेट प्रोग्राम में शामिल किया जा सकता है।
तब हम ठीक से html फ़ाइल विवरण देखेंगे, विस्तृत HTML फ़ाइल के बारे में कुछ और समय चाहिए।
इसलिए, यह हमारे अगले डेमो में शामिल किया जाएगा और कुछ मुद्दे बहुत हैं, हम यह भी कह सकते हैं कि एप्लेट प्रोग्रामिंग के साथ दिलचस्प तथ्य भी इस प्रदर्शन में शामिल किए जाएंगे।
तो, चलिए पहले सरल एपलेट जावा निष्पादन के संबंध में पहला डेमो करते हैं।
एप्लेट निष्पादन का संबंध है हम पहले से ही अपने हैलोवर्ल्ड, कार्यक्रम से परिचित हैं।
HelloWorld एप्लेट, जैसा कि हम जानते हैं कि अब तक एप्लेट प्रोग्राम का संबंध है, हमें दो पैकेजों का आयात करना होगा, अर्थात् एप्लेट पैकेज और फिर awt पैकेज।
इसलिए, आपके आयात अनुभाग में ये दोनों पैकेज होने चाहिए।
यदि आप इन दो पैकेजों को आयात नहीं करते हैं, तो आप संकलन त्रुटि का सामना कर सकते हैं और इस एप्लेट में जैसा कि हम देखेंगे कि वास्तव में कई और विधियां हैं, लेकिन इस विशेष एप्लेट, वर्तमान एप्लेट में जब हम केवल एक ही विधि देखते हैं तो यह एक महत्वपूर्ण विधि है किसी भी एप्लेट प्रोग्रामिंग में विधि और इस पेंट विधि में शामिल है, इसलिए यह पेंट विधि
तो, इन पेंट विधियों में ड्रॉस्ट्रिंग तरीके शामिल हैं और यह मूल रूप से एक विशेष स्थान पर पेंट क्षेत्र में एक स्ट्रिंग HelloWorld प्रदर्शित करता है जिसे 150 कहा जाता है ऊर्ध्वाधर और क्षैतिज 150।
तो, यह प्रदर्शित करेगा।
तो, ये पहले से ही इस तरह के एप्लेट प्रोग्राम से परिचित हैं।
तो, यह पहला एप्लेट प्रोग्राम है और बहुत सरल सबसे सरल एप्लेट प्रोग्राम है जो हमारे पास हो सकता है, लेकिन वास्तविक एप्लेट प्रोग्राम इतना सरल नहीं है, जो कि हम अपने प्रदर्शन के पाठ्यक्रम में वैसे भी सीखते हैं।
और वहां आपको दो चीजों को HTML का उपयोग करके एप्लेट कोड लिखना होगा, जावा सिंटैक्स का उपयोग करके और फिर, इस एप्लेट कोड को html सिंटैक्स के बाद एक html पेज का उपयोग करके होस्ट करने की आवश्यकता है।
तो, दो प्रोग्रामिंग भाषाएँ शामिल हैं;
html और दूसरा जावा है।
Html हाइपरटेक्स्ट मार्कअप लैंग्वेज के लिए है क्योंकि यह एक टैग आधारित है और html में यह <html> टैग है।
यह दिखा रहा है कि HTML को यहां शामिल करना आवश्यक नहीं है एक वैकल्पिक है, लेकिन यह यहां वैकल्पिक है कि एप्लेट टैग, और यह <एप्लेट> दो अनिवार्य विनिर्देशनों को टैग करता है जिसे कोड विनिर्देश कहा जाता है और फिर, चौड़ाई और फिर ऊंचाई विनिर्देशन ।
और कोड आधार भी है हालांकि यह अनिवार्य नहीं है।
तो, कोड आधार यदि इसका स्पष्ट रूप से उल्लेख नहीं किया गया है, तो यह इंगित करता है कि यह वर्ग फ़ाइल, अर्थात जावा प्रोग्राम और यह html फ़ाइल स्वयं उसी निर्देशिका से संबंधित है।
और हम मानते हैं कि यह फ़ाइल और डॉट, डॉट, यह .class फ़ाइल और .this HTML फ़ाइल यदि हम इसे सहेजते हैं, तो यह उसी निर्देशिका में होनी चाहिए और फिर हम किसी भी एपलेट दर्शकों का उपयोग कर सकते हैं।
एप्लेट और उसके बाद जो भी पेंट विधि परिभाषित की गई है वह उसके अनुसार काम करेगी।
यहाँ एक उदाहरण है जैसा कि हम देखते हैं कि यह एक एप्लेट व्यू है जिसमें चौड़ाई और ऊँचाई का एक विनिर्देश है जो हमने आपके html पेज में दिया है जो एप्लेट को पूरी तरह दिखाता है।
तो, यह पहला और फिर सबसे सरल उदाहरण है जिसे हम एप्लेट प्रोग्रामिंग के लिए देख सकते हैं
यहाँ।
अब, हमारे दूसरे उदाहरण विभिन्न तरीकों को दिखा रहे हैं, बल्कि मुझे मानक तरीकों को कहना चाहिए।
Init जैसे कुछ मानक तरीके हैं, फिर शुरू करें, फिर पेंट करें, बंद करें और नष्ट करें।
इस उदाहरण में हम देखेंगे कि ये विधियाँ अनिवार्य हैं या नहीं, ठीक है।
तो, विधियों को पहले से ही एक सार वर्ग में परिभाषित किया गया है जिसे एप्लेट कहा जाता है।
तो, जैसा कि आप देखते हैं कि यह एप्लेट सार वर्ग है और जैसा कि आप जानते हैं कि यह एप्लेट कार्यक्रम है, जिसे आपको एक नमूना के रूप में इस वर्ग का नाम देना है।
तो, यह एप्लेट प्रोग्राम है और इस वर्ग में मूल रूप से एब्स्ट्रैक्ट क्लास इनहेरिट की जाती है जिसे एपलेट कहा जाता है जिसे java.let पैकेज में परिभाषित किया गया है।
तो, इस वर्ग सार वर्ग को सार कहा जाता है क्योंकि इसमें कुछ सार तरीके होते हैं जैसे कि init एक सार पद्धति है।
Init एक अमूर्त विधि है और फिर यहाँ यह शुरुआत एक और है और फिर पेंट एक अन्य अमूर्त विधि है।
Init मेथड के लिए किसी पैरामीटर की आवश्यकता नहीं होती है क्योंकि एक तर्क शुरू भी एक ही होता है, लेकिन पेंट विधि के लिए यह हमेशा एक प्रकार के ग्राफिक्स के साथ होना चाहिए।
तो, ग्राफिक्स वह वर्ग है जिसे java.awt में परिभाषित किया गया है और फिर, g उस का एक उद्देश्य है।
यह पैरामीटर वैसे भी आवश्यक है।
अब, यह एक विधि है, जिसके बारे में हमने यहां चर्चा की है और हमें इस एक कक्षा में जाना है, ठीक है।
तो, इस विधि अगर यह वहाँ है, वैसे भी कोई मुद्दा नहीं है।
इसलिए, यह विधि यदि हम वहां हैं और यह उदाहरण दिखाएगा कि ये सभी विधियां हमारे यहां लिखी गई हैं और लिखी गई विधि मूल रूप से इनिट विधि है जैसा कि हम देखते हैं। हम सिर्फ एप्लेट को पृष्ठभूमि और अग्रभूमि रंग के साथ आरंभ करते हैं।
सेटबैकग्राउंड, सेटफोरग्राउंड ये ऐसी विधि है जो java.awt में परिभाषित की गई है और फिर यह मूल रूप से स्ट्रिंग है जिसे हमने सौंपा है, स्ट्रिंग।
स्टिंग का नाम msg है और फिर उसका मूल्य यह एक है और प्रारंभ विधि में जैसा कि आप विधि को देखते हैं जो पहले से ही इस init पद्धति में है, इसे इस एक के द्वारा जोड़ा जाएगा और यहाँ पेंट विधि में यह है।
3 विधियां हैं और फिर, निष्पादन का क्रम जैसा कि हमने पहले ही चर्चा की है कि init को पहले इनवॉइस के बाद लागू किया जाएगा, प्रारंभ को लागू किया जाएगा और फिर, इस क्रम में प्रिंट को लागू किया जाएगा।
अब, निष्पादन का यह क्रम यदि इसे लागू किया जाता है, तो संदेश तेजी से आरंभ किया जाएगा अंदर इनिट, तो इसे इस संदेश को प्रारंभ के अंदर से जोड़ दिया जाएगा और फिर, अंत में पेंट में यह फिर से स्याही के अंदर होगा और उसके बाद अंदर प्रारंभ होगा और फिर, अंदर जिसे पेंट कहा जाता है और फिर, इस एपलेट क्षेत्र में इस विधि का उपयोग करके पेंट विधि द्वारा इस संदेश को प्रदर्शित किया जाएगा।
अब, यदि यह आदेश सही है और यदि प्रारंभ में भी हम देखते हैं तो पृष्ठभूमि सियान और फिर अग्रभूमि होगी।
इसका मतलब है कि फ़ॉन्ट लाल रंग में दिखाई देगा।
अब, इस प्रोग्राम को जावा और फिर एक html फ़ाइल में होस्टिंग और फिर संकलन, ओके के साथ संकलित करें।
हम एप्लेट व्यूअर का उपयोग करके संकलन कर सकते हैं।
तो, एप्लेट व्यूअर तब html फ़ाइल का नाम html फ़ाइल का नाम नमूना। Html है और जैसा कि आप ठीक देखते हैं कि यहाँ ठीक है, ठीक है।
फिर, बैकग्राउंड डिज़ाइन और फिर यह मूल रूप से एक है जैसा कि आप देख रहे हैं कि init मेथड तेजी से निष्पादित होता है यही कारण है कि संदेश है, फिर प्रारंभ विधि और फिर अंत में पेंट विधि।
इसीलिए यह बात पेंट पद्धति में आ गई और आखिरकार यह वहां दिखाई दे रही है।
इसलिए, ऑर्डरिंग अंदर है, फिर शुरू करें और फिर पेंट करें जो कि महत्वपूर्ण बात है।
अब, हम फिर से देखते हैं जैसा कि मैंने पहले ही कहा था कि इन सभी तरीकों को प्रोग्रामर द्वारा परिभाषित किया जाना आवश्यक नहीं है।
यह जरूरी है।
यदि आप इस विधि का उपयोग नहीं करते हैं तो यह वहां भी होगा।
अब इस मामले में उदाहरण के लिए हमने ओवरराइट किया है, हालांकि बिना किसी कोड के ओवरराइट किया गया है, यह प्रोग्राम भी एक प्रकार का ओवरराइटिंग है और यदि हम इस प्रोग्राम को फिर से ऐपलेट व्यूअर चलाते हैं और फिर, यह प्रोग्राम यदि आप इसे चलाते हैं और हम आपको देखेंगे। यह ब्राउज़र अभी थोड़ा ठीक है।
इसलिए, जैसा कि आप देख रहे हैं कि अब तक कोई सेटिंग नहीं है, आरंभीकरण, पृष्ठभूमि, अग्रभूमि क्योंकि हमारे पास कोई कोड नहीं है।
अब तक init पद्धति का कोई प्रारंभ नहीं है, कोई भी पेंट नहीं है और इसीलिए यह एक खाली एप्लेट है।
तो, क्या यह एप्लेट में कुछ और नहीं है।
अब, इसलिए यहां आपने ओवरराइट कर दिया है, हालांकि कोई कोड नहीं है, लेकिन यहां हम बिना किसी कोड के भी एप्लेट प्रोग्राम लिख सकते हैं।
इसलिए, मैं सिर्फ इन सभी तरीकों पर टिप्पणी करना चाहता हूं और फिर हमें इस कार्यक्रम को शुरू करना चाहिए।
तो, जैसा कि आप एक ही बात देखते हैं।
तो, एप्लेट चल रहा है एप्लेट शुरू हो गया है, लेकिन अब इसमें कोई सामग्री नहीं है।
इसलिए, हमने 3 तरीकों के बारे में चर्चा की है जो प्रारंभ करें और फिर, पेंट करें
विधि और फिर, निष्पादन के आदेश और हमने यह भी उल्लेख किया है कि ये सभी विधियां अधिमानतः लिखित हैं, लेकिन आवश्यक नहीं हैं।
अब हमारा अगला उदाहरण एक एप्लेट 4 में स्टॉप मेथड का उपयोग दिखा रहा है, सही।
हालाँकि awt को कवर नहीं किया गया है और इसलिए, हम मान लेते हैं कि यह मूल रूप से एक फ़्रेम बनाया जाएगा और फिर, फ़्रेम प्रदर्शित किया जाएगा और इस फ़्रेम ने WindowsAdapter इवेंट नामक एक घटना का उपयोग किया, ठीक है।
आइए हम मान लें कि यह कोड मूल रूप से एक फ्रेम बनाएगा, उस फ्रेम को एप्लेट द्वारा बनाया जा सकता है।
प्रोग्राम कोड का हमारा अगला भाग जो मूल रूप से इस एक फ्रेम सहित है।
तो, यहाँ यह मुख्य कार्यक्रम मुख्य एप्लेट प्रोग्राम है जिसे हम यहाँ कह सकते हैं, ठीक है।
तो, यह यहाँ मुख्य कार्यक्रम है कि एप्लेट फ्रेम एक विस्तार एप्लेट है।
तो, यह AppletFrame हमारा मुख्य एपलेट प्रोग्राम है।
हमारे यहाँ init कोड है।
विधि, यह विधि मूल रूप से एक फ्रेम बनाती है, जिस फ्रेम पर पहले से ही चर्चा की गई है और फिर, फ्रेम ऑब्जेक्ट का नाम एफ है, फ्रेम ऑब्जेक्ट्स और हमारे पास सिर्फ एक फ्रेम विंडो है एक संदेश है जो शीर्षक पर दिखाई देगा। फ़्रेम का शीर्ष और यह उस फ़्रेम का आकार है जो वहां होगा और फिर कहा गया दृश्य यह एक अवधारणा है जिसे फ़्रेम को दिखाई देने के लिए आवश्यक है और फिर, प्रारंभ विधि।
जैसा कि आप देख रहे हैं कि यह बहुत ही सरल सेट है जो सच है।
इसका मतलब है कि हम इसे बनाते हैं और फिर इसे बंद कर देते हैं मूल रूप से एफ डॉट सेट दिखाई देता है।
इसलिए, जब भी हम बस रोकते हैं, हम वहां रुकने की विधि का आह्वान करते हैं।
अब, एक और बात यह है कि init का स्पष्ट रूप से आह्वान किया जाता है, प्रारंभ भी अंतर्निहित रूप से जो भी स्टॉक में किया जा सकता है उसे स्पष्ट रूप से आपके एप्लेट में लागू करने की आवश्यकता है।
यदि आप इसका उपयोग नहीं करते हैं, तो एप्लेट शुरू हो जाएगा मेरा मतलब है कि प्रदर्शन को प्रदर्शित करना, इसकी सामग्री इस तरह से।
वैसे भी इस एप्लेट विधि में फिर से पेंट मूल रूप से सरल है।
यह आपके एप्लेट क्षेत्र में इस स्ट्रिंग को प्रदर्शित करेगा।
अब, यदि हम इस प्रोग्राम को सफलतापूर्वक संकलित करते हैं और फिर हम इस प्रोग्राम को चला रहे हैं और आप देखेंगे कि स्टॉप मेथड कैसे इसके प्रभाव में आता है।
पहले के एप्लेट में स्टॉप मेथड डिक्लेरेशन नहीं था।
अब इस एप्लेट में हमने स्टॉप मेथड का इस्तेमाल किया है जो हम देखते हैं।
इस प्रदर्शन में जैसा कि आप देखते हैं कि दो चीजें हैं।
जब भी आपने इसे शुरू किया, यह मूल रूप से हमारा सामान्य एप्लेट है।
एप्लेट की शुरुआत हुई और इस एप्लेट ने मूल रूप से एक और फ्रेम मंगवाया जो एप्लेट इनिट विधि में पहले से ही है।
यह एप्लेट है जिसे कहा जाता है यह फ्रेम सही है और फिर, इस फ्रेम के भीतर कुछ स्ट्रिंग है जो ठीक से प्रदर्शित नहीं है और यह मूल रूप से स्ट्रिंग है जिसे वहां पेंट विधि द्वारा चित्रित किया गया है।
तो, अब यहाँ एप्लेट शुरू होने वाला है और निष्पादन में सक्रिय एप्लेट है जिसे हम कह सकते हैं।
अब, हम इसे रोक सकते हैं।
यदि हम इसे रोकते हैं, तो यह फ्रेम आगे बढ़ेगा, लेकिन एप्लेट अभी भी चल रहा है।
इसलिए, यदि आप इसे यहां रोकते हैं तो यह, ताकि फ्रेम अधिक मौजूद न हो और इसे रोक दिया जाता है अर्थात हमें बाद में उसी कार्यक्रम को चलाने के बाद इसे फिर से शुरू करना होगा।
अब, यहाँ फिर से एपलेट जैसा कि आप देखते हैं एप्लेट अभी भी चल रहा है और अगर हम इसे क्लिक करते हैं, तो मूल रूप से यह एप्लेट के निष्पादन को रोक देगा।
तो, यह मूल रूप से प्लेट को रोक रहा है और यहां आप कह सकते हैं कि एप्लेट को यहां रोक दिया गया है और फिर कर्सर यहां नियंत्रण कमांड पर लौट आया है।
अब, दूसरी तरफ अगर हम एप्लेट को रोकते हैं, तो एपलेट का मतलब है कि धागा सब कुछ एक साथ बंद कर देगा।
स्वचालित रूप से फ़्रेम का अस्तित्व समाप्त हो जाएगा।
मैं इसे यहां रोक रहा हूं और आप दोनों फ्रेम को एप्लेट के रूप में देखते हैं।
तो, यह मूल रूप से रोक की अवधारणा है।
स्टॉप एक और संदर्भ में भी है।
प्ले पर आने वाली स्टॉप विधि कहती है कि जैसे ही आप html पेज को एप्लेट व्यू को होस्ट करते हुए देखते हैं, अगर आप html पेज को बंद कर देते हैं, तो क्या होगा इस एप्लेट को भी बाहर जाना होगा।
अब, अगर हम उसी को चलाते हैं
एप्लेट, फिर उसी एप्लेट को प्रदर्शित किया जाएगा।
तो, इसका मतलब है कि रोक का मतलब यह नहीं है कि यह स्थायी रूप से बंद हो गया है।
यह सिर्फ स्मृति से है।
अस्थायी रूप से यह वहाँ नहीं है, लेकिन स्मृति में यह वहाँ रहता है।
तो, इस एप्लेट को मेमोरी से पूरी तरह से स्थानांतरित करने के लिए, हमें नष्ट विधि को कॉल करना होगा।
हमारा अगला उदाहरण इस अवधारणा की व्याख्या करेगा कि यह मुख्य विधि, मुख्य मेमोरी से पूरी तरह से कैसे साफ हो सकता है।
अब, यहाँ आप देखते हैं कि यह एप्लेट का दूसरा उदाहरण है जैसा कि आप यहाँ देखते हैं।
तो, यह एप्लेट जीवन चक्र है, यह यहां एप्लेट प्रोग्राम का नाम है, एप्लेट क्लास इनहेरिट करता है और यह मूल रूप से एक स्ट्रिंग का उपयोग किया जाता है और यह विधि पर आइटम जोड़ें का भी उपयोग करता है।
इस भाग में विधि यहाँ बताई गई है, मूल रूप से सिर्फ दो काम करते हैं।
यह कंसोल क्षेत्र पर प्रिंट करने के साथ-साथ एपेंट स्ट्रिंग पर रिपेंट विधि का उपयोग करके प्रिंट करता है और इसकी शुरुआत होती है।
मूल रूप से कुछ स्ट्रिंग का उपयोग करके आइटम को तर्क के रूप में कॉल करना शुरू करें क्योंकि इस ऐड आइटम को पास करने के लिए स्ट्रिंग की आवश्यकता होती है।
स्टॉप भी वही काम कर रहा है और फिर, उसी काम को करने के लिए नष्ट भी करें।
AddItem विधि कहा जाता है, सभी तीन विधियों को कॉल करें। AddItem विधि मूल रूप से कंसोल कंट्रोल विंडो पर एक स्ट्रिंग प्रदर्शित करती है, दूसरा यह है कि एप्लेट क्षेत्र में सभी तारों को जोड़ते हुए कुछ स्ट्रिंग प्रदर्शित करें।
वास्तव में अब अगर हम एक एप्लेट का उपयोग करके फिर से इस कार्यक्रम को चलाते हैं।
दर्शक हमें देखते हैं कि यह कैसा दिखेगा।
अब यहां दो चीजें हैं।
तुम बस मुझे यहाँ ले गए हो, बस यहाँ एक के लिए आओ, अब यहाँ दो चीजें हैं जो आपको यहाँ नोट करनी चाहिए।
तो, यह कंसोल क्षेत्र है और कंसोल क्षेत्र में आप यह नोट कर सकते हैं कि यह इनलेट विधि के कारण एप्लेट को इनिशियलाइज़ कर रहा है और फिर, एप्लेट को भी शुरू करना है क्योंकि इन दोनों विधियों को स्वचालित रूप से कहा जाता है जब भी एप्लेट शुरू हुआ है फिर यह एप्लेट को इनिशियलाइज़ करते हुए एप्लाइड टेक्स्ट को दिखा रहा है और फिर, एपलेट को शुरू करते हुए जैसा कि आप देख रहे हैं।
अब, हमारे पास कोई विध्वंस नहीं है और न ही कोई विधियाँ हैं।
अब, यदि हम इसे रोकते हैं तो स्टॉप विधि निष्पादन में होगी और यह विधि निष्पादन का मतलब होगी, लेकिन एक स्टॉप विधि ऐड आइटम को कॉल करेगी।
इसलिए, आइटम जोड़ें बस इसे प्रदर्शित करेगा, लेकिन जैसे ही यह एप्लेट बंद हो जाएगा तब यह अधिक नहीं होगा।
तो, यह वास्तव में कोई दृश्य नहीं होगा।
अब, हम इसे रोकते हैं।
जैसा कि आप यहां एप्लेट को रोकते हैं और फिर एप्लेट को लोड करते हैं, वे मूल रूप से स्टॉप विधि के कॉल के आधार पर हैं और यह विध्वंस विधि के आधार पर है।
अब जब भी आप इसे कॉल करते हैं और कंसोल क्षेत्र से हमारे मुख्य सामान्य पर लौटते हैं, तो यह इंगित करता है कि एप्लेट मेमोरी में नहीं है और न ही अधिक थ्रेड है, न ही अधिक निष्पादन।
तो, यह मूल रूप से कहता है कि स्टॉप विधि के तुरंत बाद नष्ट विधि को कैसे लागू किया जा सकता है।
अब विध्वंस विधि को केवल रोक विधि कहा जा सकता है।
तो, यह उदाहरण 5 अलग-अलग तरीकों को दिखाता है;
init, start, paint, stop और destroyed.
कुछ और विधियाँ अद्यतन और प्रत्याहार विधि हैं और यह एक बहुत ही रोचक एक एप्लेट का उपयोग करके अद्यतन और पुनरावृत्ति विधि के बारे में डेमो करना अधिक आकर्षक है, इसे बैनर एप्लेट कहा जाता है।
अब यहाँ बैनर एप्लेट के लिए कोड है, ठीक है।
यह समझना थोड़ा मुश्किल हो सकता है, लेकिन अगर हम इस बारे में थोड़ा परेशान हैं, तो
हम देख सकते हैं कि इस कार्यक्रम में सामग्री, कोड तत्व, कोड चीजें क्या हैं।
अब, यहाँ ये हमेशा की तरह आयात अनुभाग हैं और यहाँ एप्लेट का नाम है।
अब आप देखते हैं कि विस्तार एप्लेट है, लेकिन इस बैनर एप्लेट को निष्पादित करने के लिए एक सूत्र की आवश्यकता है।
तो, यह रननेबल थ्रेड को लागू करता है और आप थ्रेड को जानते हैं इसका मतलब है कि हमें थ्रेड घोषित करना होगा और फिर, हमें रन विधि को परिभाषित करना होगा।
अब, यहां प्रारंभ विधि में एक धागा घोषित किया गया है।
जैसा कि आप यहाँ देख रहे हैं, यह एक आरंभ विधि है जहाँ एक धागा बनाया जाता है और यह धागा मूल रूप से पूरे एप्लेट का धागा होता है जो मूल रूप से यहाँ एक धागा है।
तो, यह इस धागे का पैरामीटर है।
तो, यह धागा अब थ्रेड बनाया गया है, उदाहरण बनाया गया है और अब t.start () का अर्थ है कि थ्रेड ने इसका निष्पादन शुरू कर दिया है।
तो, इनिट विधि मूल रूप से बैकग्राउंड और फोरग्राउंड को स्वचालित रूप से बदल देगी, प्रारंभ भी स्वचालित रूप से इस के द्वारा किया जाएगा, थ्रेड स्वचालित रूप से निष्पादन में होगा और फिर जब भी थ्रेड निष्पादित होता है, तो यह मूल रूप से उस कोड को निष्पादित करता है जो इसमें परिभाषित किया गया है रन विधि।
तो, रन मूल रूप से थ्रेड क्लास के साथ है क्योंकि रन विधि जो कि रनने योग्य इंटरफ़ेस है, यहां ओवरइटन विधि थोड़ी है।
यह एक मुश्किल कोड है, सही है।
हमें इस बारे में ज्यादा नहीं बताना चाहिए कि ये कोड वास्तव में कैसे काम करते हैं।
यह मूल रूप से स्ट्रिंग से एक चरित्र का चयन करता है जिसे वास्तव में जल्दी चिह्नित करने की आवश्यकता होती है।
इसका मतलब है, स्ट्रिंग आगे बढ़ेगी और फिर उस स्ट्रिंग को चित्रित किया जाएगा और फिर, पुन: प्रिंट और अपडेट किया जाएगा।
इतना लंबा यह धागा निष्पादन में होगा, यह धागा मूल रूप से निष्पादन है और रुक-रुक कर धागा 250 मिलीसेकंड के लिए नींद की स्थिति में है।
यह केवल आपके विचारों की धारणा के लिए है कि एक चरित्र प्रदर्शित होता है।
चरित्र का अगला उप स्ट्रिंग आएगा, इसे फिर से लिखा जाएगा, मेरे द्वारा बताई गई चीजों को अपडेट करें और फिर, फिर से, फिर से अपडेट करें, आगे जा रहे हैं और यह प्रक्रिया चल जाएगी और फिर अगर हम इसे बंद नहीं करते हैं, तो यह जारी रहेगा ।
तो, स्टॉप मेथड है और तब इवेंट को बनाए रखा जा सकता है, अगर हम सिर्फ बटन पर क्लिक करते हैं तो वैसे भी कोई ईवेंट नहीं है।
तो, इसका मतलब यह है कि हमने अभी जो भी प्रक्रिया पर चर्चा की है, उसे हमने रोक दिया है।
तो, बंद का मतलब है कि बैनर पूरी तरह से शुरू होगा और इसका निष्पादन होगा।
अब, देखते हैं कि यहाँ इस एप्लेट क्लास का डेमो है।
केवल यहाँ रन विधि को समझना थोड़ा मुश्किल है, अन्यथा सब कुछ बहुत सरल है।
मैं इस एप्लेट विंडो को थोड़ा बढ़ा रहा हूं, ताकि हम इसके बारे में समझ सकें।
अब, हमारे एप्लेट को क्रियान्वित करने में जैसा कि आप देख रहे हैं।
तो, एप्लेट शुरू हुआ और यहां आप देख रहे हैं कि बैनर राज्य में काम कर रहा है कि स्ट्रिंग एक सरल बैनर आ रहा है।
फिर से एक सरल यह एक बैनर है जो वास्तव में प्रदर्शन डिजिटल प्रदर्शन जैसा दिखता है जैसा बैनर आपको पता है।
तो, यह मूल रूप से एपलेट में है कि आप इसे कर सकते हैं और फिर पृष्ठभूमि, अग्रभूमि यह पहले से ही init विधि द्वारा है।
अब, इसलिए यहां हमारा धागा अभी भी क्रियान्वयन में है और फिर, इस धागे को रोकने के लिए हम बस इसे बंद कर देते हैं।
इसलिए, अब हम अपने निष्पादन पर नियंत्रण वापसी करते हैं। मेरा मतलब रनटाइम मैनेजर में निष्पादन से है।
इसका मतलब अब एप्लेट बंद हो गया है।
इसलिए, यह एक बैनर उदाहरण है जिसे हमने इसे योजनाबद्ध किया है और फिर, हम देखते हैं कि यहां एक सरल एप्लेट लिखने के उपयोग से यह कैसे संभव है।
और फिर एक बुनियादी बात अब तक एप्लेट प्रोग्रामिंग का संबंध है, एक html पृष्ठ का उपयोग करके होस्ट करना।
हमारे पास एप्लेट प्रोग्रामिंग के बारे में एक विचार है।
अब तक एप्लेट प्रोग्राम अलग-अलग तरीकों से संबंधित है, मानक विधियाँ हैं।
मानक तरीके, हम उपयोग कर सकते हैं आप उपयोगकर्ता द्वारा परिभाषित कई अन्य तरीकों को शामिल कर सकते हैं, उपयोगकर्ता परिभाषित विधि और साथ ही विधि को अन्य एपीआई वर्ग से भी विरासत में मिला जा सकता है, ठीक है।
इसलिए, वे चीजें संभव हैं और उपयोगकर्ता द्वारा परिभाषित विभिन्न तरीकों के संबंध में यह है कि, हम अलग-अलग एप्लिकेशन संदर्भ में उन सभी चीजों पर फिर से चर्चा करेंगे, जब हम एप्लेट प्रोग्रामिंग और ओटीटी प्रोग्रामिंग के बारे में कई और चीजों को जानते हैं, ठीक है।
तो, उस पर चर्चा की जाएगी।
अब, मैं केवल यह सोचना चाहता हूं कि वहां दो महत्वपूर्ण बातें हैं।
दो प्रोग्रामिंग बल्कि मुझे कहना चाहिए कि एक जावा प्रोग्रामिंग है।
जावा प्रोग्रामिंग के माध्यम से हम अपनी क्लास फाइल को परिभाषित कर सकते हैं जो हमारे एप्लेट में कोड हो सकती है और फिर html सही है।
इसका मतलब है, कि उस क्लास की फाइल को वहाँ html में एम्बेड किया जाना चाहिए।
अब, क्या वास्तव में एक html फ़ाइल है। html वहाँ है, html जैसा कि आप जानते हैं कि html हाइपरटेक्स्ट मार्कअप लैंग्वेज के लिए है।
यह मूल रूप से एक भाषा विनिर्देश है जो एक ब्राउज़र इस कोड को समझ सकता है और ब्राउज़र इस html कोड को समझकर या टैग को पहचानकर समझ सकता है।
तो, html मूल रूप से html टैग्स का एक संग्रह है और यहां हम विभिन्न टैग देख सकते हैं और फिर टैग्स को एक सिंटैक्स कहा जाता है जो शुरू और बंद होता है।
उदाहरण के लिए, कोणीय कोष्ठक (<>) के भीतर शुरू होने वाला वाक्यविन्यास html जैसा कि हम देखते हैं और एक समापन है यह एक है, फिर जो कुछ भी इस शुरुआत और समापन के भीतर होगा वह मूल रूप से इस टैग और आपके HTML पृष्ठ का हिस्सा है।
ब्राउज़र वास्तव में यह मूल रूप से एक ब्राउज़र द्वारा निष्पादित किया जा सकता है, ब्राउज़र इस HTML पृष्ठ को खोल सकता है और टैग द्वारा टैग किया जा सकता है, यह व्याख्या कर सकता है कि वास्तव में सामग्री क्या है।
अब, इस उदाहरण में, जैसे ही आप HTML को html के भीतर फिर से एक अन्य टैग बॉडी देखते हैं और फिर, इस बॉडी के भीतर जैसे ही आप कुछ अन्य टैग देखते हैं, एप्लेट कहलाता है।
अब यह एक बहुत विशिष्ट प्रकार है, लेकिन html ऐसा नहीं है कि सभी टैग आवश्यक या अनिवार्य हैं।
वे सभी टैग वैकल्पिक भी हैं।
अब यहां एक उदाहरण है कि हम जा सकते हैं कि आम तौर पर साधारण HTML पेज कैसे होता है, आमतौर पर बिना किसी एप्लेट कोड के यहां कैसा दिखता है।
यह एक साधारण HTML फ़ाइल का एक विशिष्ट रूप है जिसमें कई अन्य महत्वपूर्ण चीजें शामिल हैं।
जैसा कि आप यहाँ देख रहे हैं शीर्षक एक और टैग है <head> एक और टैग है <body> शरीर के भीतर एक और टैग है <Applet> अब है।
यहाँ आप देख सकते हैं कि यह शीर्षक है और ये उसके भीतर का सरल पाठ है, है ना।
Html इसे प्रोसेस नहीं कर पाएगी।
बस इसे सिर्फ डिस्प्ले करने वाले को पास करना होगा, यह केवल एक स्ट्रिंग के रूप में होगा जब भी html इसे पास करने में सक्षम नहीं होगा यह केवल स्ट्रिंग के रूप में स्ट्रिंग सामग्री है और फिर ये हैं <head> <TITLE> <H1>।
ये अलग-अलग html टैग हैं जिनके अलग-अलग अर्थ हैं जिन्हें html जानते हैं।
वे इसके बारे में वैसे भी समझ सकते हैं।
मैं नहीं जानता कि प्रत्येक टैग के अर्थ के बारे में चर्चा करना चाहता हूं और जो कुछ भी है और टिप्पणी इस टैग का उपयोग करके html टैग में पोस्ट की जा सकती है और फिर, इसे एपलेट दर्शक द्वारा भी खोला जा सकता है, लेकिन एप्लेट दर्शक केवल एपलेट कोड को पहचान सकता है ।
अन्य सभी चीजें जो वहां एपलेट दर्शक हैं, वे एपलेट दर्शक के लिए पहचाने जाने योग्य नहीं हैं।
लेकिन html पेज को किसी भी ब्राउज़र से बेहतर पहचाना जा सकता है।
तो, हमारे मशीन के किसी भी ब्राउज़र को क्रोम या ब्राउज़र कहते हैं, मैं यहाँ सिर्फ एक क्रोम क्रोम का उपयोग करके इसे खोल रहा हूँ, जहाँ html फ़ाइल संग्रहीत है, वहाँ पर जाएँ और वहाँ डिफ़ॉल्ट ब्राउज़र जो स्वचालित रूप से वहाँ है, पर डबल क्लिक करें।
आपके सिस्टम को इसे खोलने के लिए आमंत्रित किया जाएगा क्योंकि आप देखते हैं कि यह html सामग्री है और इस सामग्री की व्याख्या हमारे ब्राउज़र द्वारा यहाँ की जाएगी और इसे प्रदर्शित करेंगे और आप देखेंगे कि html छवि वहाँ है जो मूल रूप से छवि है।
तो, छवि प्रदर्शित होती है और फिर हाइपरलिंक को लिंक करती है।
तो, लिंक का मतलब है कि यह इस पर जाएं।
तो, लिंक अगर आप लिंक पर जाते हैं, अगर मशीन जुड़ा हुआ है तो यह स्वचालित रूप से जाएगा
NPTEL वेब साइट।
इस ब्राउज़र से स्वचालित रूप से एक हाइपरलिंक है यह वहां है और फिर, इसे निष्पादित किया जाएगा।
अब, एक और बात यह है कि HTML ब्राउज़र, इस मामले में आपका क्रोम ब्राउज़र इस भाग को नहीं पहचान सकता है क्योंकि वे किसी HTML विशिष्ट कोड के भीतर एम्बेडेड नहीं हैं।
तो, यह मूल रूप से यहां इस में आ रहा है और यहां एक शीर्षक है जिसे आप एक साधारण HTML देखते हैं और ब्राउज़र आप शीर्षक बार देख सकते हैं।
वास्तव में यह दिखा रहा है कि एक साधारण HTML पेज है।
तो, ये html प्रदर्शन की मूल अवधारणा है यह वहां है और एक बात यह है कि ये सभी टैग मूल रूप से संवेदनशील नहीं हैं।
आप बड़े अक्षर या छोटे अक्षर में लिख सकते हैं।
बिल्कुल यह कोई मुद्दा नहीं है।
इसे वह चलाएगा।
तो, HTML ब्राउज html पेज संवेदनशील और स्पष्ट रूप से मामला है, अगर टैग में कोई गलती है जो HTML आपके कहे अनुसार नहीं पहचान पाएगा, तो इसका मतलब है कि यह सिर्फ नजरअंदाज कर दिया गया है।
लेकिन इसका अगला हिस्सा यह होगा।
तो, यह सफलतापूर्वक व्याख्या की है।
अगर कुछ सही नहीं है, तो बाकी चीजें, जो सही हैं, उन्हें वहां निष्पादित किया जाएगा, ठीक है।
तो, यह इस बारे में है और फिर इस html फ़ाइल में शामिल किया जा सकने वाला एक महत्वपूर्ण टैग एप्लेट कोड है और फिर, यदि यह कोड है और एप्लेट दर्शक इसे केवल एक ही पहचान सकता है, लेकिन एप्लेट दर्शक इसे समझ नहीं पाएंगे अब।
इसलिए, अब हमने इस एप्लेट कोड का उपयोग किया है और फिर एप्लेटव्यूअर इसे प्रोसेस कर सकता है, हालांकि यह किसी अन्य को प्रोसेस नहीं करेगा
चीजें जो वहां मौजूद हैं क्योंकि HTML पेज में मौजूद अन्य टैग एप्लेट के लिए कार्यकारी नहीं हैं।
अब, हम इस एप्लेटव्यूअर को चलाते हैं क्योंकि आप देखते हैं कि यह उतना प्रभाव नहीं देगा जैसा कि ब्राउज़र ने हमें दिया है।
तो, मैं इस HTML पृष्ठों एप्लेट दर्शक चला रहा हूँ तो ठीक है।
जैसा कि आप देख रहे हैं कि एप्लेट क्लास नहीं है, इसीलिए यह हैलो वर्ल्ड क्लास को अंजाम नहीं दे रहा था।
तो, यहाँ एप्लेट दर्शक इस क्लास फ़ाइल को प्रदर्शित नहीं कर सके क्योंकि उसी html फ़ाइल में जहाँ यह प्रोग्राम है, यह वहाँ नहीं है डॉट जावा सही नहीं है।
आपको डॉट क्लास करना है, ठीक है।
अब, डॉट हमने इसे बदल दिया है इसे सेव करें और फिर, (डॉट) क्लास फाइल है।
वहां कुछ गलतियां हैं।
इसलिए, हमने कोड फ़ाइल में शामिल किया है। (डॉट) जावा।
एप्लेट दर्शक द्वारा डॉट जावा की व्याख्या नहीं की जा सकती है।
इसलिए, इसने कोई आउटपुट नहीं दिया वास्तव में अब हमने इसे बदल दिया है।
इसलिए, जैसा कि आप देख रहे हैं कि यह हैलो वर्ल्ड क्लास दे रहा है, वैसे भी कुछ गलतियाँ हैं।
तो, यह मूल रूप से एप्लेट दर्शक इस कोड को पहचान सकता है, लेकिन यह फिर से हो सकता है यदि पहले बिना किसी एप्लेट कोड के हमारे ब्राउज़र या सफलतापूर्वक इसे प्रदर्शित करता है।
अब हम इस एप्लेट कोड का उपयोग करते हुए देखते हैं कि अगर हम फिर से इस html क्रोम फ़ाइल को चलाते हैं तो क्या होगा, ठीक है।
तो, अब यहाँ आप देख सकते हैं कि हमारा क्रोम ब्राउज़र इसकी व्याख्या नहीं कर सकता है।
एप्लेट कोड मूल रूप से केवल इसे अनदेखा करता है, हालांकि अन्य वहाँ रहा है।
तो, यह मूल रूप से एपलेट दर्शक है और फिर, एक बिंदु के रूप में ब्राउज़र जो मैं यहां उल्लेख करना चाहता हूं वह यह है कि वर्तमान ब्राउज़र जो इस समय उपलब्ध हैं, वे अब एप्लेट कोड का समर्थन नहीं करते हैं।
यदि आपके मशीन में इंटरनेट एक्सप्लोरर संस्करण 4 और निम्न पर उपलब्ध है, तो उन्हें समर्थन दिया जा सकता है और फिर ब्राउज़र कि IEEE इंटरनेट एक्सप्लोरर ब्राउज़र इस एक को पहचान सकता है, लेकिन संस्करण 4 ऊपर या नहीं समर्थन नहीं है, हालांकि कुछ ब्राउज़र हैं उन्हें नेटस्केप नेविगेटर और फिर हॉट जावा जैसे जावा सक्षम ब्राउज़र कहा जाता है।
वे ऐसा कर सकते हैं, वे सब कुछ का समर्थन कर सकते हैं जो भी HTML टैग्स एपलेट सहित वे इसे ठीक से ब्राउज़ कर सकते हैं और विशेष रूप से मोज़िला भी जो कि प्रतिबंधात्मक तरीके से अगर आप कुछ प्लगइन कोड का उपयोग करते हैं, तो उसके लिए नेट में नि: शुल्क प्लगइन उपलब्ध है। ।
आप इसे स्थापित कर सकते हैं और फिर, कि इस प्लगइन के साथ मोज़िला सभी HTML टैग और साथ ही ऐपलेट टैग को हमेशा के लिए संसाधित कर सकता है और फिर से html 5 संस्करण के बाद एपलेट एपलेट के अप्रचलित हो जाता है।
आप <ऑब्जेक्ट> टैग का उपयोग कर सकते हैं।
उनका <ऑब्जेक्ट> टैग एप्लेट टैग के समान है।
जिसमें एप्लेट प्रोग्रामिंग पर हमारा आज का पहला प्रदर्शन शामिल है।
हमारे अगले मॉड्यूल में एप्लेट प्रोग्रामिंग 2 पर हमारा अगला प्रदर्शन और फिर, हम जावा में एक और प्रोग्रामिंग अवधारणा पर चर्चा करेंगे।
आपका बहुत बहुत धन्यवाद।
कंप्यूटर विज्ञान इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर व्याख्यान में जावा प्रो। देबासीस सामंता विभाग में प्रोग्रामिंग, 08 प्रदर्शन - III तो, पिछले मॉड्यूल में, आपने इनकैप्सुलेशन के बारे में सीखा है।
एनकैप्सुलेशन, वास्तव में, एक बहुत महत्वपूर्ण अवधारणा है एक बहुत ही महत्वपूर्ण वस्तु-उन्मुख प्रतिमान है।
इसलिए, एनकैप्सुलेशन की मूल अवधारणा को सीखने के बाद, आज हमने एक डेमो की योजना बनाई है, जहाँ हम एनकैप्सुलेशन के विभिन्न पहलुओं के बारे में सीखते हैं।
तो, हमारे आज के प्रदर्शन में यह भी शामिल है कि हम एक वर्ग कैसे बना सकते हैं और फिर एक वर्ग के लिए, विभिन्न वस्तुओं का निर्माण कैसे किया जा सकता है और फिर हम एक कक्षा में कितने तरीके जोड़ सकते हैं, ताकि एक वर्ग इसे पूर्ण रूप ले सके।
एन्कैप्सुलेशन में एक महत्वपूर्ण अवधारणा जो किसी भी कार्यक्रम के लिए बहुत आवश्यक है, वह है स्वचालित वस्तु आरंभीकरण।
तो, यह अवधारणा एक निर्माता के माध्यम से जावा में हासिल की गई है।
इसलिए, कंस्ट्रक्टर की अवधारणा का प्रदर्शन किया जाएगा और साथ ही हम कंस्ट्रक्टर ओवरलोडिंग पर चर्चा करेंगे।
तो, यह जावा अवधारणा में बहुरूपता का एक हिस्सा है ताकि कई निर्माणकर्ताओं की योजना बनाई जा सके, ताकि, किसी वस्तु को अलग-अलग तरीकों से आरम्भ किया जा सके और कुछ अवधारणाएं हैं जो कुछ निश्चित टकराव को हल करने के लिए उपयोग की जाती हैं, यह नामस्थान टक्कर संकल्प कहा जाता है।
तो, यह एक विशेष जावा कीवर्ड कॉल के माध्यम से हासिल किया गया है;
यह।
इसलिए, हम इस व्याख्यान में इसके बारे में जानेंगे।
तो, हमारे पास डेमो है।
इसलिए, पहले, हम इस बात पर चर्चा करेंगे कि हम एक कक्षा कैसे बना सकते हैं।
हम एक कार्यक्रम पर बहुत छोटे कार्यक्रम पर चर्चा करेंगे;
हमें एक बहुत छोटा कार्यक्रम है।
हमारी सैद्धांतिक चर्चा में, हमने सर्कल नामक एक वर्ग पर चर्चा की है।
इसलिए, यहां हम देख सकते हैं कि यह है;
हाइलाइटर कहां है
इसलिए, यहाँ हम देखते हैं कि हम यहाँ वर्ग वृत्त घोषित करते हैं।
तो, इस वर्ग वृत्त में 3 डेटा हैं अर्थात् x, y और r तीनों डेटा को डबल घोषित किया गया है।
इस डेटा के अलावा भी इस वर्ग के दो तरीके हैं;
एक परिधि है और दूसरा क्षेत्र है।
तो, दो विधियों को यहां परिभाषित किया गया है।
तो, यह सर्कल नामक एक वर्ग की परिभाषा को पूरा करता है।
अब, इस वर्ग के घोषित होने के बाद आप इस कक्षा को एक अलग फ़ाइल या उसी फ़ाइल में रख सकते हैं जहाँ मुख्य वर्ग शामिल होगा।
अब यहां निम्नलिखित में, हम मुख्य वर्ग पर चर्चा करते हैं जो उसी फ़ाइल में सहेजा गया है।
इस मामले में मुख्य वर्ग का नाम प्रदर्शन 31 है।
अब इस कक्षा में, आप देखते हैं कि हम वर्ग प्रकार c वृत्त की एक वस्तु कैसे बना सकते हैं।
इसलिए, हम ऑब्जेक्टिव c के नाम से एक ऑब्जेक्ट बनाते हैं और एक ऑब्जेक्ट बनाने के लिए, आप इसे उस नए ऑपरेटर को नोट कर सकते हैं जिसका उपयोग यहां किया गया है।
तो, नया और फिर दोबारा सर्कल और फिर कोष्ठक के भीतर, यह मूल रूप से एक वस्तु घोषित करने के लिए सामान्य वाक्यविन्यास है।
इसलिए, इस कथन के साथ, हम एक वस्तु की घोषणा करते हैं, जिसे c ऑब्जेक्ट बनाया जाता है;
हालाँकि, अलग है
इस ऑब्जेक्ट के लिए मौजूद डेटा को अभी इनिशियलाइज़ किया जाना है।
इसलिए, निम्नलिखित तीन कथनों में हम सदस्यों x, y और r को 0.0, 0.0 और 5.0 के मान से आरंम्भित करते हैं।
तो, यह एक वस्तु का निर्माण पूरा करता है, इस मामले में, उद्देश्य का नाम c है।
अब एक बार यह ऑब्जेक्ट बन जाने के बाद, हम इस ऑब्जेक्ट में किसी भी मूल्य तक पहुँच सकते हैं।
इसलिए, अगले बयान में, हम केवल उस सर्कल की परिधि को चित्रित करते हैं जो हमने बनाई है।
अब विधि परिधि तक पहुँचने के लिए, आप ध्यान दें कि हम c.circumference का उपयोग करते हैं।
तो, इसका मतलब है कि हम ऑब्जेक्ट c की विधि परिधि कहते हैं।
अगले बयान में फिर से, हम ऑब्जेक्ट सी के विधि क्षेत्र को कहते हैं।
इस कथन में इसका अर्थ है, हम उस सर्कल के क्षेत्र को प्रिंट करने में सक्षम होंगे, जिसे हमने अभी बनाया है, अब हमारे पास डेमो है।
हम इस कार्यक्रम को संकलित करेंगे क्योंकि यहाँ मुख्य वर्ग का नाम प्रदर्शन_31 है।
हमें इस फ़ाइल को प्रदर्शन_31.java के रूप में सहेजना चाहिए और फिर हम c के java का उपयोग करके संकलन कर सकते हैं।
तो, हम संकलन javac प्रदर्शन ठीक देखते हैं।
इसलिए, हम इसे संकलित करते हैं क्योंकि कोई त्रुटि नहीं है।
इसलिए, संकलन सफल है, हम जावा कमेंट का उपयोग करके इस प्रोग्राम को चला सकते हैं जावा एक दुभाषिया है।
इसलिए, इस प्रोग्राम को चलाएं और आप इस प्रोग्राम को रन करते हुए देखें और फिर यहां सर्कल में परिधि जो कि 39.4159 और एरिया की गणना 75 की है।
अब, हमने सीखा है कि कैसे एनकैप्सुलेशन के रूप में यहां एनकैप्सुलेशन संभव है, हम एक वर्ग सर्कल बनाते हैं और इस वर्ग के लिए, हमने एक ऑब्जेक्ट बनाया।
अब यहाँ यह प्रश्न उठता है कि क्या हम एक प्रोग्राम में केवल एक ही ऑब्जेक्ट बना सकते हैं या एक प्रोग्राम में कई ऑब्जेक्ट।
इसका उत्तर यह है कि एक वर्ग के लिए कई वस्तुओं का निर्माण किया जा सकता है, यहां तक ​​कि कई वस्तुओं के लिए भी बनाया जा सकता है, अन्य वर्गों के लिए भी।
अब, हमारे अगले प्रदर्शन में, हम देखेंगे कि एक ही वर्ग के लिए यह कैसे कहें कि सर्किल कई सर्कल बनाए जा सकते हैं और हमें यहाँ डेमो दें।
फिर से हम यहाँ सर्कल वर्ग की उसी घोषणा का उपयोग करते हैं।
यह पहले की तरह सामान्य है।
अब केवल हम मुख्य कार्यक्रम मुख्य वर्ग को बदलते हैं।
इसलिए, इस मुख्य वर्ग को प्रदर्शन_32 नाम दें।
अब यहाँ हम देख सकते हैं, हमने दो ऑब्जेक्ट्स c1 और c2 बनाए हैं।
पहले के उदाहरण में, हमने केवल एक ऑब्जेक्ट बनाया है, यहां हमने दो ऑब्जेक्ट बनाए हैं और इन दो ऑब्जेक्ट के लिए c 1 और c 2।
हम इसके डेटा मानों को पहले ऑब्जेक्ट xy और r के लिए तीन 3.0, 4.0, 5.0 इनिशियलाइज़ करते हैं।
जबकि, दूसरी वस्तु c 2 के लिए, हमने -4.0, -8.0, 10.0 के साथ मानों का एक ही सेट शुरू किया।
इस प्रकार दो ऑब्जेक्ट बनाए जाते हैं और उनके डेटा को भी इनिशियलाइज़ किया जाता है।
अब, अगले 4 कथनों में, हम देखते हैं कि कैसे हम इन दो वस्तुओं की परिधि और उसके क्षेत्र में अलग-अलग तरीकों तक पहुँच सकते हैं।
तो, यह वही है जैसा कि पहले का कार्यक्रम स्वीकार करता है कि दो अलग-अलग वस्तुओं के लिए हमने इसका उपयोग किया है।
अब इसके लिए हमारे पास डेमो है।
तो, इस मामले में, दो ऑब्जेक्ट बनाए जाते हैं और आप यहां दो ऑब्जेक्ट्स के मान प्राप्त कर पाएंगे।
इसलिए, एक ही प्रक्रिया हम इसे संकलित कर सकते हैं और फिर हम इसे चला सकते हैं।
तो, अब, हम दो अलग-अलग वस्तुओं को देख सकते हैं और जैसे-जैसे वस्तुएं अपना क्षेत्र अलग करती हैं और फिर मुद्रित क्षेत्र भी भिन्न होता है।
तो, अब हम समझ गए हैं कि एक क्लास के लिए कई ऑब्जेक्ट्स कैसे बनाए जा सकते हैं।
इस मामले में, हमने माना है कि बड़ी संख्या में एक ही वर्ग के ऑब्जेक्ट बनाए जा सकते हैं।
अब, हमारे अगले प्रदर्शन में यह है कि एक कार्यक्रम में एक से अधिक कक्षाएं शामिल हो सकती हैं या नहीं।
इसलिए, इस प्रदर्शन में वही शामिल है।
अब यहां हम एक वर्ग का नाम शामिल करते हैं, जिस सर्कल की पहले जैसी परिभाषा है।
इस वर्ग के अलावा, हम एक और वर्ग की घोषणा करते हैं, इस वर्ग का नाम जो दिया गया है, उसे बॉक्स कहा जाता है।
इस क्लास बॉक्स में 3 डेटा फील्ड, चौड़ाई, ऊंचाई और गहराई है।
इन 3 क्षेत्रों के अलावा, इसमें 3 2 विधियाँ भी हैं जिनका क्षेत्र और आयतन है।
आप ध्यान दें कि क्लास बॉक्स में जिस विधि क्षेत्र को परिभाषित किया गया है वह पूरी तरह से अलग तरीका है जो क्लास सर्कल के लिए परिभाषित किया गया है।
तो, दो विधियों को दो वर्गों में परिभाषित किया गया है, लेकिन वे अलग हैं;
वे वही नहीं हैं जिन्हें हमने अलग तरीके से परिभाषित किया है।
दूसरी ओर, परिधि वर्ग सर्कल में एक अनूठी विधि है जहां वॉल्यूम भी क्लास बॉक्स में एक अनूठी विधि है।
तो, इस तरह हम दो वर्गों को बनाते हैं जैसे कि सर्कल और बॉक्स, हम इन सभी दो वर्गों को एक ही फाइल में मुख्य वर्ग के रूप में सहेज सकते हैं।
अब हम मुख्य वर्ग के रूप को देखते हैं, हम मुख्य वर्ग का नाम डेमॉन्सेशन_33 देते हैं।
यह मुख्य वर्ग है जिसमें मुख्य विधि शामिल है और अब आप देखते हैं कि इस मुख्य विधि में, हम दो ऑब्जेक्ट बनाते हैं टाइप क्लास का एक ऑब्जेक्ट सर्कल क्लास बॉक्स का एक और ऑब्जेक्ट।
तो, यहाँ दो ऑब्जेक्ट्स c c और छोटा b बनाया गया है।
अब, फिर से जैसे ही यह सर्कल के मामले में था, हम मूल्य को इनिशियलाइज़ करते हैं।
यहाँ उन वस्तुओं को भी बनाया गया है जिन्हें हमने उनके मूल्यों को आरंभ करने के लिए बनाया है।
इसलिए, यहां पहले कथन में, हम बनाते हैं कि हम सर्कल वस्तुओं के मूल्य को 3.0, 4.0 और 5.0 के साथ आरंभ करते हैं, जबकि बॉक्स ऑब्जेक्ट के लिए हम मान 3.0, 4.0, 5.0 के रूप में चौड़ाई की ऊंचाई और गहराई के मूल्य को प्रारंभिक करते हैं।
तो, यह दो अलग-अलग वर्गों की दो अलग-अलग प्रकार की वस्तुओं के निर्माण को पूरा करता है।
अब, अगले चार कथनों में, हम विभिन्न तरीकों तक पहुँच सकते हैं।
जैसा कि हमने यहां सर्कल सी के लिए देखा है, हम क्षेत्र और परिधि तक पहुंचते हैं और बॉक्स बी के लिए हम क्षेत्र और वॉल्यूम तक पहुंचते हैं।
अब हमारे पास इस कार्यक्रम का निष्पादन है, हम यह देख पाएंगे कि जिन दो वस्तुओं को वे अपनी कक्षाओं के संदर्भ में परिभाषित करते हैं और फिर वे मुख्य विधि द्वारा पहुंच सकते हैं।
तो, अब, हम देख सकते हैं कि पहले दो प्रिंटआउट मूल रूप से हैं
प्रदर्शित करते हैं।
सर्कल परिधि और क्षेत्र और अगले दो आउटपुट बॉक्स के बॉक्स क्षेत्र और बॉक्स नाउ की मात्रा के लिए है, हमने समझा है कि कितने वर्ग बनाए जा सकते हैं।
यह आवश्यक नहीं है कि मुख्य कक्षा में सभी वर्गों को एक ही फाइल में रखा जाए।
हम आपके कार्यक्रम में उन कक्षाओं के संगठन के बारे में चर्चा करेंगे जिनके बारे में अभी समय पर चर्चा की जाएगी।
तो, अब, देखते हैं कि जब हम ऑब्जेक्ट बनाते हैं तो हम कहां देख सकते हैं।
इसलिए, इसे शुरू करना हमारी जिम्मेदारी है।
किसी ऑब्जेक्ट के ऑब्जेक्ट इनिशियललाइज़ेशन का मतलब ऑब्जेक्ट से संबंधित सभी मेंबर एलिमेंट्स को इनिशियलाइज़ करना है।
उदाहरण के लिए, बॉक्स की चौड़ाई और गहराई के लिए सर्कल xyr के लिए, हमें आरंभीकरण करना होगा, लेकिन यह आरंभीकरण जैसा कि हमने किया है।
पिछले कुछ उदाहरणों में, आरंभीकरण थोड़ा थकाऊ है क्योंकि हमें इसे वैसे भी जबरदस्ती करना है, लेकिन आरंभीकरण को हमारे अगले कार्यक्रम में अधिक परिष्कृत तरीके से किया जा सकता है।
हम देखेंगे कि वस्तुओं का आरंभ कैसे आसान तरीके से किया जा सकता है।
तो, यहाँ एक उदाहरण एक 3.4 सही चलो हमें देखते हैं।
तो, अब, हमने यहां एक घोषित किया है, एक और वर्ग बिंदु इसके दो सदस्य तत्व हैं x और y को पूर्णांक घोषित किया है।
इस मामले में इसकी कोई विधि नहीं है।
वैसे भी, हम चर्चा करना चाहते हैं कि इस xy मूल्य को कैसे आरंभ किया जा सकता है।
अब यहां यदि आप देखें, तो यह सामान्य प्रक्रिया है कि हम प्रकार वर्ग का एक ऑब्जेक्ट बना सकते हैं और इस चीज के लिए, हम मुख्य प्रोग्राम से मूल्य को इनिशियलाइज़ कर सकते हैं।
यह एक सामान्य प्रक्रिया है जिसे आपको इस प्रक्रिया से अलग सीखना होगा।
अब, हम चर्चा करेंगे कि कुछ तरीकों को कॉल करके हम कैसे इनिशियलाइज़ कर सकते हैं।
अब हां, इस बात को करने के लिए हमें क्लास प्वाइंट में ही एक विधि घोषित करनी होगी।
अब हम अगली कक्षा 3.5 को एक डेमो के रूप में देखते हैं, हम देख सकते हैं कि क्लास प्वाइंट एक और विधि से थोड़ा पुनर्परिभाषित है। , यह x को 10 के बराबर और y को 10 के बराबर करेगा।
अब, अगले दो कथनों में यदि हम ऑब्जेक्ट p के x और y का मान प्रिंट कर सकते हैं, तो इसे इस तरह प्रिंट किया जाएगा।
अब हम इस प्रोग्राम को चलाते हैं।
हम उत्तीर्ण हुए
इसका अर्थ है, इस स्थिति में, हमने जो उद्देश्य p बनाया है, उसे इसके x मान के साथ 15 और y मान से 20 के रूप में प्रारंभ किया जा सकता है।
अब, हम इस प्रोग्राम को चलाते हैं और फिर एक क्विक डेमो देते हैं।
तो, 3.6, सही है।
अब हम इसे चलाते हैं और हम देखेंगे कि ऑब्जेक्ट डेटा सदस्य 1520 के रूप में प्रिंट होगा।
अब हम प्रोग्राम पर आते हैं, हम इस विधि को कॉल कर सकते हैं या हम एक और ऑब्जेक्ट कह सकते हैं p 1 और p 2।
हम यहाँ दो ऑब्जेक्ट्स p 1 और p 2 बना रहे हैं;
पी 1 और पी 2 ठीक है। विधि अब, यहां एक विचार है कि हमें विधि को घोषित करने और परिभाषित करने के माध्यम से स्पष्ट रूप से ऑब्जेक्ट को इनिशियलाइज़ करना है।
तो, हमारे पास एक सरल प्रोग्राम है जो मूल रूप से ऑब्जेक्ट्स को स्वचालित रूप से बनाने और फिर इसे इनिशियलाइज़ करने में मदद करता है।
अब हमारे यहाँ कार्यक्रम है।
अब कक्षा फिर से हम वर्ग सर्कल के साथ इस प्रदर्शन को जारी रख सकते हैं इस वर्ग सर्कल में 3 सदस्य तत्व x y r दो विधियाँ परिधि और क्षेत्र हैं।
अब, हम एक विधि की घोषणा करते हैं।
ह एक नई विधि है जिसे हमने इस कक्षा में इस विधि के नाम से जोड़ा है।
आप देखते हैं कि कक्षा के नाम के समान ही है।
यह एक अनोखी बात है कि विधि का नाम वर्ग के नाम के समान है और आप इस मामले में भी ध्यान दे सकते हैं कि इस पद्धति का कोई रिटर्न प्रकार नहीं है।
तो, इसे एक कंस्ट्रक्टर कहा जाता है, जिसका मूल रूप से वर्ग के नाम के समान ही नाम है और इसमें कोई रिटर्न प्रकार नहीं होना चाहिए, अब यहां सर्किल के लिए कंस्ट्रक्टर का नाम है और इस कंस्ट्रक्टर को 3 तर्कों के साथ परिभाषित किया गया है।
ये तीनों तर्क यहाँ डबल ए बी और सी के हैं।
मूल रूप से, एक तर्क है जिसे मान x में दिया जाएगा, b एक और तर्क है जिसका मान y और c को दिया जाएगा। एक और तर्क है जिसका मान r को दिया जाएगा।
इसका अर्थ है कि यदि हम 3 मानों को पारित करने वाली एक वस्तु बना सकते हैं और इन तीन मूल्यों का उपयोग इसके सदस्य तत्व को आरंभ करने के लिए किया जाएगा।
अब सर्किल को परिभाषित करने के बाद हमारे पास मुख्य क्लास है। ऑब्जेक्ट बनाने के समय हम जिन वस्तुओं को यहाँ देखते हैं, उन्हें हम इनिशियलाइज़ कर सकते हैं।
इसलिए, हम यहां नए ऑपरेटर का उपयोग करके ऑब्जेक्ट बना रहे हैं।
अब पहली रचना में, हम ऑब्जेक्ट सी 1 बनाते हैं और हमने 3 मान 3.0, 4.0, 5.0 पारित किए हैं।
इसका मतलब यह है कि कंस्ट्रक्टर, यह विधि सर्किल कहलाएगा जो कि कंस्ट्रक्टर विधि है और इस मान को सर्किल ऑब्जेक्ट्स c 1 में पास करें।
इसी तरह, सी 2 ऑब्जेक्ट्स को इनिशियलाइज़ किया जाएगा।
दीक्षा समाप्त होने के बाद, विधि तक पहुँचा जा सकेगा और फिर विधि विधि की गणना या परिभाषा के अनुसार विभिन्न मूल्यों को प्रिंट करेगी।
अब, हमारे पास निष्पादन पहले जैसा ही है।
यह अब तक अलग नहीं है, संकलन निष्पादन का संबंध है;
हालाँकि, परिणाम के दृष्टिकोण से, यह आरंभीकरण का अधिक परिष्कृत तरीका है।
इसलिए, हमने उस समय ऑब्जेक्ट बनाया है जब हमने ऑब्जेक्ट्स बनाने के समय ऑब्जेक्ट को इनिशियलाइज़ किया है और फिर कंस्ट्रक्टर के माध्यम से यह कॉन्सेप्ट कंस्ट्रक्टर कहलाता है जैसा कि मैंने आपको बताया था।
अब, निर्माता के पास इसके अधिक आयाम हैं।
इस अर्थ में कि यह किसी प्रोग्रामर को किसी ऑब्जेक्ट को अलग तरीके से इनिशियलाइज़ करने के लिए बहुत अधिक लचीलापन देता है।
अब अगर हम अगर आप ऑब्जेक्ट को अलग तरीके से इनिशियलाइज़ करना चाहते हैं तो आपको परिभाषित करना होगा।
तो, अपनी आवश्यकता के लिए कई निर्माणकर्ता अब इस अवधारणा को कंस्ट्रक्टर ओवरलोडिंग कहा जाता है, अब यहां फिर से क्लास सर्किल की चर्चा पर आते हैं, पिछले उदाहरण में हमने चर्चा की है कि हम तीन तर्कों के साथ एक कंस्ट्रक्टर के माध्यम से स्वत: आरंभीकरण कैसे करते हैं इसे परिभाषित किया है।
अब, इसके अतिरिक्त, हम आरंभीकरण के एक और तरीके को परिभाषित करना चाहते हैं।
यहां अगले कंस्ट्रक्टर में जिसे हमने घोषित किया है।
यदि आप देखते हैं, तो इस निर्माता के पास केवल एक तर्क डबल c है और निर्माणकर्ता को इस तरह परिभाषित किया जाता है यदि हम एक तर्क के साथ एक निर्माता को बुलाते हैं, तो यह उनके सदस्य तत्वों को x बराबर 0 y बराबर 0 और r बराबर 0 के बराबर कर देगा। इस परिभाषा के लिए के रूप में।
इसका मतलब है कि यदि हम केवल 1 तर्क से गुजरने वाली वस्तु बनाते हैं, तो जावा रनटाइम कंपाइलर स्वचालित रूप से समझ जाएगा कि इस निर्माता को आमंत्रित किया जाना चाहिए।
यदि हम 3 तर्कों को पारित करने वाली एक वस्तु बनाते हैं, तो पहले निर्माता को बुलाया जाएगा।
अब यहां फिर से आप तीसरे निर्माता को देखते हैं जिसे हमने यहां परिभाषित किया है।
यह थोड़ा अलग है;
यहाँ हम एक तर्क पारित कर सकते हैं जो कि स्वयं वस्तु है जो काफी संभव है।
तो, यहाँ सर्कल c एक अन्य ऑब्जेक्ट है जिसे पास किया गया है। अगर हमने इसे पारित किया है तो इसका मतलब है कि नई वस्तु जो सर्किल c के समान डेटा सदस्य के रूप में बनाई जाएगी
यहाँ।
तो, यह एक निर्माता है;
इसका मतलब है, एक डुप्लिकेट एक वस्तु को इस अर्थ में एक डुप्लिकेट ऑब्जेक्ट बनाया जा सकता है कि वे अलग-अलग ऑब्जेक्ट हैं;
हालाँकि, समान डेटा मान होना।
दूसरे तरीके को डिफ़ॉल्ट कंस्ट्रक्टर कहा जाता है।
यदि आप किसी तर्क को पास किए बिना किसी कंस्ट्रक्टर को परिभाषित करते हैं, तो उसे डिफॉल्ट कंस्ट्रक्टर कहा जाता है। ।
तो, इस मामले में, अंतिम निर्माणकर्ता को श्रृंखला में चौथा निर्माणकर्ता डिफ़ॉल्ट निर्माता कहा जाता है।
यहां डिफ़ॉल्ट कंस्ट्रक्टर का अर्थ है कि x 0.0 के बराबर है, y 0.0 के बराबर है, r 0.0 के बराबर है।
अब हम मुख्य कार्यक्रम करते हैं।
तो, मुख्य कार्यक्रम यहाँ मुख्य वर्ग प्रदर्शन_39 के माध्यम से परिभाषित किया गया है।
अब यहाँ हम देखते हैं कि हमने 4 ऑब्जेक्ट बनाए हैं और प्रत्येक ऑब्जेक्ट को उनके स्वयं के कंस्ट्रक्टर के साथ बनाया गया है।
तो, पहले ऑब्जेक्ट को पहले कंस्ट्रक्टर के साथ दूसरे ऑब्जेक्ट के साथ और दूसरे कंस्ट्रक्टर के साथ तीसरे ऑब्जेक्ट के साथ बनाया जाता है और अंत में, यह यहाँ ठीक है।
इसलिए, यहाँ, यदि आप c3 और c1 देखते हैं, जब हम ऑब्जेक्ट c3 बनाते हैं, तो हम c1 c1 पास करते हैं, जो कि एक वर्ग वृत्त का एक ऑब्जेक्ट है, जो तीसरे कंस्ट्रक्टर डिक्लेरेशन के लिए है।
और बाकी चीजें मूल रूप से अलग-अलग पैरामीटर क्षेत्र को प्रिंट कर रही हैं और चार सर्कल के लिए परिधि जो हमने बनाई हैं और निश्चित रूप से सी 1 और सी 1 सी 3 को एक ही परिणाम देना चाहिए।
अब हम प्रदर्शन करते हैं।
तो, हमारे पास क्विक डेमो है, अब हम कंस्ट्रक्टर को ओवरलोड कर रहे हैं।
तो, सभी 4 ऑब्जेक्ट स्वचालित रूप से और ऑब्जेक्ट बनाए जाते हैं
निर्माण के समय वस्तु के निर्माण के समय निर्मित होते हैं;
मेरा मतलब है घोषणा करना और मूल्यों को पारित करना।
तो, यह ओवरलोडिंग निर्माणकर्ताओं के बारे में है।
अब इस वर्ग और फिर ऑब्जेक्ट कंस्ट्रक्टर के बारे में कुछ और महत्वपूर्ण और दिलचस्प तथ्य हैं।
हम बस जल्दी से एक अवधारणा पर चर्चा करना चाहते हैं जिसे यह कीवर्ड कहा जाता है।
यदि हम इस उदाहरण का अनुसरण करते हैं तो इस अवधारणा को बहुत आसानी से समझा जा सकता है।
अब हम एक कक्षा को छात्र घोषित करने की घोषणा करते हैं।
यहां, इस वर्ग में चार सदस्य तत्व हैं।
यहां पूर्णांक संख्या नाम और पाठ्यक्रम स्ट्रिंग प्रकार के रूप में और फिर फ्लोट के रूप में कुंजी।
अब, फिर से, हम देखते हैं कि यह कंस्ट्रक्टर घोषणा, रोल नंबर, नाम, स्ट्रिंग कोर्स और यह है
अब यहां आप उन तर्कों को नोट कर सकते हैं जो हमने पास किए हैं, उनका नाम है और इस मामले में, डेटा सदस्यों के नाम भी समान हैं।
अब अगर हम आरंभ करने की कोशिश करते हैं तो निश्चित रूप से।
इसलिए, रोल नंबर के लिए रोल नंबर के बराबर होता है, तो यह सही समान नाम नहीं है नाम के बराबर है यह थोड़ा अस्पष्ट भी है।
तो, आप क्या कर सकते हैं कि हम इसे इस एक के माध्यम से परिभाषित कर सकते हैं।
तो, यह रोल नंबर इंगित करता है कि यह रोल नंबर इस वर्ग के सदस्य का है, जबकि केवल रोल नंबर ही वह तर्क है जो इसी तरह पारित किया गया है। यह निर्दिष्ट करें कक्षा के सदस्यों का नाम और यह नाम सदस्य का नाम लिखें। कक्षा पाठ्यक्रम।
अब तो, अगर हम इसे चलाते हैं, तो हम देखेंगे कि हम अगले भाग पर चर्चा कैसे करेंगे।
आइए हम देखें कि हम इसका उपयोग कैसे कर सकते हैं।
तो, यह मूल रूप से यह कीवर्ड है जो मूल रूप से नेमस्पेस टकराव को हल करने में मदद करता है।
तो, इस मामले में, रोल नंबर का नाम और पाठ्यक्रम डेटा सदस्य के साथ टकरा जाता है।
तो, इसे हल करने के लिए, हम इस कीवर्ड का उपयोग कर सकते हैं।
इसलिए, यहां हमने इसका उपयोग किया है और फिर हमने इसे पारित किया है।
अब, आप पहली बार देख सकते हैं जब ऑब्जेक्ट को जावा 0.0 रखने के लिए पहला ऑब्जेक्ट बनाया गया है और अब हमें दूसरे तरीके से आने दें।
अब, यह बिंदु आइए हम एक और 3.11 में इस कीवर्ड के विशेष उपयोग के लिए आते हैं। 3.11 डेमो चलाते हैं। ।
अब हम यहां और अधिक महत्वपूर्ण बात पर चर्चा करेंगे।
अब फिर से सर्कल के संदर्भ में इस कीवर्ड को बहुत सटीक रूप से समझा जा सकता है।
तो, यहाँ फिर से, कंस्ट्रक्टर, हम देख सकते हैं कि कंस्ट्रक्टर को x y r के साथ परिभाषित किया गया है, जिसका सदस्य तत्व के समान नाम है और हम इसका उपयोग करके इसे हल करते हैं, यह उसी चीज़ पर लागू होता है जो दूसरे पर भी लागू होता है।
इसलिए, यदि हम कुछ नाम को हल करना चाहते हैं, जो उसी श्रेणी का है जिसमें अन्य चर है।
अतः हमें इसका उपयोग करना चाहिए।
तो, यह जावा प्रोग्राम में इस कीवर्ड का एक उपयोग है। अब जावा प्रोग्राम में इस प्रोग्राम का एक और उपयोग है, इन चीजों को समझने के लिए हमें एक साधारण प्रोग्राम बनाने दें;
कार्यक्रम 3.12 है।
अब, यहां हम देख सकते हैं कि इसका उपयोग कुछ अन्य फायदे देखने के लिए किया जा सकता है।
यहाँ हमारे पास प्रोग्राम बहुत सरल है, इसे समझना बहुत आसान है।
A वह वर्ग है जो यहां घोषित किया गया है और इसमें एक विधि m एक अन्य विधि n है।
मेथड एम बस हेलो एम प्रिंट करेगा, एन भी केवल एक स्ट्रिंग हेल्लो एन प्रिंट करेगा।
अब, यदि हम उसी विधि को किसी अन्य विधि से एक्सेस करना चाहते हैं, तो निश्चित रूप से हमने केवल यह सीखा है कि किसी विधि तक पहुँचने के लिए हमें एक वस्तु बनानी चाहिए।
लेकिन जब भी हम कोई विधि घोषित कर रहे हैं या किसी विधि को परिभाषित कर रहे हैं तो कोई भी वस्तु बनाने का सवाल ही नहीं है।
अब यदि वस्तुएं समान हैं;
इसका मतलब है, यदि आप उस विधि का उपयोग करना चाहते हैं जो एक ही कक्षा में है, तो हम इसे शाम को निर्दिष्ट करके हल कर सकते हैं।
उदाहरण के लिए, विधि v शून्य में, हम उस विधि m को कहते हैं जिसे इस वर्ग में ही परिभाषित किया गया है।
तो, इसे हल करने के लिए, हमने इस सुबह का उपयोग किया। इसका मतलब है कि शून्य n जब भी हम उदाहरण के लिए यहां बनाई गई एक नई वस्तु के लिए कॉल करते हैं, तो ए यह विधि मीटर के साथ-साथ विधि n भी कहेगा।
तो, यह तो, इसलिए, जब ए;
इसका मतलब है, हम विधि को n कहते हैं;
यह hello n प्रिंट करेगा और फिर यह उस हैलो m को प्रिंट करेगा।
अब हमें इस कार्यक्रम का त्वरित निष्पादन करना है, ताकि हम इस बारे में समझ सकें।
तो, यह एक विधि है जिसे आप देखते हैं।
तो, क्लास ए घोषित है और ए कंस्ट्रक्टर है कंस्ट्रक्टर की परिभाषा पर जाएं वहां एक कंस्ट्रक्टर ठीक है।
हम ए कंस्ट्रक्टर को मंजूरी दे रहे हैं;
अब, यहाँ, कंस्ट्रक्टर दो कंस्ट्रक्टर हैं पहला कंस्ट्रक्टर ठीक है।
चलिए दूसरे कंस्ट्रक्टर पर आते हैं, दूसरा कंस्ट्रक्टर क्या है जो हम दूसरे कंस्ट्रक्टर को एक तर्क पास करने के माध्यम से परिभाषित करते हैं फिर पूर्णांक टाइप करते हैं।
तो, इसका मतलब है कि यह इस एक को पसंद करेगा।
अब यहां एक डिफ़ॉल्ट निर्माणकर्ता जो परिभाषित करता है कि मूल रूप से एक डिफ़ॉल्ट मान द्वारा आरंभ किया गया है 5।
लेकिन उस इंस्टॉलेशन कॉलिंग को पहले से परिभाषित कंस्ट्रक्टर यानी ए इंटेक्स।
इसलिए, यदि आप किसी अन्य निर्माता के भीतर किसी भी निर्माता को कॉल करना चाहते हैं, तो आप इसका उपयोग कर सकते हैं और फिर पैरामीटर मानों को निर्दिष्ट कर सकते हैं जो आप चाहते हैं कि अब हम इस कार्यक्रम का निष्पादन करें।
इसलिए, यह मूल रूप से एक कंस्ट्रक्टर में एक निर्माता को बुलाता है और यह कंस्ट्रक्टर मूल रूप से एक नेस्टिंग प्रकार का है, यह ओवरलोडिंग कंस्ट्रक्टर का हिस्सा भी है।
तो, निष्पादन है।
इसलिए, आप देख सकते हैं कि जब भी हम इस कथन में एक वस्तु को नए ए के बराबर बनाते हैं, तो हम पहले निर्माणकर्ता को डिफ़ॉल्ट निर्माता कहते हैं जब भी पहला निर्माणकर्ता इसे मूल रूप से मान 5 के साथ सदस्य तत्वों को इनिशियलाइज़ करता है।
हमारे पास वास्तव में कोई सदस्य नहीं है, मान 5 है जिसे क्लास ऑब्जेक्ट में पास किया गया है और फिर इस वैल्यू x का उपयोग करके हैलो को प्रिंट करता है।
तो, मूल रूप से, यह मूल रूप से 5 के रूप में प्रिंट करता है।
तो, यह तरीका है।
अब हमारे पास अंतिम दिन का डेमो है जिसे समझना अधिक दिलचस्प है।
तो, आखिरी डेमो, इसे समझना आसान होगा।
अब फिर से सर्कल क्लास।
हम निर्माण करते हैं एक निर्माता मूल रूप से 3 मापदंडों का उपयोग कर रहा है।
अब, इस निर्माणकर्ता का उपयोग इस तरीके के माध्यम से किसी अन्य निर्माता को परिभाषित करने के लिए किया जा सकता है।
इसलिए, उदाहरण के लिए, दूसरा जिसे हम उसी कंस्ट्रक्टर को यहां का उपयोग करके कॉल करते हैं और 0.0 पास करते हैं, 0.0 आर इसी तरह का दूसरा कंस्ट्रक्टर है जिसे हम इस c.x c.y c.r.
यहाँ यह और यह सब मूल रूप से एक विशेषाधिकार निर्माता को इंगित करता है जो कि तीन पैरामीटर हैं और स्वचालित रूप से इसे उन्हें कहते हैं।
इसलिए, इस तरह से मूल रूप से इसी तरह के कार्यक्रम में थोड़ा बदलाव आया है जिस पर हमने पहले चर्चा की है कि ये इस ऑपरेटर का उपयोग हैं।
इसलिए, हमने कंस्ट्रक्टर ओवरलोडिंग पर चर्चा की है और मैं सिर्फ पिछली बातों का उल्लेख करना चाहता हूं।
इसलिए, जो निर्माणकर्ता ओवरलोडिंग से संबंधित है, वह निर्माणकर्ताओं से अलग माना जा सकता है;
यदि वे तर्क की संख्या और तर्कों के प्रकार के संदर्भ में भिन्न हैं।
तो, यह केवल ऐसी चीजें हैं जो आप पहले से ही इसके बारे में महसूस कर सकते हैं और यदि आप सभी उदाहरणों के माध्यम से जा सकते हैं, तो आप यह समझ पाएंगे कि सभी तीन निर्माणकर्ता या जो भी निर्माणकर्ता हैं वे अलग-अलग तर्क के कारण अलग हैं कि हम ठीक है
तो, यह हमारे प्रदर्शन को समापन पर समाप्त करता है।
आपका बहुत बहुत धन्यवाद।
कम्प्यूटर साइंस इंजीनियरिंग इंडियन इंस्टीट्यूट ऑफ टेक्नोलॉजी, खड़गपुर लेक्चर का सामंत विभाग - 20 इंटरफेस - I सो, प्रदर्शन सहित अंतिम मॉड्यूल में;
हमने जावा में पैकेज के बारे में सीखा है।
अब जावा में दो चीजें हैं जो जावा प्रोग्रामिंग को अद्वितीय बनाती है एक पैकेज और इंटरफ़ेस है।
और यही कारण है कि जावा प्रोग्रामिंग मूल रूप से अन्य प्रोग्रामिंग भाषाओं की तुलना में अधिक लोकप्रिय है, विशेष रूप से बहुत बड़े और जटिल सॉफ़्टवेयर के निर्माण के लिए।
तो, आज हम इंटरफ़ेस की अवधारणा पर आज और अगले मॉड्यूल में चर्चा करेंगे।
दरअसल, चर्चा को पूरा करने के लिए मुझे व्याख्यान के घंटों का मतलब है कि हम इसे पूरा करने के लिए दो मॉड्यूल लेंगे।
वैसे भी, आज हमारे पास इंटरफ़ेस की कुछ बुनियादी अवधारणा है और फिर अन्य कुछ अन्य अवधारणाओं पर भी अगले मॉड्यूल में चर्चा की जाएगी।
तो, हम इंटरफ़ेस के बारे में शुरू करते हैं, लेकिन इंटरफ़ेस के बारे में सबक लेने से पहले हम अमूर्त वर्ग से शुरू करना चाहते हैं।
जब हम वंशानुक्रम पर चर्चा कर रहे हैं, तो हम पहले ही चर्चा कर चुके हैं।
इसलिए, एक क्लास को एब्सट्रैक्ट क्लास के रूप में घोषित किया जा सकता है जैसा कि हम कीवर्ड एब्स्ट्रैक्ट को परिभाषित करके जानते हैं।
अब, हम इस उदाहरण पर एक बहुत ही सरल उदाहरण पर विचार करते हैं, कहते हैं, हम एक वर्ग को ज्यामिति को एक सार वर्ग घोषित करते हैं।
और फिर हम चाहते हैं कि इस अमूर्त वर्ग से कुछ कक्षाएं विरासत में मिलीं जैसे कि सर्कल, आयत और दीर्घवृत्त।
यहां, ज्यामिति मूल रूप से कहती है कि वस्तुओं का एक सेट ज्यामितीय वस्तुओं के बजाय और फिर अलग-अलग विशेष वस्तुएं हैं जो इस सभी ज्यामितीय वस्तुओं जैसे सर्कल, आयत और दीर्घवृत्त हैं।
अब, आइए हम इस बात पर एक नज़र डालें कि अमूर्त वर्ग की अवधारणा का उपयोग करके जावा में इस तरह का कार्यान्वयन कैसे किया जा सकता है।
इसलिए, यहां हम देख सकते हैं कि हमने एक बिल्ट इन एब्सट्रैक्ट क्लास बनाया है।
और फिर हमने इस क्लास को एक पैकेज में रखा।
पैकेज का नाम जैसा कि हम देखते हैं मेरा आकार पैकेज है।
और इस पैकेज के तहत, इसलिए इस वर्ग सार वर्ग को इन तीन सदस्यों द्वारा परिभाषित किया गया है।
एक पीआई को एक स्थिर और अंतिम के रूप में घोषित किया गया है और फिर क्षेत्र और परिधि दो सार तरीके हैं जिनकी हमने चर्चा की है।
जैसा कि आप जानते हैं कि एक अमूर्त वर्ग में अमूर्त विधियों के साथ-साथ ज्ञात अमूर्त विधि भी हो सकती है।
इस उदाहरण में, हम केवल दो सार विधियों को यहाँ शामिल करते हैं।
तो, उन्हें सार्वजनिक सार डबल क्षेत्र, सार्वजनिक सार डबल परिधि के रूप में घोषित किया जाता है।
तो, यह एक सार वर्ग की घोषणा है।
अब, हमारा उद्देश्य क्या है कि हमारा उद्देश्य अन्य वर्गों को बनाना है जो इस सार वर्ग से विरासत में मिल सकते हैं।
तो, यहां एक कोड है जिसे हम यहां देख सकते हैं सर्कल वर्ग जो मूल रूप से सुपरक्लास ज्यामिति से विरासत में मिला है।
इसके स्वयं के निर्माता हैं।
यहाँ द्विध्रुवीय रचनाकार हैं और एक अन्य रचनाकार केवल एक तर्क है।
इसलिए, दो निर्माणकर्ता यहां विधि क्षेत्र और फिर विधि परिधि को परिभाषित करेंगे।
और कुछ विधि जो इस वर्ग में अपने आप में अनूठी है।
जैसा कि हम देखते हैं कि ये दो विधियां हैं, जो कि अमूर्त विधि का कार्यान्वयन है।
जैसा कि हम देखते हैं कि ये दो विधियां हैं, जो कि अमूर्त विधि का कार्यान्वयन है।
यदि आप लागू नहीं करते हैं, तो आप इस वर्ग की कोई भी वस्तु नहीं बना पाएंगे, जिसे हमने अभी बनाया है।
वैसे भी यह वर्ग चक्र के निर्माण को पूरा करता है जो वर्ग सार वर्ग से विरासत है।
अब, इस वर्ग के खत्म हो जाने के बाद और अगला यह है कि दीर्घवृत्त वर्ग को फिर से इस अमूर्त वर्ग से कैसे विरासत में मिला जा सकता है।
इसलिए, हम तीन वर्गों को सार वर्ग अर्थात् सर्कल से विरासत में लेने जा रहे हैं।
और अब हम चर्चा करने जा रहे हैं हम इस पर चर्चा करने जा रहे हैं कि यह वृत्त वर्ग है।
और इसके बाद यह है कि सर्कल से एक विरासत एक और है जिसे आयत वर्ग कहा जाता है।
इसलिए, इस वर्ग के पास इस तरह का रूप है, हम देखते हैं कि यह एक सदस्य है जिसे इसे एक सुरक्षा के रूप में घोषित किया गया है;
इसका मतलब है, यह एल और डब्ल्यू अपने विरासत वर्ग के लिए सुलभ होगा।
और ये इस मामले में विधायक हैं।
और यह एक और कंस्ट्रक्टर है जिसमें दो तर्कों के साथ इसे पारित करना एक द्विध्रुवीय कंस्ट्रक्टर है और यह विशेष कंस्ट्रक्टर है।
इसलिए, यह वर्ग घोषणा है और जैसा कि हम यहां देखते हैं यह मूल रूप से है
ज्यामिति वर्ग से विरासत।
अब, अगली कक्षा जिस पर हम चर्चा करने जा रहे हैं, इस वर्ग में अन्य विधियाँ आ गई हैं जिन्हें यहाँ नहीं रखा गया है।
अब, अगली कक्षा जिस पर हम चर्चा करने जा रहे हैं, इस वर्ग में अन्य विधियाँ आ गई हैं जिन्हें यहाँ नहीं रखा गया है।
इसलिए, यह एक अन्य विधि है क्योंकि हम उस क्षेत्र को देखते हैं जिसे विरासत में एक सार के रूप में फिर से घोषित किया गया है।
तो, यह इस वर्ग के लिए यहां परिभाषित किया गया है, और यह एक परिधि है जो इस वर्ग के लिए है यह पुनर्परिभाषित है और ये अपने स्वयं के दो तरीके हैं जो इस वर्ग के लिए विशेष हैं।
तो, यह वर्ग आयत की घोषणा को पूरा करता है जो वर्ग ज्यामिति का एक उत्तराधिकार है।
अब, हमारी अगली कक्षा एक उदाहरण है यह एक दीर्घवृत्त है।
तो, हम फिर से व्युत्पन्न वर्ग को व्युत्पन्न करते हैं जो कि ज्यामिति से विरासत में मिला है, इसमें इस तरह की विधियाँ हैं।
और यह एक और कंस्ट्रक्टर है कुछ और चीजें भी यहां हैं।
इसलिए, यह मूल रूप से इस वर्ग की घोषणा को पूरा करता है जैसा कि हम देखते हैं कि इस क्षेत्र को इस वर्ग परिधि और दो तरीकों के लिए पुनर्परिभाषित किया गया है जो कि स्वयं के हैं।
वैसे भी, इसलिए हमारे पास एक पूर्ण है जिसे तीन वर्गों अर्थात् सर्कल आयत और दीर्घवृत्त की घोषणा कहा जाता है जो यहां सुपरक्लास ज्यामिति से व्युत्पन्न वर्ग हैं।
और ज्यामिति वर्ग, इस मामले में, एक सार वर्ग है।
अब, इसके बाद इन तीन वर्गों की परिभाषा है तो हम अब इन वर्गों की वस्तु बनाने की स्थिति में हैं।
अब देखते हैं कि हम इन वर्गों की वस्तु कैसे बना सकते हैं।
तो, यहां एक आवेदन कार्यक्रम है जो मूल रूप से मुख्य वर्ग शामिल है;
ताकि हम उन वर्गों की वस्तुओं का निर्माण कर सकें जिन्हें हमें अभी परिभाषित करना है, हम इस वर्ग का नाम जियोडेमो देते हैं और हम इन सभी वर्गों को देख सकते हैं जिन्हें हमने घोषित किया है कि हमने उन्हें पैकेज के रूप में संग्रहीत किया है और नाम पैकेज MyShape है।
इसलिए, हमें उन सभी वर्गों को आयात करना होगा जो हमने पैकेज MyShape में संग्रहीत किए हैं और यह आयात विवरण है।
अब, इसलिए यह मुख्य कार्यक्रम है क्योंकि हम देखते हैं कि हम यहां सार वर्ग की एक भू-वस्तु बनाते हैं।
तो, यह मूल रूप से एक कंटेनर है जिसे हम कह सकते हैं कि जियोऑब्जेक्ट एक कंटेनर है जो विभिन्न प्रकार की ज्यामिति की वस्तुओं को रखता है।
अब फिर हम तीन अलग-अलग वर्गों की तीन अलग-अलग वस्तुओं को बनाते हैं जैसे सर्कल, आयत, दीर्घवृत्त।
और हम इस जियोऑब्जेक्ट को इस कंटेनर में स्टोर करते हैं, जैसे कि यह।
तो, यह मूल रूप से जियोऑब्जेक्ट का एक सरणी है जिसे हम कह सकते हैं कि यह संग्रहीत है।
अब, देखते हैं कि हम कैसे प्रक्रिया कर सकते हैं।
तो, मान लीजिए कि इस मामले में हमने जो भी वस्तुएं बनाई हैं, हमने उन तीन वस्तुओं को बनाया है जो वस्तुओं के लिए अलग-अलग पैरामीटर पास हैं।
और हम वहां मौजूद सभी तीन वस्तुओं द्वारा खपत किए गए कुल क्षेत्र को बनाना चाहते हैं।
तो, हम पाश के लिए एक बहुत ही सरल हो सकता है;
इसलिए हम कुल क्षेत्र बना सकते हैं ये कुल क्षेत्र हैं वस्तुओं के सभी क्षेत्रों में से कुछ यह है और फिर यह प्रिंट होगा।
अब, यहाँ हम सोच सकते हैं कि यह बहुत सरल है।
हमने क्या किया है?
हमने इस एब्सट्रैक्टर के लिए एक एब्स्ट्रैक्ट क्लास बनाई है, जिसे हमने तीन सब क्लास अर्थात् सर्कल दीर्घवृत्त और फिर व्युत्पन्न किया है और फिर हम इस चीज़ को एक एप्लीकेशन में स्टोर करते हैं और फिर उन्हें प्रोसेस करते हैं।
अब यहाँ, इस में ध्यान देने योग्य कुछ बातें:
अब geoObjects.area तो अगर आप इस कोड के बारे में बात नहीं करते हैं।
अब केवल यह कोड अब जियोऑब्जेक्ट्स i.area है।
इसलिए, जब भी लूप की भूमिका होगी, यह मूल रूप से खुद को बांध देगा कि वह किस वस्तु के अनुरूप है।
अब, जब भी मैं 0 के बराबर होता है, तो यह क्षेत्र सर्कल ऑब्जेक्ट्स से बंध जाएगा जब भी मैं 1 के बराबर होगा यह क्षेत्र आयताकार वस्तु में बंध जाएगा, जब भी मैं 2 के बराबर होगा यह क्षेत्र दीर्घवृत्तीय वस्तु से बंधेगा।
इसलिए, जियोऑब्जेक्ट्स i और यह स्वचालित रूप से एक संबंधित वस्तु के साथ बाध्यकारी है। यह एक उदाहरण है जिसे डायनेमिक बाइंडिंग कहा जाता है या इसे रन टाइम पॉलिमॉर्फिज्म भी कहा जाता है।
क्योंकि यह ज्यामितीय वस्तु किसी भी क्षेत्र के लिए पॉलीमॉर्फिक रूप से काम करती है चाहे वह जिस भी प्रकार की वस्तु हो।
अब, यह अमूर्त वर्ग के उपयोग का एक बहुत अच्छा उदाहरण है, इसलिए हमने पहले उपयोग किया है।
अब इस प्रकार की अवधारणा के बारे में हम अब अन्य बातों पर चर्चा करने जा रहे हैं।
तो ठीक है, यह हम ज्यामिति ऑब्जेक्ट से देख सकते हैं कि हमें तीन वर्गों को प्राप्त करना है, लेकिन यह एकल वंशानुक्रम के माध्यम से प्राप्त होता है।
लेकिन कुछ स्थितियों में आप जानते हैं कि हमारे पास कई उत्तराधिकार की अवधारणा है।
अब यह अवधारणा कैसे है जो अब अमूर्त वर्ग और सब कुछ है जैसा कि हमारे पास है
इस बात पर चर्चा की कि उन बातों पर पहले ही चर्चा हो चुकी है।
इसलिए, मैं इसे ठीक नहीं दोहराना चाहता।
तो, अमूर्त विधि अपने आप में ही अमूर्त होती है, और फिर यदि कोई वर्ग अमूर्त के रूप में घोषित किया जा सकता है, भले ही उसके पास कोई अमूर्त विधि न हो, यह उसे तत्काल होने से रोकता है।
अब इस तात्कालिकता के बारे में यहाँ हम विवरणों पर चर्चा करेंगे और फिर हमें इस पर एक अच्छा प्रदर्शन करना चाहिए।
तो, कि आप इसे समझने में सक्षम होंगे और एक सार वर्ग के एक उप वर्ग को तत्काल किया जा सकता है यदि यह अपने सुपरक्लास के प्रत्येक अमूर्त तरीकों को ओवरराइड करता है।
अन्यथा, उपवर्ग ऑब्जेक्ट नहीं बनाया जा सकता है जो मैं यहां कहना चाहता हूं।
और यहाँ मूल रूप से अगर एक सार वर्ग का उपवर्ग सभी अमूर्त पद्धति को लागू नहीं करता है जो तब घोषित किया जाता है;
अमूर्त वर्ग तो उप वर्ग ही एक अमूर्त के रूप में बनाया क्योंकि हम उस अमूर्त की कोई भी वस्तु नहीं बना सकते हैं।
तो, यह अमूर्त वर्ग के कुछ गुण हैं जो इसकी पकड़ है।
वैसे भी, अब हम इस अवधारणा के बारे में देखते हैं कि एकाधिक उत्तराधिकार हमारा उद्देश्य है फिर एकाधिक वंशानुक्रम कैसे संभव है।
वे मानते हैं कि कई तरह की विरासत इस प्रकार है मान लीजिए कि सर्कल ऑब्जेक्ट में ज्यामिति ऑब्जेक्ट की विशेषताएं होनी चाहिए जिनके बारे में हमने चर्चा की है।
अब इसके अलावा, यह कुछ अन्य वर्गों से कुछ अन्य विशेषताओं का निर्माण करेगा जो कि उनके ड्रा आकार में वहां परिभाषित हैं।
तो, मान लीजिए कि आप अलग-अलग रंगों के साथ सर्कल को अलग-अलग रंगों के साथ बनाना चाहते हैं, जो इस तरह के अलग-अलग ज़ोम्स के साथ है।
इन सभी बातों को मान लेते हैं
इस ड्रा आकार विधि में परिभाषित किया गया है।
इसका मतलब है कि हम एक सर्कल को परिभाषित करना चाहते हैं जो दोनों ज्यामिति कक्षाओं का लाभ उठाते हैं जो हमने पहले ही सीखे हैं और फिर ड्रा सर्कल के अलावा भी।
तो, यह अवधारणा है कि अगर हम करने में सक्षम हैं;
इसका मतलब है, यदि आप दो या अधिक वर्गों से विशेषताओं को प्राप्त करने में सक्षम हैं, तो यह एक एकल वंशानुक्रम नहीं है, इसे एकाधिक विरासत कहा जाता है।
हालाँकि, Java किसी भी विरासत का समर्थन नहीं करता है फिर हम इस चीज़ को कैसे प्राप्त कर सकते हैं?
तो, इन चीजों को करने का एक वैकल्पिक तरीका है;
यह एक इंटरफ़ेस का उपयोग करना संभव है।
अब, यहाँ कार्य यह है कि वास्तव में एक इंटरफ़ेस क्या है।
इसलिए, हम इंटरफ़ेस पर चर्चा करने जा रहे हैं।
परिचय मेरा मतलब है कि अमूर्त वर्ग पर चर्चा क्योंकि आप उस इंटरफ़ेस के बारे में जानेंगे एक सार वर्ग कई मायनों में बहुत समान है दोनों के बीच अंतर खोजना बहुत मुश्किल है।
लेकिन अंतर यह है कि अमूर्त वर्ग केवल एकल वंशानुक्रम की अनुमति देता है जबकि, इंटरफ़ेस जो एक सार वर्ग के समान है, लेकिन यह वंशानुक्रम एकाधिक विरासत का समर्थन करता है।
तो, यह सार वर्ग और जावा में इंटरफ़ेस के बीच महत्वपूर्ण अंतर है।
अब, हमें कई विरासत और इंटरफ़ेस के लिए विरासत की पूर्ण अवधारणा है।
जैसा कि मैंने आपको बताया कि एक इंटरफ़ेस मूल रूप से एक वर्ग के समान है, यह बहुत ही विशेष रूप से एक अमूर्त वर्ग के समान है।
इसका मतलब यह है कि कक्षाओं की तरह एक इंटरफ़ेस कर सकता है
सदस्य और विधियाँ शामिल हैं।
हालांकि, वर्ग और इंटरफ़ेस के बीच का अंतर यह है कि इंटरफ़ेस के मामले में सभी सदस्य अंतिम हैं और सभी विधियां सार हैं।
ऐसा कोई भी सदस्य नहीं होना चाहिए जो नॉनफिनिकल हो और कोई भी तरीका जो नॉन एब्सट्रैक्ट हो।
अब, यह वर्ग और फिर इंटरफ़ेस के बीच का अंतर है, जबकि यदि आप वर्ग सार वर्ग और फिर इंटरफ़ेस देखते हैं, जैसा कि आप पहले ही जान चुके हैं कि सदस्यता अंतिम होगी।
और फिर अंतर सार भी कंटेनर सार विधि के रूप में अच्छी तरह से ज्ञात सार विधि कर सकते हैं।
यह अमूर्त वर्ग और इंटरफ़ेस अवधारणा के बीच के अंतर पर भी है और एक और बात यह है कि अमूर्त वर्ग और इंटरफ़ेस दोनों के लिए किसी भी वस्तु को त्वरित नहीं किया जा सकता है।
तो, यह इस तरह की बात है कि हम इस अर्थ में दो चीजें समान हैं।
तो, अंतर इस तरह है और फिर समानता भी इस तरह ठीक है।
तो, यह एक बहुत व्यापक अर्थ में इंटरफ़ेस की अवधारणा है।
अब, हम इसके बारे में अधिक विस्तार की अवधारणा रखते हैं।
जैसा कि आप पहले ही चर्चा कर चुके हैं कि वास्तव में एक सार वर्ग क्या है या एक इंटरफ़ेस क्या है।
अब, जैसा कि हम देखते हैं कि यदि आप किसी वस्तु को तत्काल नहीं बना सकते हैं, तो आप सार वर्ग या इंटरफ़ेस का उपयोग क्या करते हैं, यदि आप उस वर्ग की वस्तु का निर्माण नहीं करते हैं तो उसका क्या उपयोग है।
दरअसल, जावा में सभी सार वर्ग या एक इंटरफ़ेस मूल रूप से एक वर्ग के लिए एक टेम्पलेट देता है।
एक वर्ग के लिए एक रूपरेखा:
इसलिए यह मूल रूप से एक प्रोफ़ाइल या एक दृश्य देता है कि;
एक वर्ग जो आपके पास होना चाहिए यदि आप अपना खुद का कार्यक्रम बनाना चाहते हैं;
यदि आप अमूर्त वर्ग और इंटरफ़ेस के अनुसार अवधारणा का पालन करते हैं।
तो, अमूर्त वर्ग और इंटरफ़ेस एक अवधारणा देते हैं बल्कि यह व्यवहार का एक प्रोटोकॉल देता है जिसे आपके जावा कार्यक्रमों द्वारा लागू किया जाना चाहिए जिसे आप इसे विकसित करना चाहते हैं।
तो, यह मूल रूप से अंगूठे का नियम देता है अपने वर्ग को सार वर्ग या इंटरफ़ेस से नियम लेने के बारे में यह अवधारणा है।
और जैसा कि मैंने पहले ही आपको बताया है कि एक इंटरफ़ेस विधियों के एक सेट को परिभाषित करता है, लेकिन उन्हें लागू नहीं करता है, क्योंकि उन्हें एक सार के रूप में घोषित किया जाता है यह एक सार वर्ग की तरह ही है।
और एक वर्ग को उन तरीकों को लागू करना चाहिए जो एक इंटरफ़ेस में एक सार पद्धति के रूप में घोषित किए गए हैं।
इसका मतलब है कि, इंटरफ़ेस एक संरचना है, और फिर यदि आप इंटरफ़ेस के समर्थन के साथ एक वर्ग बनाना चाहते हैं तो इसे लागू करने के लिए उस वर्ग की जिम्मेदारी है।
इसका मतलब है, स्पष्ट रूप से सभी विधि को परिभाषित किया गया है कि अगर उस अर्थ में वहाँ है
और जैसा कि आप पहले ही आपको बता चुके हैं कि इंटरफ़ेस में वे सभी विधियाँ हैं जिन्हें उन्हें सार्वजनिक और सार के रूप में घोषित किया जाना चाहिए।
और डिफ़ॉल्ट रूप से, यदि आप किसी भी पहुंच विनिर्देशन की घोषणा नहीं करते हैं, तो इसे सार्वजनिक और सार माना जाएगा।
और अन्यथा यह एक बात है और फिर एक इंटरफ़ेस में स्थिर तरीकों को घोषित नहीं किया जा सकता है।
इसलिए, यह एक महत्वपूर्ण प्रतिबंध है जहां तक ​​यह बात एक चिंता का विषय है।
लेकिन फिर भी, अमूर्त वर्ग में भी आप एक स्थिर विधि की घोषणा कर सकते हैं।
वैसे भी ऐसा इंटरफ़ेस ऐसा है कि यह सभी विधियाँ अमूर्त होंगी और अधिक स्पष्ट रूप से सभी इंटरफ़ेस सार्वजनिक और अमूर्त होंगे और किसी भी स्थिर विधि को वहाँ घोषित नहीं किया जाना चाहिए।
हालांकि, सदस्य एक चिंता का विषय है कि उन्हें सार्वजनिक फाइनल घोषित किया जाना चाहिए और स्थिर भी।
तो, ये वो चीज़ हैं जो इंटरफ़ेस के लिए समान हैं, चिंताएँ हैं।
अब, एक इंटरफ़ेस कैसे बनाया जा सकता है।
इसलिए, इंटरफ़ेस बनाने के लिए, Java कीवर्ड को कीवर्ड इंटरफ़ेस कहलाता है।
तो, यह अमूर्त वर्ग की तरह ही है एक अमूर्त वर्ग बनाने के लिए हम कीवर्ड सार का उपयोग करते हैं।
तो, यह इस तरह है, लेकिन वहाँ वाक्यात्मक रूप से कुछ और चीजें अलग हैं जिन्हें हमें इस पर चर्चा करनी चाहिए।
अब यहाँ एक उदाहरण है;
इसलिए आप देख सकते हैं कि हमने एक इंटरफ़ेस घोषित किया है, इंटरफ़ेस का नाम कहा जाता है
तो, इंटरफ़ेस कीवर्ड इंटरफ़ेस के नाम के बाद और जैसा कि यह घुंघराले कोष्ठक के साथ एक वर्ग की घोषणा के समान है।
और फिर इसके अंदर जैसा कि हम यहां देखते हैं, इसमें एक विधि शून्य कॉल int p और फिर अर्धविराम शामिल है, जैसा कि हम देखते हैं कि विधि की घोषणा के तुरंत बाद एक अर्धविराम होता है इसका मतलब यह है कि इस पद्धति का कोई कोड किसी भी परिभाषा में नहीं है।
तो, इसका मतलब है कि यह एक अमूर्त विधि है और फिर से मैंने आपको बताया था कि जैसा कि यह डिफ़ॉल्ट है कि यह विधि एक सार्वजनिक और सार है।
इसलिए, हमें किसी भी कीवर्ड को स्पष्ट रूप से निर्दिष्ट करने की आवश्यकता नहीं है, हमारा मतलब है कि आप ऐसा नहीं करते हैं।
तो, समझ में आता है कि यह कॉलिंग विधि एक सार्वजनिक और सार है।
इसका मतलब है कि कोई भी वर्ग इस इंटरफ़ेस को लागू कर सकता है।
तो, यह एक इंटरफ़ेस घोषित करने के लिए सिंटैक्स है।
अब इंटरफ़ेस के बारे में यदि आपके पास उस इंटरफ़ेस का उपयोग करने वाला इंटरफ़ेस है, तो आप उस इंटरफ़ेस से किसी भी वर्ग का निर्माण कर सकते हैं;
इसका मतलब है कि।
यहाँ, उदाहरण के लिए, इंटरफ़ेस एक वर्ग है यहाँ हम देखते हैं कि इंटरफ़ेस आप एक इंटरफ़ेस को परिभाषित करते हैं।
फिर यह कक्षा 1 और फिर कक्षा 2 इस इंटरफ़ेस के 2 कार्यान्वयन हैं दो अलग-अलग तरीकों से दो अलग-अलग कोड दो अलग-अलग प्रोग्राम हैं।
अब, इसलिए, यह एक विचार है कि इसी तरह अगर हम देखते हैं कि क्या हमारे पास इंटरफ़ेस 1, इंटरफ़ेस 2, इंटरफ़ेस 3 जैसे दो या अधिक इंटरफेस हैं।
जैसे तब एक वर्ग जिसकी आप योजना बना सकते हैं या जो आप बना सकते हैं वह बना सकते हैं।
तो, कि यह इस सभी इंटरफ़ेस को लागू कर सकता है।
अब हम देख सकते हैं कि यह विरासत की तरह है।
इसका मतलब यह है कि यह वर्ग इस सभी विधियों से विरासत में मिला है जो कि यहां घोषित किए गए सभी चर यहां या इस तरह विरासत में मिलेंगे।
तो, यह ठीक उसी तरह है जैसे कि कई वंशानुक्रम दिखते हैं जैसे कि यह जावा में कई विरासत की अवधारणा है जो रास्ते में आ रहा है।
कि अगर यह इंटरफेस करता है तो आप इसे कर सकते हैं, लेकिन अगर यह एक एब्सट्रैक्ट क्लास है तो आप ऐसा नहीं कर सकते हैं कि ये सभी चीजें एक एब्सट्रेक्ट क्लास या कोई क्लास नहीं होनी चाहिए।
तो, यह विचार है कि हम जावा में इंटरफ़ेस का उपयोग करके नियत समय में अधिक से अधिक वंशानुक्रम पर चर्चा करेंगे।
अब, हम एक उदाहरण देते हैं जल्दी से;
ताकि हम इंटरफ़ेस की अवधारणा को अधिक स्पष्ट रूप से समझ सकें।
जैसा कि हम यहां देखते हैं, इसलिए यह एक संरचना है जैसा कि हम देख सकते हैं और इस संरचना को हम इंटरफ़ेस कर सकते हैं।
अब इस संरचना में हमने दो तरीकों को परिभाषित किया है और उनका आकार बदलना है।
वे मूल रूप से विधि की घोषणा करते हैं, लेकिन शरीर का मतलब यह नहीं है कि इन सभी विधियों को मूल रूप से एक रूपरेखा तैयार की जाती है जो मूल रूप से एक प्रोटोकॉल टेम्पलेट होता है इसलिए यह इंटरफ़ेस लगता है।
और फिर हम अपना स्वयं का वर्ग अर्थात् सर्कल बना सकते हैं जो मूल रूप से एक आकार परिवर्तन विधि को लागू करते हैं जो वहाँ परिभाषित किया गया है।
अब, यह ऑब्जेक्ट्स लाइन के लिए भी लागू हो सकता है।
तो, अलग-अलग तरीके आकर्षित करते हैं और यह एक;
इसका मतलब है, यहाँ वृत्त और रेखा या आयत।
यदि हम यहां ड्रा विधि को सर्कल या लाइन में देखते हैं या ड्रा करते हैं तो वे कार्यान्वयन का अलग तरीका है।
इसलिए, यही कारण है कि विभिन्न आरोपण हम कह सकते हैं।
तो, इस तरह से हम जो समझ सकते हैं, वह यह है कि तीन अलग-अलग कार्यान्वयन, लेकिन यह उस टेम्पलेट या प्रोटोकॉल का अनुसरण करता है जिसे उनका इंटरफ़ेस दिया गया है।
तो, इस तरह से इंटरफ़ेस इस तरह से आ रहा है कि हम इसका उपयोग कर सकते हैं।
अब, आगे, अगर यह एक वर्ग है तो इस वर्ग का उपयोग सामान्य वर्ग की तरह किया जा सकता है।
इसलिए, इस वर्ग से, हम कुछ अन्य विधि के साथ कुछ अन्य विधि को भी इनहेरिट कर सकते हैं जो भी वहां है।
तो, इन सभी चीजों को शांत करना संभव है, यह अधिक लचीला, अधिक बहुमुखी बनाता है, और जो भी आप वास्तव में चाहते हैं किसी भी तरह से लिख सकते हैं।
वैसे भी, इस बारे में यह विचार है कि यदि आपके पास एक इंटरफ़ेस है तो यह आपको I मतलब संरचना देता है।
ताकि, आप इस संरचना का अनुसरण कर सकें
उसी प्रकार की वस्तुओं का निर्माण करें जैसा कि वस्तुओं के प्रकार को कहा जाता है बल्कि तब हम अपने कार्यक्रम में इसका उपयोग कर सकते हैं।
अब, इसलिए यह अवधारणा है जो वहां है और हमारे पास एक अच्छा उदाहरण है ताकि हम इसके बारे में समझ सकें।
अब, इंटरफ़ेस और सब कुछ के बारे में पूर्ण कोड होने से पहले;
आइए हमने इंटरफ़ेस और इसकी विशेषताओं के बारे में संक्षेप में फिर से संक्षेप में बताया है।
जैसा कि हमने चर्चा की है कि इंटरफ़ेस को इंटरफ़ेस के साथ घोषित किया जाना चाहिए।
सभी इंटरफ़ेस विधियां स्पष्ट रूप से सार्वजनिक और सार हैं जो मैंने पहले ही आपको बता दिया है क्योंकि आपको पता है कि स्पष्ट रूप से उल्लेख करने की आवश्यकता है।
एक इंटरफ़ेस में वहां मौजूद सभी चर सार्वजनिक, स्थिर होने चाहिए, और अंतिम यह स्पष्ट है;
इसका मतलब यह है कि वे चर जो एक इंटरफ़ेस में हैं, उन्हें एक स्थिर माना जाना चाहिए।
अन्य वर्ग में कोई भी विधि नहीं है जो मूल रूप से एक इंटरफ़ेस को लागू करता है उनके मूल्यों को बदल नहीं सकता है।
और इंटरफ़ेस विधियों को स्थिर नहीं होना चाहिए इंटरफ़ेस में किसी भी स्थिर विधि की अनुमति है।
और क्योंकि इंटरफ़ेस के तरीके सार हैं वे अंतिम रूप से चिह्नित नहीं किए जा सकते हैं।
इसलिए, आप ऐसा नहीं कर सकते क्योंकि इसे लागू करने या इसे लागू करने वाले किसी अन्य वर्ग में परिभाषित करने की आवश्यकता है।
तो, वे अंतिम नहीं होने चाहिए फिर हम सभी तरीके अमूर्त हैं, लेकिन अंतिम नहीं हैं।
और आप एक नोट पा सकते हैं कि ये आपके अमूर्त वर्ग और इस इंटरफ़ेस वर्ग के बीच फिर से अंतर हैं।
अब, इसके अलावा दर्ज करें और इंटरफ़ेस वर्ग एक या एक से अधिक अन्य इंटरफेस का विस्तार कर सकता है जो हमने पहले ही चर्चा की है।
एक इंटरफ़ेस दूसरे इंटरफ़ेस या वर्ग को लागू नहीं कर सकता है जो संभव नहीं है।
तो, इंटरफ़ेस केवल एक वर्ग इसे लागू कर सकता है, लेकिन वास्तव में रिवर्स संभव नहीं है।
और इंटरफ़ेस प्रकारों का उपयोग बहुरूपिक रूप से किया जा सकता है।
तो, यह अवधारणा है कि एक इंटरफ़ेस;
यदि यह एक प्रकार है, तो यह प्रकार समयबद्ध बाँध चला सकता है यदि अतिरिक्त वर्ग के उदाहरण में हमने उस वृत्त को दीर्घवृत्त और फिर आयताकार दिखाया है कि कैसे गतिशील रूप से या समय चलाएं या बहुरूपिक रूप से इस एक के साथ क्षेत्र नामक विधि के साथ बाँधें;
तो यह ठीक है।
तो, अब यहां एक त्वरित वाक्यविन्यास संरचना है कि इंटरफ़ेस को किसी कार्यक्रम में कैसे घोषित किया जाना चाहिए।
अब तो यह सिंटैक्स है कि हम देख सकते हैं कि इंटरफ़ेस को इंटरफ़ेस के नाम के साथ इंटरफ़ेस घोषित किया जाना चाहिए और ये विकल्प हैं।
एक इंटरफ़ेस किसी भी अन्य इंटरफ़ेस का विस्तार कर सकता है।
तो, ये नाम एक और सब कुछ हैं, लेकिन यह इंटरफ़ेस है, न कि वास्तव में वर्ग।
वैसे भी और ये वैरिएबल डिक्लेरेशन हैं क्योंकि हमने घोषित किया है कि इस सभी वैरिएबल को स्टैटिक फाइनल और एब्सट्रैक्ट घोषित किया जाना चाहिए और फिर ये पब्लिक स्टैटिक और फाइनल हैं।
और ये विधि अमूर्त और अमूर्त विधि है, एक सार्वजनिक अमूर्त विधि है इसलिए ये विधियां हैं।
अब, तो यह मूल रूप से एक उदाहरण है कि कैसे एक चर या एक इंटरफ़ेस में एक सदस्य जैसा दिखता है और ये मान लेते हैं कि यह एक बार यह रहेगा कि आप इसे बदल नहीं सकते क्योंकि यह स्थिर है।
और फिर यह एक वापसी प्रकार है जो मूल रूप से केवल अर्धविराम देख सकता है कोई शरीर यह यहाँ नहीं है।
इस घोषणा के बाद इसका मतलब है कि इस पद्धति को एक सार पद्धति के रूप में घोषित किया गया है और जैसा कि यह सार्वजनिक है कि कीवर्ड डिफ़ॉल्ट रूप से है यह ठीक है।
इसलिए, यह इस बारे में विचार है कि हम एक प्रोग्राम सिंटैक्स में अपना इंटरफ़ेस कैसे बना सकते हैं, जिस पर हमने चर्चा की है और यह एक उदाहरण है।
तो, एक आइटम एक इंटरफ़ेस घोषणा है;
इसका चर है यह वैरिएबल है जिसे स्थिर अंतिम के रूप में घोषित किया गया है।
और यह एक और वैरिएबल स्टैटिक फाइनल है और यह एक तरीका है जिसकी हमने यहां चर्चा की है।
तो यह एक उदाहरण है कि हम समझ सकते हैं कि इसका उपयोग इंटरफ़ेस बनाने के लिए कैसे किया जा सकता है।
अब, यह एक और उदाहरण है, इसलिए हम यहां एक तापमान को एक इंटरफ़ेस घोषित कर सकते हैं यह एक समान प्रकार की चीजें हैं इसलिए यह मूल रूप से अस्थायी है।
और इस इंटरफ़ेस का उपयोग करके हम एक वर्ग बना सकते हैं।
यहां हम इस उदाहरण इंटरफ़ेस में देख सकते हैं यह इंटरफ़ेस का नाम है घटता है और फिर सर्कल और दीर्घवृत्त का विस्तार करता है।
इसका मतलब है, यहाँ वक्र एक इंटरफ़ेस है जो मूल रूप से सर्कल और दीर्घवृत्त प्रकार का विस्तार करता है।
इसका मतलब है कि इन वक्रों में वे सभी सुविधाएँ शामिल होंगी जो वृत्त और इंटरफ़ेस दोनों में हैं।
और इसके अलावा, यह इन सभी चीजों की तरह एक विधि है।
अब, यहां एक त्वरित उदाहरण है यह इंटरफ़ेस की अवधारणा को समझने के लिए एक बहुत ही अच्छा उदाहरण है यह उसी पंक्ति में है, जैसा कि हम पहले चर्चा कर चुके अमूर्त वर्ग उदाहरण के रूप में करते हैं।
अब यहां हम देख सकते हैं कि यह एक इंटरफ़ेस संरचना है जैसा कि हम जानते हैं कि इसमें सदस्य स्थिर अंतिम सार हैं।
और ये विधि सार और सार्वजनिक हैं और हम इस अवधारणा इंटरफ़ेस का उपयोग करके सर्कल इलिप्स और आयत जैसी तीन प्रकार की वस्तु बनाना चाहते हैं।
अब, हम इस पर त्वरित नज़र डालते हैं कि यह कैसे संभव है कि एक अच्छा कार्यक्रम हो।
अब, यहाँ हम उस इंटरफ़ेस का नाम GeoAnalyzer दे सकते हैं।
इसकी विधियाँ हैं जैसा कि हमने चर्चा की है और यहाँ पर आप इस वृत्त को देख सकते हैं।
और इस आरोपण का मतलब है कि यह इस विधि को लागू करेगा यह इस पद्धति को लागू करता है।
तो, यह कन्स्ट्रक्टर है स्वचालित रूप से इस वर्ग के लिए हमें यह करना होगा।
और यह इस क्षेत्र का कार्यान्वयन है और यह इस क्षेत्र का कार्यान्वयन है।
इसलिए, यह सर्कल को लागू करने के लिए एक इंटरफ़ेस का उपयोग पूरा करता है।
इसी तरह, हम एक दीर्घवृत्त जैसी ज्यामितीय वस्तु के लिए एक और वर्ग बना सकते हैं।
तो, यह क्लास ऑब्जेक्ट एलिप्से बनाने का एक समान तरीका है और यह आयत का कार्यान्वयन है।
अब हम समझ सकते हैं कि इंटरफ़ेस का उपयोग करने और इसे लागू नहीं करने से आप एब्सट्रैक्ट क्लास के मामले में देख सकते हैं कि हम एक्सटेंड्स का उपयोग कर सकते हैं;
इसका मतलब है, व्युत्पन्न वर्ग।
लेकिन यहाँ वास्तव में इंटरफ़ेस का एक कार्यान्वयन है जो एक पूरी तरह से एक अमूर्त अवधारणा है और फिर हम इस तरह की वस्तुओं का निर्माण कर सकते हैं।
अब, एक बार इस तरह की वस्तु बन जाने के बाद, हम अपनी खुद की विधि देख सकते हैं।
यह एक ही लाइन में अमूर्त वर्ग अवधारणा के समान है, हम देख सकते हैं कि यह एक वर्ग है जिसे हमने मुख्य वर्ग के मुख्य वर्ग के रूप में घोषित किया है, ज्यामिति है।
यह स्पष्ट रूप से, उन सभी वर्गों को इनपुट करता है जो हमने पहले बनाए हैं, यदि उन्हें एक पैकेज में रखा जाए।
अब, इन चीजों के बाद हम एक विधि बनाते हैं जो इस वर्ग शून्य प्रदर्शन में एक विशेष विधि है।
यह मूल रूप से x और y मान प्रदर्शित करेगा यह इस तरह है।
अब हम उस मुख्य विधि को देखते हैं जिसे हमने यहाँ घोषित किया है।
तो, ये मुख्य विधियाँ इस ऑब्जेक्ट के रूप में स्टोर किए गए तीन ऑब्जेक्ट सर्कल को दीर्घवृत्त बनाती हैं।
और फिर हम एक बनाते हैं जिसे कहा जाता है यह एक तात्कालिकता नहीं है हम बस बनाते हैं हम घोषणा करते हैं कि हम प्रकार के ऑब्जेक्ट को परिभाषित करते हैं GeoAnalyzer।
इसका मतलब है कि, यह एक इंटरफ़ेस प्रकार है GeoAnalyzer हमारे उदाहरण में एक इंटरफ़ेस है।
इसलिए, यहाँ हम मूल रूप से जियोइटेम और इंटरफ़ेस आइटम देखते हैं जो हमने बनाया है।
अब, यहां एक बार एक सर्कल सी बन जाने पर हम इसे असाइन कर सकते हैं।
इसका मतलब है कि, जियोमाइट अब c को इंगित करता है;
इसका मतलब है, सर्कल और फिर प्रदर्शन विधि जो यहां घोषित की गई है, आपको यह देखने के लिए कहा जा सकता है कि प्रदर्शन विधि जो भी हो, वस्तु समान हो।
यदि आप इस बारे में नहीं देखते हैं और यह एक तरीका प्रदर्शित करता है, तो मूल रूप से सर्कल आयत के बावजूद यह मूल रूप से समान है।
तो, यह फिर से अवधारणा है इसे डायनामिकली बाइंडिंग कहा जाता है या यह एक पॉलीमॉर्फिक रूप से चलने वाला समय है जो पॉलीमॉर्फिक बाइंडिंग है।
अब, हम यह कह सकते हैं कि जो भी वस्तु है वह उनका क्षेत्र है और इस कार्यक्रम में परिधि का उपयोग किया जा सकता है।
इसलिए, यह विचार है कि हमने क्लास के निर्माण के लिए इंटरफ़ेस अवधारणा का उपयोग कैसे किया जा सकता है, इसके बारे में सीखा है।
और इसलिए, बाद में, जावा प्रोग्राम का निर्माण करें।
अब, इंटरफ़ेस के साथ विरासत जैसा कि मैंने आपको बताया कि एक इंटरफ़ेस का उपयोग दूसरे इंटरफ़ेस को विस्तारित करने के लिए भी किया जा सकता है।
तो, यह एक उदाहरण है कि वंशानुक्रम एक वर्ग के समान अवधारणा है।
इसका मतलब है, इंटरफ़ेस एक वर्ग के रूप में बनाया जा सकता है, इसलिए विरासत के लिए चिंता इंटरफ़ेस है।
जैसा कि हम देख रहे हैं कि इंटरफेस इंटरफेस्ड केमिस्ट्री इसे बढ़ाता है।
इसका मतलब यह है कि इस इंटरफ़ेस का उपयोग निरंतर का विस्तार करने के लिए किया जाता है जहां निरंतर एक इंटरफ़ेस है।
तो, यह एक इंटरफ़ेस है और यहां हम देख सकते हैं कि यह इंटरफ़ेस विस्तारित इंटरफ़ेस निरंतर इंटरफ़ेस को विरासत में प्राप्त करने वाला एक अन्य इंटरफ़ेस रसायन बनाता है।
यहाँ, हम देख सकते हैं कि इंटरफेस भौतिक विज्ञान का एक और इंटरफ़ेस कानून बना रहा है, जो निरंतर और भौतिक हैं।
तो, यह एक ही अवधारणा है यह सिर्फ अगर आप इसे पसंद करते हैं तो यह एक वर्ग है जो इस तरह से दूसरों को विरासत में मिला है।
तो, यह अवधारणा है कि विरासत भी संभव है।
अब, इसलिए यह विरासत के बारे में एक संक्षिप्त विचार के बारे में विचार है।
और हम अपने अगले मॉड्यूल में अधिक विरासत पर चर्चा करेंगे।
धन्यवाद।
कम्प्यूटर प्रोफ़ेसर और इंजीनियरिंग इंडियन इंस्टिट्यूट ऑफ़ टेक्नोलॉजी, खड़गपुर लेक्चर के जावा प्रो। देबासीस सामंत विभाग में प्रोग्रामिंग - 55 प्रदर्शन - XXII मुझे आशा है कि आप हमारे प्रदर्शनों का आनंद ले रहे हैं।
यह हमारा आखिरी डेमो है और यह डेमो उन पाठों से संबंधित है जो हमने सीखे हैं कि अब तक JDBC अवधारणा का संबंध है।
अब, आज के डेमो में हम मूल रूप से केवल प्रोग्राम करने के लिए कंसोल पर SQL सर्वर से कनेक्ट नहीं करने के बारे में कवर करने जा रहे हैं।
इसलिए, कि जावा एप्लिकेशन से ही विभिन्न एसक्यूएल कमांड को कैसे जारी किया जा सकता है और कमांड को सर्वर पर भेजा जा सकता है, सर्वर कमांड को निष्पादित करेगा और फिर सर्वर परिणाम वापस करेगा और सभी परिणाम आवेदन से ही संसाधित होंगे।
तो, सब कुछ मूल रूप से आवेदन में शामिल है केवल हम आवेदन से बाहर नहीं जाएंगे।
अब, अब तक इस बात का संबंध है, हम देखेंगे कि कैसे अलग-अलग कथनों को निष्पादित किया जा सकता है और फिर वे सर्वर पर आग लगा सकते हैं।
और आप वास्तव में एक प्रक्रिया के रूप में जानते हैं, उनका पहला कदम जिसे आपको विचार करना है कि आपको पहले तीन ऑब्जेक्ट बनाने होंगे।
एक कनेक्शन ऑब्जेक्ट्स, स्टेटमेंट ऑब्जेक्ट और फिर परिणाम ऑब्जेक्ट्स है।
इसलिए, हमने पहले ही जान लिया है कि कनेक्शन ऑब्जेक्ट कैसे बनाए जा सकते हैं और फिर आपके आवेदन से JBCBC ड्राइवर के माध्यम से सर्वर से कनेक्शन कैसे स्थापित किया जा सकता है।
और फिर हमने अपने पिछले सत्र के बारे में भी जान लिया है कि JDBC ड्राइवर का इस्तेमाल संचार के लिए कैसे किया जा सकता है, इसका मतलब है कि एप्लिकेशन से सर्वर तक कुछ अनुरोध जारी किया जा सकता है।
आज हम चर्चा करेंगे, अब हम कार्यक्रम के बारे में चर्चा करने जा रहे हैं;
विभिन्न एसक्यूएल बयानों की स्टेटमेंट प्रदर्शनी और फिर परिणाम प्राप्त करना और एप्लिकेशन वातावरण में ही परिणाम संसाधित करना।
अब, हम इस बारे में चर्चा करने जा रहे हैं कि एक चयनित विवरण का निष्पादन कैसे किया जा सकता है और जैसा कि आप जानते हैं कि चयनित विवरण के बाद, यह रिकॉर्ड का एक सेट लौटाएगा, कैसे उन सभी रिकॉर्डों को आवेदन से ही संसाधित किया जा सकता है।
उदाहरण के लिए, स्क्रीन पर ही प्रदर्शित करें।
इसलिए, जहां तक ​​प्रसंस्करण का संबंध है, हम सरल प्रसंस्करण पर विचार करेंगे।
पहले उदाहरण में हम विचार करेंगे कि डेटा सर्वर से सामना किया जाएगा और डेटा उदाहरण के लिए कुछ गणना, सभी रिकॉर्ड की औसत गणना इस तरह से गणना की जाएगी।
और फिर हम इस बारे में चर्चा करेंगे कि तालिका कैसे बनाई जा सकती है और फिर कार्यक्रम से सफल तालिका के निर्माण के बाद, हम अपने स्वयं की पुष्टि करने में सक्षम होंगे कि तालिका सफलतापूर्वक बनाई गई है।
और फिर हम यह देखेंगे कि इंसर्ट कमांड को कैसे निष्पादित किया जा सकता है और इंसर्ट कमांड के पूरा होने के बाद हम यह सुनिश्चित कर सकते हैं कि डेटा डालने का काम सफलतापूर्वक प्राप्त हो और फिर अंत में अपडेट जैसी अन्य कमांड के लिए दोहराने के साथ डिलीट करें , ड्रॉप टेबल वगैरह।
इसलिए, हम प्रदर्शन के लिए आगे बढ़ें।
पहला प्रोग्राम जिसे हम डेमो करने जा रहे हैं, वह मूल रूप से है कि चयन स्टेटमेंट को कैसे निष्पादित किया जा सकता है।
इन बातों के लिए हम मानते हैं कि डेटाबेस में पहले से ही एक टेबल उपलब्ध है।
हमने इस डेमो के उद्देश्य के लिए पहले ही एक टेबल बना लिया है।
तालिका का नाम javacourseold है।
अब हाँ के रूप में, इसलिए, यह तालिका है कि यह पहले से ही MySQL सर्वर में संग्रहीत है और हमने इस पर ऑपरेशन का चयन किया है।
उदाहरण के लिए, javacourseold से स्टार का चयन करें।
इसलिए, मूल रूप से यह इस कथन को निष्पादित करेगा और फिर सफल निष्पादन पर यह एक परिणाम देगा, उन परिणाम को आवेदन का सामना करना पड़ेगा और आवेदन से, हम इसे संसाधित करने में सक्षम होंगे।
अब, यहाँ कार्यक्रम है।
देखते हैं।
जैसा कि आप यहाँ कार्यक्रम देखते हैं, कुछ कथन जैसा कि आप जानते हैं जो स्पष्ट हैं कि कनेक्शन कैसे स्थापित करें।
इसलिए, जैसा कि हम देखते हैं कि यह मूल रूप से सर्वर से कनेक्ट करने के संबंध में है।
इसलिए, जैसा कि हम देखते हैं कि ये संबंध हैं और फिर अंत में, इस कथन में हम कथन को निष्पादित कर रहे हैं।
जैसा कि आप बयान देखते हैं कि हम javacourseold से चुनिंदा स्टार को निष्पादित करने जा रहे हैं।
तो, इस तालिका से यह वहाँ होगा।
अब यदि इस कमांड को निष्पादित किया जाता है तो यह मूल रूप से एक परिणाम देगा।
तो, getResultSet स्टेटमेंट ऑब्जेक्ट का परिणाम प्राप्त करेगा और फिर इसे किसी अन्य ऑब्जेक्ट में rs कॉल किया जाएगा।
तो, rs एक परिणाम सेट ऑब्जेक्ट है।
इसलिए, मुख्य रूप से तीन वस्तुओं के रूप में मैंने आपको पहले ही बता दिया है;
कनेक्शन ऑब्जेक्ट, स्टेटमेंट ऑब्जेक्ट और परिणाम सेट।
हम आप पहले से ही हमारे में परिचित हैं
पिछले दो प्रदर्शन, हमने इसके बारे में चर्चा की है।
अब हम इस rs ऑब्जेक्ट को प्रोसेस करने जा रहे हैं।
अब, आप जानते हैं, जबकि rs डॉट नेक्स्ट मूल रूप से एक बूलियन मान लिखा जाता है।
इसलिए, यह मूल रूप से वस्तुओं को रिकॉर्ड करेगा जो मूल रूप से प्राप्त होगा का एक सेट सामग्री।
तो, सभी रिकॉर्ड यह वहाँ है;
इसका मतलब है, सभी पंक्तियों को हम कह सकते हैं।
अब rs डॉट नेक्स्ट मूल रूप से पंक्तियों के अंत तक चलेगा।
तो, शुरू में पंक्तियों की संख्या में पंक्तियों वास्तव में खाली नहीं है।
तो, यह पहली पंक्ति होगी।
तो, यह rs डॉट नेक्स्ट वास्तव में सही है।
तो, जैसा कि यह सच है कि यह इस पर जाएगा।
तो, rs डॉट getString मूल रूप से javacourseold में रिकॉर्ड के लिए है;
एक फ़ील्ड कॉल नाम है तो दूसरे को रोल और मार्क्स और ग्रेड कहा जाता है।
इसलिए, वर्तमान रिकॉर्ड के लिए फ़ील्ड मान जिसमें फ़ील्ड का नाम है, नाम प्राप्त किया जाएगा और यह मूल रूप से एक स्ट्रिंग के रूप में पढ़ा जाता है।
इसलिए, जावा हमेशा शुरू में एक स्ट्रिंग के रूप में पढ़ा जाता है और फिर हम अपनी आवश्यकता के अनुसार दूसरे रूप में परिवर्तित कर सकते हैं।
इसलिए, मूल रूप से फ़ील्ड के लिए स्ट्रिंग पढ़ें मूल्य का नाम दें और हम स्टोर एक स्ट्रिंग पर हैं।
तो, इसी तरह NameString, RollString, MarkString, ग्रेडस्ट्रीम एक रिकॉर्ड के लिए चार अलग-अलग फ़ील्ड मान हैं;
नाम, रोल, मार्क्स और ग्रेड और फिर हम तब हम सभी मूल्यों को परिवर्तित करते हैं।
एक बार जब आप अंक पढ़ लेते हैं, तो हमें सभी रिकॉर्डों के लिए कुल अंकों की कुल राशि की गणना करनी होगी और फिर अंत में, रिकॉर्ड की कुल संख्या से विभाजित करें और फिर औसत की गणना की जाएगी।
तो, यह मूल रूप से प्रक्रिया है मूल रूप से शुरू में TotalMarks है और फिर Integer dot parseInt MarkString है क्योंकि यह शुरू में एक स्ट्रिंग के रूप में है और इस वार्तालाप का उपयोग करके हम पूर्णांक मान को परिवर्तित कर सकते हैं और फिर TotalMarks को जोड़ा जाएगा।
इसलिए, ये मूल रूप से हर बार एक रिकॉर्ड तक पहुंचते हैं और फिर I का अर्थ है मानों पर टोटलमार्क्स के मान को चिह्नित करते हैं और अंत में, सभी के कुल निशान यहां प्राप्त किए जाएंगे और यहां वास्तव में अगला है।
तो, सिस्टम डॉट आउट डॉट प्रिंटलाइन नाम बराबर होता है NameString रोल रोलस्ट्रिंग और फिर मार्क्स मूल रूप से यहां मुद्रित होते हैं।
तो, MarkString है।
और फिर अगला मूल रूप से rs dot अंतिम साधन है मूल रूप से जब आप अंतिम वस्तु तक पहुंचते हैं, तो, rs dot last मूल रूप से होता है।
और फिर छात्रों की संख्या मूल रूप से rs ऑब्जेक्ट से प्राप्त की जा सकती है विधि getRow विधि कहकर।
तो, आरएस डॉट getRow।
इसलिए, यह मूल रूप से रिकॉर्ड की कुल संख्या कहती है जो हमने इसे पढ़ा है।
तो, TotalMarks द्वारा रिकॉर्ड की गई कुल संख्या से यह मूल रूप से आपको औसत गणना देता है।
जैसा कि हम देखते हैं कि औसत गणना मूल रूप से यहां गणना की जाती है और फिर हम इस औसत को प्रिंट करते हैं।
और बाकी चीज़ कोशिश, कैच, ब्लॉक और सब कुछ के लिए है यह प्रथागत कोशिश है, पकड़, ब्लॉक हमें बनाए रखना है और ताकि कार्यक्रम को एक विश्वसनीय और मजबूत तरीके से निष्पादित किया जा सके।
तो, ये मूल रूप से आपको बताते हैं कि परिणाम सेट ऑब्जेक्ट को कैसे संसाधित किया जा सकता है।
इसलिए, इस सत्र में हम मुख्य रूप से परिणामों के प्रसंस्करण पर जोर देंगे, जैसे या वैकल्पिक रूप से सभी परिणाम जो कि एसक्यूएल स्टेटमेंट के निष्पादन के बाद ही प्राप्त होंगे, ठीक है।
तो, यह प्रदर्शन है, आशा है कि आप इसे समझने में सक्षम होंगे।
हमारा अगला प्रदर्शन थोड़ा सरल है।
हम बिल्कुल देखेंगे कि कैसे विभिन्न एसक्यूएल प्रकार के बयान।
हम केवल मूल एसक्यूएल विवरणों के निष्पादन पर विचार करेंगे और यह केवल सीखने के उद्देश्य के लिए शुरुआत के लिए पर्याप्त होगा।
तो, इस मामले में, हम पहले से उपलब्ध एक तालिका पर विचार करेंगे।
अब, हम बनाएँ तालिका को सही मानेंगे।
इसलिए, हम इस पर विचार करने जा रहे हैं कि कैसे एक नई तालिका बनाई जा सकती है और फिर, हम पहले आवेदन से पहले देखते हैं, हम ठीक से जाँच करेंगे कि डेटाबेस सर्वर में अलग-अलग तालिकाएँ उपलब्ध हैं।
तो, उस स्थिति में हमें आदेश जारी करना होगा।
तो, टेबल और फिर एक बार टेबल होने के बाद हम एक नई टेबल बना सकते हैं।
इसलिए, हम सिर्फ एक नई तालिका बनाते हैं।
नई तालिका का नाम शायद जावा पाठ्यक्रम है और फिर एक नई तालिका बनाने के बाद हम फिर से इस बात की पुष्टि देखेंगे कि नई तालिका सफलतापूर्वक बनाई गई है।
तो, ये ऐसे चरण हैं जिनका हम एक-एक करके पालन करेंगे, लेकिन जावा एप्लिकेशन से ही ठीक है।
इसलिए, यहाँ एक कार्यक्रम है क्योंकि हम देखते हैं कि थोड़ा ठीक है।
इसलिए, कार्यक्रम के पहले कुछ भाग।
इसलिए, कार्यक्रम का पहला भाग स्पष्ट है कि मूल रूप से JDBC का उपयोग कर सर्वर से जुड़ रहा है।
इसलिए, इन सभी चीजों को जोड़ने वाले JDBC को लोड करना और फिर अगले आप देख रहे हैं कि यह एक बयान है जिसे हम निष्पादित करने जा रहे हैं, शो कमांड।
अब इसलिए, परिणाम सेट प्राप्त किया जाएगा।
मूल रूप से शो टेबल आपको उन सभी तालिकाओं को दिखाएगा जो इस मामले में वर्तमान सक्रिय डेटाबेस में हैं, परीक्षण डेटाबेस हो सकते हैं।
इसलिए, rs को मूल रूप से परिणाम सेट मिलेंगे, इसमें वे सभी टेबल शामिल हैं जो अभी डेटाबेस में हैं।
अब, प्रॉम्प्ट यह है कि तालिका बनाने से पहले परिणाम और यहां मूल रूप से आरएस वस्तुओं को संसाधित करना मूल रूप से कुछ भी नहीं कर रहा है मूल रूप से परिणाम तालिका से प्रत्येक टेबलनाम प्राप्त कर रहा है और इसे स्क्रीन पर प्रिंट कर रहा है जो सभी है।
इसलिए, यह मूल रूप से इन चीजों को करेगा और फिर अगली चीज के बाद हम एक और स्टेटमेंट बनाते हैं टेबल जावाकोर्स बनाते हैं।
और जैसा कि आप जानते हैं कि यह एक तालिका नई तालिका बनाने के बारे में पूर्ण वाक्यविन्यास है, वास्तव में, और डेटाबेस में जोड़ें।
तो, एक स्टेटमेंट निष्पादित होता है और इसके बाद एक नया टेबल बनाया जाता है।
शो टेबल, यह मूल रूप से सभी तालिकाओं के सही होने के बाद पिछले कोड को सही तरीके से भेजने के लिए है;
यह मूल रूप से सभी तालिकाओं को प्रदर्शित करेगा।
तो, यह वह हिस्सा है जो ठीक है, यह बनाने से पहले तालिका दिखाएगा और फिर एक नई तालिका बनाएगा और निर्माण के बाद यह फिर से सभी तालिका दिखाएगा।
अब, हम उन परिणामों को देखेंगे जो जावा एप्लिकेशन से प्राप्त किए जा सकते हैं।
यह एक ऐसा रूप है जैसा आप यहाँ देख रहे हैं जावा एप्लिकेशन से हम इसे देख पा रहे हैं।
अब, यदि हम इस कार्यक्रम को चलाते हैं, तो निष्पादन इस तरह दिखेगा।
तो, यह कार्यक्रम है और फिर ठीक है।
तो, हम सिर्फ तालिका का नाम एक javacourse है।
तो ये मूल रूप से शुरू में पता चलता है कि केवल एक मेज वहां मौजूद है जिसे जावकोर्सोल्ड कहा जाता है।
अब तालिका बनाने के बाद परिणाम जैसा कि आप तालिका बनाने के बाद देखते हैं।
इसलिए, हम इस कोड को फिर से चलाते हैं।
तालिका बनाने के बाद, यह मूल रूप से दर्शाता है कि javacourseold वहां है और फिर javacourse table है।
तो, दो तालिकाओं यहाँ हैं;
javacourseold पहले और फिर नया है, यह वहां है और फिर मूल रूप से यह है कि मूल रूप से यह आउटपुट है जैसा कि हम यहां देखते हैं।
इसलिए, बयान निष्पादित किए गए हैं।
निष्पादन के बाद हम परिणाम और परिणाम JDBC के माध्यम से भी देख सकते हैं।
अब, हम अगले एक अन्य उदाहरण पर आते हैं, जहाँ हम हैं कि हम यह देख सकते हैं कि हम पहले से मौजूद तालिका में रिकॉर्ड कैसे डाल सकते हैं।
हम मेज पर रिकॉर्ड दर्ज करने पर विचार करेंगे।
पहले हम निष्पादन से पहले दिखाते हैं कि तालिका में क्या सामग्री है और फिर हम फिर से सम्मिलित विवरण जारी करेंगे और फिर सम्मिलित विवरण के बाद वर्तमान डेटा है।
अब यहाँ पाठ्यक्रम है।
यहां एक कनेक्शन बनाने और फिर JDBC ड्राइवर को लोड करने के लिए स्पष्ट पाठ्यक्रम दिया गया है और फिर, यहाँ मूल रूप से हम स्टेटमेंट ऑब्जेक्ट्स बना रहे हैं और यह पहला स्टेटमेंट है जिसे हम बनाने जा रहे हैं java कोर्स से स्टेटमेंट स्टार।
इसका मतलब यह है कि डालने से पहले यह है कि सामग्री क्या है, परिणाम सेट करता है और यह परिणाम सेट मूल रूप से उन सभी रिकॉर्डों को प्रदर्शित करेगा जो यह हमारे पास लौटता है और हम डेटा डालने से पहले वास्तव में देखेंगे कि कैसे अलग-अलग रिकॉर्ड हैं क्या आप वहां मौजूद हैं।
और फिर अगले समय हम एक बार में एक रिकॉर्ड डालने के बारे में कुछ बयान देते हैं।
इसलिए, यहाँ पहला रिकॉर्ड डाला जा रहा है, फिर दूसरा रिकॉर्ड तीसरा रिकॉर्ड और चौथा रिकॉर्ड।
इसलिए, यदि तालिका खाली है तो यह केवल चार रिकॉर्ड दिखाएगी।
यदि तालिका की सामग्री पहले से ही डेटा का उपयोग करती है, तो मौजूदा डेटा के बाद इन सभी चार नए सम्मिलित रिकॉर्ड को जोड़ा जाएगा और फिर यह कथन जावा समर से चुनिंदा स्टार को निष्पादित करेगा।
मूल रूप से, एक ही मूल रूप से सभी रिकॉर्ड का चयन करें और प्राप्त करें परिणाम सेट इसे प्राप्त करेगा और फिर अंत में, परिणाम सेट यहां होगा एक लूप है परिणाम सेट प्रक्रिया होगी।
जैसा कि आप यहाँ डालें से पहले परिणाम देखें।
तो, ये मूल रूप से तालिका में कोई रिकॉर्ड नहीं है।
तो, यह मूल रूप से खाली है।
फिर डालने के बाद परिणाम, जैसा कि हम देखते हैं कि यह पहला रिकॉर्ड है जिसे हमने डाला है, यह दूसरा रिकॉर्ड तीसरा रिकॉर्ड और चौथा रिकॉर्ड है।
तो, परिणाम प्राप्त हुए हैं और फिर उन्हें स्क्रीन पर प्रदर्शित किया गया है;
का अर्थ है, हम यह पुष्टि कर सकते हैं कि परिणाम अब आवेदन में स्वयं उपलब्ध हैं।
तो, यह एक उदाहरण है जो एक सम्मिलित है, सम्मिलित के विपरीत हमारा अगला उदाहरण अद्यतन उदाहरण है।
इसलिए, हम सिर्फ एक विशेष रिकॉर्ड को अपडेट करने जा रहे हैं।
जैसा कि हमेशा होता है हम कमांड को निष्पादित करेंगे कि रिकॉर्ड क्या हैं और फिर हम एक रिकॉर्ड अपडेट करेंगे और फिर अपडेशन के बाद हम देखेंगे कि अपडेशन परिलक्षित होता है या नहीं।
इसलिए, हम अपडेट के बाद परिणाम प्राप्त करेंगे और हम स्क्रीन पर अद्यतन रिकॉर्ड प्रदर्शित करेंगे।
तो, यह प्रोग्राम फ्लो है और यहां मूल रूप से कनेक्शन बना रहा है और फिर स्टेटमेंट को निष्पादित कर रहा है कि रिकॉर्ड क्या हैं।
इसलिए, अपडेशन से पहले और फिर यह मूल रूप से सभी रिपोर्ट दिखाता है और यहां वह कमांड है जिसके द्वारा हम अपडेट को निष्पादित करते हैं।
यहां हम अपडेट जावाकॉर्स सेट नाम डीबासिस देखते हैं जहां नाम डीबासिस है।
इसलिए, यदि कोई रिकॉर्ड है जिसका मूल्य मूल रूप से डेबिस नाम क्षेत्र के रूप में है और यह मूल रूप से इस रूप में बदल जाएगा।
तो, यह अगला है और यह पिछले वाला है।
तो, यह अद्यतन वहाँ है।
रिकॉर्ड का केवल एक फ़ील्ड मान यहां अपडेट किया जाएगा।
यदि एक ही चीज़ वाले कई रिकॉर्ड्स हैं, तो वास्तव में सभी रिकॉर्ड्स, इस कमेंड द्वारा अपडेट किए जाएंगे क्योंकि यह अपडेट हो जाएगा यह संपूर्ण डेटा बेस तालिकाओं को स्कैन करेगा और फिर अंत में, जो भी स्थिति से मेल खाता है, वह मूल रूप से इस एक पर लागू होगा, बाइंड उस के लिए, रिकॉर्ड और फिर करते हैं।
और यह अपडेशन से पहले रिकॉर्ड दिखाएगा।
अब यहां निष्पादन की कुल आउटपुट निष्पादन है।
यहाँ तुम हाँ देखते हो।
इसलिए, जैसा कि हम यहां से शुरू करते हैं, इसलिए, यह अपडेट रिकॉर्ड को निष्पादित करने के बाद यहां स्क्रीन से शुरू किया गया आउटपुट है।
इसलिए, परिणाम से पहले अद्यतन के रूप में हम देबासीस, नीलांजन, तौहीद, प्रियब्रत को देखते हैं;
चार रिकॉर्ड हैं।
अब, हमने अपडेट कमांड निष्पादित किया है।
फिर अपडेट कमांड के बाद परिणाम जैसा कि आप शुरू में देखते हैं, डेबिसिस को डेबिसिस अपडेट किया गया है और यह केवल इस रिकॉर्ड पर लागू होता है।
तो, यह केवल एक अपडेशन है और फिर परिणाम है।
तो, अब, हम इसे समझ सकते हैं।
तो, आपके प्रोग्राम से ही सब कुछ संभव है और फिर सभी SQL स्टेटमेंट या तो एक्जीक्यूशन के बाद रिजल्ट उपलब्ध होने के बाद उन सभी रिजल्ट को नोड के केवल एक पॉइंट से प्रोसेस करते हैं।
अब, हमारा अगला उदाहरण;
यह उदाहरण ठीक है, इसलिए, हटाना आम है।
ताकि, डिलीट कमांड को सफलतापूर्वक निष्पादित किया जा सके या नहीं।
तो, पहले उसी तरीके से हम पहले सभी तालिकाओं को देखेंगे;
एकाउंटेंट, पहले रिकॉर्ड और फिर हम एक डिलीट कमांड जारी करेंगे और डिलीट कमांड के बाद हम परिणाम देखेंगे।
तो, यहां प्रोग्राम प्रवाह है, कनेक्शन बनाना।
फिर हम पहले कथन को निष्पादित करते हैं;
जावाकोर्स से स्टार का चयन करें, मूल रूप से सभी रिकॉर्ड प्राप्त करते हैं और फिर स्टेटमेंट के निष्पादन के बाद स्क्रीन पर सभी परिणाम प्रदर्शित करते हैं।
फिर हम डिलीट कमांड को निष्पादित करते हैं;
जावा पाठ्यक्रम से हटाएं जहां 66 से कम अंक हैं।
यदि कोई रिकॉर्ड रिकॉर्ड हैं या कोई ऐसा रिकॉर्ड है, जिसके क्षेत्र के निशान का मान से कम है
66 को रिकॉर्ड से हटा दिया जाएगा और इस विवरण के निष्पादन के बाद हम हटाए जाने के बाद फिर से रिकॉर्ड देख पाएंगे।
इसलिए, हमें JavaCourse से एक और कमांड सिलेक्ट स्टार जारी करना होगा, यह सभी परिणाम प्राप्त करेगा और फिर स्क्रीन पर परिणाम प्रिंट होगा।
परिणाम स्क्रीन पर मुद्रित किया जाएगा और फिर बाकी कार्यक्रम मूल रूप से पकड़ने की कोशिश करेंगे।
अब, हम इस प्रोग्राम को चलाते हैं, यह प्रोग्राम एक डिलीट रिकॉर्ड है।
अब, अब तक JDBC प्रोग्रामिंग का संबंध है कि कुछ चरण हैं जो हमने सीखा है और उन सभी चरणों के बारे में जो हमने किए हैं और फिर हमने जो पर्याप्त प्रदर्शन शुरू किया है वह यह है कि MySQL सर्वर कैसे स्थापित किया जा सकता है।
और फिर MySQL सर्वर का उपयोग कंसोल आधारित mySQL सर्वर एक्सेस करने के लिए कैसे किया जा सकता है।
फिर JDBC का उपयोग कर सर्वर से कनेक्शन और कैसे JDBC ड्राइवर को डाउनलोड किया जा सकता है और इसे संग्रहीत किया जा सकता है और फिर कमांड को निष्पादित किया जा सकता है।
और फिर हम कमांड के निष्पादन के बाद परिणाम कैसे प्राप्त कर सकते हैं या कार्यक्रम में प्राप्त कर सकते हैं और कार्यक्रम इन चीजों को संसाधित कर सकता है।
तो, यह डेमो के हमारे पिछले तीसरे कहने के लिए डेमो का हिस्सा है, इसलिए JDBC के लिए चिंतित है और यह हमारे प्रदर्शन सत्र के साथ-साथ सभी प्रदर्शन का अंत है।
इस पाठ्यक्रम में हमने लगभग 20 22 प्रदर्शनों को कवर किया है और फिर अन्य में लगभग 28 व्याख्यान टुकड़ा है।
इसलिए, मूल रूप से 50 प्रतिशत सैद्धांतिक चर्चा के बाद लगभग 50 प्रतिशत प्रदर्शन, ताकि सभी सैद्धांतिक रूप से झुकी हुई अवधारणा को प्रदर्शन के माध्यम से सराहा जा सके।
मुझे आशा है कि आपने पाठ्यक्रम और प्रदर्शन का आनंद लिया होगा।
हमारे अगले भाग में, हम कुछ जावा प्रोजेक्ट्स के बारे में चर्चा करेंगे, जिन्हें प्रोजेक्ट्स एक टीम के सदस्य के रूप में या संयुक्त रूप से शामिल कई टीम के लोगों के रूप में आपके द्वारा नियंत्रित किया जा सकता है।
अब हम परियोजनाओं पर चर्चा करेंगे और फिर हम मूल रूप से यह देखेंगे कि आपके पास कितनी दूर तक झुकाव है और फिर क्या हम इस ओके में किसी भी वास्तविक जीवन के आवेदन को हल कर सकते हैं।
आपका बहुत बहुत धन्यवाद।
जावा प्रोफ़ेसर डेबासिस सामंता डिपार्टमेंट ऑफ़ कंप्यूटर साइंस एंड इंजीनियरिंग इंडियन इंस्टिट्यूट ऑफ़ टेक्नोलॉजी, खड़गपुर लेक्चर - 44 स्विंग प्रोग्रामिंग - II में प्रोग्रामिंग हम जावा स्विंग के बारे में चर्चा कर रहे हैं और पिछले मॉड्यूल में हमने इसमें कुछ घटकों पर चर्चा की है, और कुछ और भी हैं घटक जो हम इस मॉड्यूल में शामिल करने जा रहे हैं।
तो, पहला घटक जो यहां जेसेपरेटर;
AWT में नहीं है और तब JSeparator मूल रूप से जैसा कि यहां दिखाया गया है, यह इस अर्थ में एक विभाजक की तरह दिखता है कि यह मूल रूप से प्रदर्शन क्षेत्र को दो भागों में विभाजित करेगा जिसमें अलग-अलग सेटिंग दिखती है।
और इसके दो निर्माता और दो विधियाँ हैं।
और एक सरल उदाहरण है जो किसी भी विधवा कार्यक्रम में जेसेपरेटर के उपयोग को दिखाएगा जैसा कि हम यहां देखते हैं।
तो, यह मूल रूप से JSeparator है।
इस JSeparator में मेनू शामिल है और जब भी आप मेनू पर क्लिक करते हैं तो कुछ आइटम यहाँ दिखाई देंगे।
तो, JSeparator में कुछ अन्य चीजों को भी जोड़ा जा सकता है, हम टैब के बारे में चर्चा करेंगे और अन्य मेनू भी जोड़े जा सकते हैं और यदि आप देखते हैं तो मेनू आइटम यह बताएगा कि यह वहां है।
तो, यह मूल रूप से आपके प्रोग्राम में JSeparator का उपयोग है और यह प्रोग्राम आप स्वयं समझ सकते हैं और बहुत सरल है कि आप इसका पालन करने में सक्षम होंगे कि यह वहां कैसे काम करता है।
और फिर आप इसे दिखा सकते हैं।
और यह एक सरल उदाहरण है जिसके द्वारा आप दिखा सकते हैं कि हमने दो आउटपुट दिए हैं जैसे कि बीच में या प्रगति बार में काम कर रहा है, और जब फिनिश काम होता है।
तो, यह एक सरल उदाहरण है जिसे आप कोशिश कर सकते हैं और आप देख सकते हैं कि यह आपके कार्यक्रम में कैसे काम करेगा।
और फिर JTree यह एक बहुत ही दिलचस्प एक स्विंग घटक है।
एक जेट्री वास्तव में हम इन चीजों से भी परिचित होते हैं जब भी हम किसी निर्देशिका को ब्राउज़ करते हैं और तब।
तो, यह मूल रूप से दिखाता है कि एक निर्देशिका के तहत उपनिर्देशिकाएं क्या हैं जैसे उपनिर्देशिकाओं के तहत फाइलें क्या हैं।
तो, इसके 3 निर्माता हैं।
और यह एक सरल उदाहरण है जो मूल रूप से दर्शाता है कि जेट्री को कैसे दिखाया जा सकता है जैसा कि हम यहां देखते हैं, हम घोषणा करते हैं कि यह मूल रूप से है जिसे हम कह सकते हैं कि शैली एक जड़ है इस जड़ के नीचे एक दो नोड्स है यह नोड्स है इस फिर से नोड्स के तहत वास्तव में सबनॉड्स हैं।
अब, आप देखते हैं कि हम इसे कैसे बना सकते हैं, यह मूल रूप से शैली है यह मूल रूप से डिफ़ॉल्ट म्यूटेबल म्यू टी नोड है यह वह फ़ाइल है जो कक्षा में वहाँ है जिसे उसमें झूले पैकेज घोषित किया गया है;
हमें इसका उपयोग करना होगा और फिर हम शैली बना सकते हैं और फिर हम मेनू टी नोड कह सकते हैं जिसे रंग और फ़ॉन्ट कहते हैं।
अब, यहाँ आप style.addcolor देखते हैं, इसका मतलब है कि हम शैली के एक भाग के रूप में रंग जोड़ते हैं और फिर शैली के रंग के तहत शैली और शैली के तहत फ़ॉन्ट को शैली के भाग के रूप में जोड़ते हैं।
फिर हम इस रंग के तहत कुछ अन्य म्यू नोट जोड़ सकते हैं।
तो, यह मूल रूप से हम इसे परिभाषित करते हैं और एक दर पर इस रंग डॉट के तहत, इसका मतलब है कि हम रंग दर में जाते हैं।
तो, इस तरह से अन्य शाखाओं के बाद किसी भी शाखाओं के पेड़ बनाए जा सकते हैं।
तो, यह सरल उदाहरण है जो मूल रूप से आपको बताता है कि जब भी आपके कार्यक्रम में आवश्यकता होती है तो JJavaTree को कैसे क्रेट किया जा सकता है।
तो, यह JTree के बारे में विचार है और अगला JColorChooser है यह भी बहुत दिलचस्प है शायद आप जानते हैं कि जब भी आप एमएस शब्द की तरह किसी भी शब्द का उपयोग करते हैं और जब भी आपको एक फ़ॉन्ट के रंग का फैसला करना होता है, तो आपको चुनना होगा इसे और फिर रंग को एक पेन पेन से चुना जा सकता है।
इसलिए, डिफ़ॉल्ट रूप से यह ऐसा रंग होगा जिसे चुना जाता है जो कहता है कि 200 रंग जैसे आप इसमें और रंग जोड़ सकते हैं, इसमें प्रो सुविधाएं भी हैं जो इस निर्माणकर्ता द्वारा की जा सकती हैं।
तो, फिर से यह अभ्यास के लिए एक सरल पा कार्यक्रम है आप इस कार्यक्रम का अभ्यास कर सकते हैं आप देख सकते हैं कि रंग कैसे चुना जा सकता है, यहां मूल रूप से एक बटन जोड़ा गया है और इस बटन का उपयोग करके एक्शन हैंडलर है।
यदि आप इसे क्लिक करते हैं तो रंग चयनकर्ता विकल्प पॉप-अप होगा और फिर वहां से आप कुछ रंग का चयन कर सकते हैं और रंग का चयन किया जाएगा और यदि आप कुछ लिखते हैं तो आप उस रंग का उपयोग करते हैं, जो उस रंग के साथ होगा और फिर
रंग रीसेट किया जा सकता है।
और यहां यह भी देखें कि आपने हाल ही में जो भी रंग इस्तेमाल किया है वह भी आपको प्रदर्शित किया जाएगा।
यह सूक्ष्म कहने के संदर्भ में बहुत समान है और तब वर्जित फलक मूल रूप से एक घटक है, जो कि AWT में नया नहीं है और इन चीजों के भीतर यह मूल रूप से यदि आप एक फ्रेम बनाते हैं, तो इस फ्रेम में बहुत कुछ अन्य टैब के हैं।
यदि आप एक्सेल जानते हैं और आप शायद सबसे नीचे जानते हैं, तो बहुत सारे टैब होते हैं जो कि पेज 1 पेज 2 या उससे अधिक के टैब होते हैं, शायद इसे सीट 1 सीट 2 सीट 3 की तरह कहा जाता है।
तो, ये टैब हैं और आप इस टैब का नाम बदल सकते हैं।
तो, यह नाम सीट 1 है यह सीट 2 है या कहें फोटो एल्बम 1 एल्बम 2 एल्बम 3 या जो कुछ भी है।
प्रोग्राम जो फ्रेम पर अलग मेनू आइटम को व्यवस्थित करने के लिए है और इसे फिर से रखा जा सकता है कंस्ट्रक्टर है, टैब को ऊपर या आमतौर पर नीचे रखा जा सकता है।
तो, आम तौर पर डिफ़ॉल्ट रूप से शीर्ष टैब्ड फलक होता है और फिर अन्यथा आप अपने अनुसार अनुकूलित कर सकते हैं।
और यह आपके अभ्यास के लिए फिर से एक सरल उदाहरण है, आप देख सकते हैं कि टैब्ड फलक एक फ्रेम में कैसे दिखाई देगा जो एक कंटेनर में शामिल है।
इसके कुछ निर्माता और फिर विधियाँ हैं।
यहां मूल रूप से यह लुक जैसा है जब भी आपको फ़ॉन्ट आकार का चयन करना होता है तो आप आमतौर पर माइक्रोसॉफ्ट वर्ड या अन्य वर्ड डॉक्यूमेंट प्रोसेसर में जानते हैं, मूल रूप से इस तरह का स्पिनर होता है।
आप क्लिक करते हैं यदि आप क्लिक करते रहते हैं तो एक मूल्य अपने आप बढ़ जाएगा और फिर वह इसे जारी करेगा फिर उस मूल्य को चुना जाएगा और फिर यदि आप इसे दबाते हैं तो वह मान इस तरह चुना जाता है।
और यह एक सरल उदाहरण है जिसके द्वारा कुछ डिफ़ॉल्ट मानों के साथ एक जेस्पिनर की योजना बनाई जा सकती है और आप विभिन्न मूल्यों को बदल सकते हैं, वहां हम जेस्पिनर को देख सकते हैं जब भी यह आपको प्रारंभिक मूल्य फी के साथ प्रदर्शित करता है और इसमें 0 से 10 तक सीमा होती है।
तो, हम तय कर सकते हैं कि सीमा क्या है।
इसलिए, उदाहरण के लिए, 0 से 100 भी हम इसे तय कर सकते हैं और यह मूल रूप से कदम है;
इसका मतलब है, कितना वृद्धि 0 1 इस तरह से अगर हम 0.5 कहते हैं;
इसका मतलब है कि, यहां बढ़ाई जा सकने वाली वेतन वृद्धि की दर।
तो, यह एक अलग तरीका है जेस्पिनर को नियंत्रित किया जा सकता है आप इस कार्यक्रम को अलग-अलग सेटिंग्स के साथ चला सकते हैं और फिर आप प्राप्त कर सकते हैं कि जेस्पिनर यहां कैसे दिखेगा।
और JFileChooser मूल रूप से है जब भी आपको एक सिस्टम प्रोग्राम विकसित करना होता है और फिर JFileChooser वास्तव में बहुत बेहतर होता है।
यहां मूल रूप से वर्तमान निर्देशिका में जो भी फाइलें हैं, वह इसे चुनेंगी और फिर इसे प्रदर्शित करेंगी और फिर यह किसी विशेष फ़ाइल का चयन करके कई घटनाओं को उत्पन्न करने और फिर इसे सहेजने या इसे कॉपी करने या इसे जो कुछ भी है उसे खोलने की अनुमति देगा।
तो, यह मूल रूप से जावा स्विंग में JFileChooser के अनुसार घटक जैसा दिखता है।
और यह एक सरल प्रोग्राम है जिसे आप अपने स्वयं की जांच कर सकते हैं, ये अलग-अलग फ़ोल्डर हैं जिन्हें आपने इस फ़ोल्डर में यहां शामिल किया है जो भी फाइलें हैं, यह मूल रूप से वहां प्रदर्शित होगी।
तो, आप इसे आज़मा सकते हैं और फिर आप दौड़ने के बारे में मज़े कर सकते हैं और आप देख सकते हैं कि यह कैसा है।
यदि आप निर्देशिका के अनुसार अलग-अलग निर्देशिका निर्दिष्ट करते हैं, तो यह जो भी फाइल है, वह फाइलें स्वचालित रूप से प्रदर्शित की जाएंगी।
और यह एक उदाहरण है जैसा कि हम देखते हैं कि हमने एक बटन बनाया है और फिर इसके दो क्षेत्र हैं और यह बंद है और यह कैसे, यदि आप इसे यहां क्लिक करते हैं, तो स्वचालित रूप से बंद हो जाएगा, और जब भी यह बंद होता है तो इसे क्लिक किया जाता है या पर टॉगल करें।
तो, जब भी कोई घटना होती है, तो टॉगल किया जाता है और फिर यह बिस कर सकता है कि बटन मान अपने आप इसे तदनुसार कहेगा और फिर उस मान का उपयोग किसी अन्य आवश्यकता के लिए किया जाएगा जो आपके कार्यक्रम में है।
यह एक उदाहरण है जैसा कि हम इस विकल्प 1 के तहत फ़ाइल संपादन विकल्प 1 को देखते हैं, इसलिए कई अन्य चीजें हैं।
तो, इसे टूलबार कहा जाता है जैसे यह मेनू बार के समान है, लेकिन यह एमएस टूलबार में विशेष है और हम इसका उपयोग कर सकते हैं।
तो, जैसा कि इसका उपयोग कुछ उपकरण विकसित करने के लिए किया जाता है, वह यह है कि नाम एक टूलबार है।
और इसमें दो वर्ग दो नेस्टेड वर्ग हैं और फिर इसके दो अलग-अलग मूल्य हैं और फिर निर्माणकर्ता हैं।
केवल एक कंस्ट्रक्टर और इतने सारे तरीके हैं।
इस तरह एक ही फ्रेम में।
तो, आप समझ सकते हैं कि वे वास्तव में आपके लिए क्या कर रहे हैं, और फिर यह सिर्फ एक शुरुआती बिंदु है।
आपको अंततः अपने कार्यक्रम को विकसित करने के लिए उपयोग करना होगा जिसे आप एक परियोजना तय कर सकते हैं और फिर उस परियोजना के लिए आप सोच सकते हैं कि आपके पास क्या है और इसे महसूस करने की कोशिश के अनुसार, और यह सब मूल रूप से यही तरीका है इस तरह की अवधारणा को सीखना वहां मौजूद है।
तो, यह JViewpoint है और फिर मैं कंटेनर क्लास में आऊंगा क्योंकि आप देखते हैं कि यह घटक है।
ऐसे कई घटक हैं, जिन्हें हमने इस मॉड्यूल के साथ-साथ पिछले मॉड्यूल में भी कवर किया है।
इसलिए, कंटेनर के लिए संबंध है कि 3 चीजें हैं फ्रेम पैनल डायलॉग बॉक्स और 1 कंटेनर भी एप्लेट है।
तो, एप्लेट को भी यहां जोड़ा जा सकता है और हालांकि हमने उसके लिए कोई उदाहरण नहीं दिया है, लेकिन यह मूल रूप से है यदि आप एक प्रोग्राम बनाते हैं जो एक एप्लेट को बढ़ाता है, और जो भी घटक आप जोड़ना चाहते हैं उसे एप्लेट में जोड़ा जा सकता है जिसे हम भी जब हम AWT के बारे में चर्चा कर रहे हैं, तो पहले ही पर्याप्त व्याख्या चर्चा दे चुके हैं।
तो, एक एप्लेट वही है जिसे हम वैसे भी इस चर्चा में यहाँ अनदेखा करते हैं।
कंटेनर के लिए, जैसा कि हम देखते हैं कि कंटेनर में विंडो शामिल है, यह इनपुट पैनल और डायलॉग भी फ्रेम कर सकता है और इसमें एक एप्लेट भी शामिल हो सकता है।
तो, ये पूर्ण हैं जिन्हें I माध्य अवधारणा कहा जाता है।
तो, जावा स्विंग में कंटेनर के लिए वहां संबंध है, और वे सभी चीजें वहां AWT में ही हैं।
तो, यह कुछ बेहतर के साथ एक जोड़ है जिसे लुक और फीलिंग कहा जाता है।
और इसमें पैनल जैसा कंस्ट्रक्टर है और फिर इसमें एक पे तर्क w बफर है;
इसका मतलब है, सभी सामग्री संग्रहीत की जा सकती हैं और लेआउट प्रबंधक का अर्थ है कि लेआउट प्रबंधक यदि आप पैनल में कई और आइटम जोड़ना चाहते हैं, तो यह लेआउट प्रबंधक है जिसे आपको अनुसरण करना होगा।
लेआउट प्रबंधक अवधारणा के रूप में ही है
लेआउट प्रबंधक जिसे हमने java.awt में चर्चा की है;
इसका मतलब है कि, फ्लो लेआउट वॉटर लेआउट ग्रिड लेआउट चार लेआउट उन सभी चीजों पर भी लागू होता है।
यही कारण है कि वे हैं कि जावा स्विंग में कोई स्पष्ट या विशेष असर नहीं है यही कारण है कि यह यहां शामिल नहीं है।
और यह एक उदाहरण है कि पैनल कैसे हो सकता है क्योंकि हम उन्हें यहां देखते हैं पूरी तरह से यह मूल रूप से एक फ्रेम है यह पूरा फ्रेम है, इस फ्रेम में पैनल है।
और इस पैनल में, दो बटन यहां जोड़े गए हैं।
तो, यह उदाहरण और है;
इस आउटपुट के लिए कार्यक्रम ऐसा दिखेगा जैसा यहाँ दिखाया गया है।
तो, आप इस प्रोग्राम को चला सकते हैं और आप आउटपुट देख सकते हैं, और आप एक प्रोग्राम में कई मापदंडों को बदल सकते हैं जो हमने वहां इस्तेमाल किया है और फिर आप इसे देख सकते हैं।
उदाहरण के लिए, पैनल की पृष्ठभूमि को बदला जा सकता है और फिर बटन के बजाय बटन आप इसमें कुछ अन्य घटक जोड़ सकते हैं जो कुछ भी यह है।
आप बहुत सारे प्रयोग कर सकते हैं, और इस कार्यक्रम को शुरू करने से आप कई चीजों को बदलना शुरू कर सकते हैं और वे इसे सीखते हैं।
तो, यह वास्तव में विचार है जिसका मैं उल्लेख करना चाहता हूं।
इसमें कुछ फ़ील्ड हैं जैसे सक्षम करने के लिए क्लोज़ रूट पेन चेकिंग पर बाहर निकलना।
तो, ये ऐसे कंस्ट्रक्टर हैं जिनका उपयोग आप प्रोग्राम करते समय कर सकते हैं और ऐसे ही कई तरीके हैं, इन विधियों का उपयोग करके पैनल के बारे में जानकारी निकाली जा सकती है जो आपके प्रोग्राम को नियंत्रित करने के लिए उपयोग की जा सकती हैं।
और यह एक सरल उदाहरण है जैसा कि हम देखते हैं कि यह एक फ्रेम है और इस फ्रेम में सरल बटन शामिल है और फिर यह मूल रूप से इसका उपयोग करेगा।
और फिर यह इस कार्यक्रम के रूप में हम यहाँ देख रहे हैं एक स्तर भी इस फ्रेम में प्रयोग किया जाता है।
तो, स्तर, बटन, एक बटन बटन के रूप में स्तर है और फिर फ्रेम एक के रूप में बनाया गया है।
तो, फ्रेम यह उनके शीर्षक है JFrame उदाहरण के लिए।
तो, यह एक ऐसी चीज है जिसे हमने एक साधारण कंटेनर में उपयोग किया है, लेकिन एक ही बात फिर से अगर आप इसे दोहरा सकते हैं, तो यहां केवल इसे बदल दिया गया है आपको इसे क्या बदलना चाहिए?
उदाहरण के लिए, आप इन चीजों को एक एप्लेट में शामिल करना चाहते हैं;
इसका मतलब है, हम उनके एप्लेट में फ्रेम जोड़ना चाहते हैं, केवल साधारण बदलाव के लिए आपको पब्लिक क्लास करना चाहिए।
मुख्य विधि के बजाय आप यहाँ कुछ अनोखी विधि लिख सकते हैं और फिर कोड इन सभी कोडों को शामिल कर सकते हैं, यह सब मूल रूप से एक फ्रेम बनाएगा और फिर फ्रेम में कुछ अन्य तत्व शामिल होंगे।
तो, यह एक सरल है जिसे आप पहले से ही अनुभव कर चुके हैं, जबकि हम AWT के बारे में चर्चा कर रहे हैं, कैसे एक घटक को एप्लेट में जोड़ा जा सकता है कि कैसे एक घटक को एक फ्रेम में जोड़ा जा सकता है।
तो, यह फ्रेम के बारे में विचार है और फिर कैलकुलेटर हमें एक विचार के बारे में देखने देता है।
हमने पहले ही एक उदाहरण दिया है कि अगर हम AWT का उपयोग करते हैं तो कैलकुलेटर कैसा दिखेगा।
अब उस समय को भी हमने समझाया है कि हमने उल्लेख किया है कि कैलकुलेटर बहुत अच्छा नहीं दिखता है, और बहुत से अन्य स्टाइलिंग जो आपको प्रोग्रामर के अंत से ही करना है ताकि कैलकुलेटर बहुत अच्छा और अधिक सुरुचिपूर्ण दिख सके।
हालांकि, जावा स्विंग में बहुत सादगी है;
ताकि प्रोग्रामर के बारे में बहुत अधिक सिरदर्द के बिना प्रत्येक के अच्छे दृश्य के अनुसार एक कैलकुलेटर को आसानी से खींचा जा सके।
और जैसा कि आप यहाँ देख रहे हैं यह एक बहुत अच्छा दिखने वाला कैलकुलेटर है और यह एक कैलकुलेटर है जिसे हम स्विंग घटकों का उपयोग करके आसानी से विकसित कर सकते हैं।
इसलिए, मैं आपको चरणबद्ध तरीके से कदम दूँगा जो भी विधि हम इस तरह के कैलकुलेटर को विकसित करने के लिए अनुसरण कर सकते हैं।
तो, ऐसी कौन सी विधि है जो आवश्यक है और फिर एक कैलकुलेटर को डिजाइन करना मूल रूप से वास्तव में पहली बार अभ्यास है।
यदि आप किसी कैलकुलेटर को सफलतापूर्वक डिज़ाइन कर सकते हैं, तो आप इस बारे में बहुत विश्वास अर्जित कर सकते हैं कि स्विंग का उपयोग आपकी आवश्यकता के लिए एक एप्लिकेशन विकसित करने के लिए कैसे किया जा सकता है जो हम आपकी आवश्यकताओं के अनुरूप हो सकते हैं।
अब, पहले जिस विधि का उल्लेख करना चाहिए, वह है।
इसलिए, हमें उस घटक के साथ जोड़ना होगा जो वह घटक है जिसका उपयोग करने की आवश्यकता है मान लीजिए कि हमें इसे एक फ्रेम के रूप में बनाना है या एक पैनल है, तो आपको इस घटक को जोड़ना होगा और फिर उन अन्य घटकों को जोड़ना होगा जिन्हें शामिल किया जाएगा। इस एक में।
इसलिए, वास्तव में जैसा कि हम वा को देखते हैं;
तो सभी बटन हैं।
तो, हम 16 बटन देख सकते हैं, साथ ही साथ एक, कुल बटन के बराबर है
कुल मिलाकर 17 बटन हैं और 17 बटन के अलावा जैसा कि हम देखते हैं कि 1 टेक्स्ट फील्ड एरिया है।
इसलिए, जैसा कि हम देखते हैं कि ये 17 बटन सही हैं और यह मूल रूप से फ्रेम क्षेत्र है और इस फ्रेम क्षेत्र में एक और टेक्स्ट फ़ील्ड भी है।
तो, दर्ज फ्रेम है और इस फ्रेम में, एक पाठ क्षेत्र क्षेत्र है और ये बटन हैं और यह 1 वहां है।
और बटन अब इस घटक में शामिल हैं;
जाहिर है, हम कुछ लेआउट प्रबंधकों का अनुसरण कर सकते हैं, शायद ग्रिड लेआउट प्रबंधक कह सकते हैं।
इसलिए, हम इस तरह एक ग्रिड लेआउट बना सकते हैं, फिर उसी के अनुसार हम इसे तय कर सकते हैं।
और यदि आप फ्लो लेआउट मैनेजर का उपयोग करते हैं तो हम यह भी कर सकते हैं कि जिस तरह से आप कोई समस्या नहीं कर सकते हैं।
तो, आप इसे समायोजित कर सकते हैं।
तो, ये 17 बटन हैं जिन्हें आप यह कह सकते हैं कि मान लीजिए कि यह एक ऐसा कह सकता है।
तो, सही-संरेखित करें या यह वहां है, हमने इस तरह 1 के लिए केंद्र-संरेखित का उपयोग किया है।
तो, वैसे भी, ये बटन हैं और फिर पाठ क्षेत्र और फिर पृष्ठभूमि ये कुछ चीजें हैं, जिन पर आपको विचार करना है।
तो, इस कैलकुलेटर के लिए डिजाइन का संबंध है।
आप नीले रंग के बजाय रंग बदल सकते हैं शायद मूक ऑडियो कम कहें जो भी हो।
तो, पहले हमें घटकों को जोड़ना होगा और फिर सभी घटकों को कंटेनर में शामिल करना होगा, हमें तब परिभाषित करना होगा और फिर समायोजित करना होगा।
और फिर अंत में, यह एक ऐसा रूप देगा जो मूल रूप से सिर्फ एक संरचना है, लेकिन हमें इस घटना को जोड़ना होगा अब घटना को कैसे जोड़ा जा सकता है?
हमने पहले से ही चर्चा की है कि हमें एक्शन श्रोता को पंजीकृत करना है जो एक्शन श्रोता है जिसे आप यहां उपयोग करना चाहते हैं।
यहां, उपयोगकर्ता, माउस है जो एक्शन श्रोता को वहां जोड़ा जा सकता है, एक्शन श्रोता को जोड़ सकता है या घटना को नियंत्रित करने के लिए निर्दिष्ट कर सकता है।
और फिर पृष्ठभूमि का रंग जो भी हो, आप इसे उस कैलकुलेटर का आकार चुन सकते हैं, यह भी आप सेट आकार फ़ंक्शन और फिर सेटटेक्स्ट का उपयोग करके तय कर सकते हैं;
सेटटेक्स्ट मूल रूप से टेक्स्ट को s के स्तर पर सेट करता है;
इसका मतलब है, जो भी स्तर हैं आप पाठ को सेट कर सकते हैं जैसे कि और फिर गेटटेक्स्ट मूल रूप से उस पाठ पर वापस आ जाता है जिसे हमने इसे यहां समतल किया है।
तो, यहाँ मूल रूप से 1 2 3 ये सभी चीजें टेक्स्ट हैं, जिन्हें हमने प्रत्येक बटन पर सेट किया है जैसे कि और फिर यह मूल रूप से मानों को लौटाएगा।
तो, क्या मूल्य यहां पाठ क्षेत्र में होगा या मूल्य यहां होगा, वे सभी चीजें यहां हो सकती हैं।
अब, इसके अलावा, जैसा कि हम देखते हैं कि ये कुछ अन्य हैं यह वास्तव में पाठ नहीं है, वे मूल रूप से कुछ ऑपरेशन के लिए हैं और उन ऑपरेशन का मतलब है अगर हम मूल रूप से सीए पर क्लिक करते हैं
कार्रवाई यह है कि इसके जो भी परिणाम हैं और फिर बाद की चीजें क्या हैं, इसमें प्रवेश किया जाएगा और फिर दोनों स्पष्ट रूप से जुड़ जाएंगे।
तो, यह वास्तव में यह विचार है।
अब, इसलिए, विचार यह है कि हमें पहले लेआउट को डिज़ाइन करना होगा और फिर उसमें सभी घटकों को रखना होगा और फिर अंत में, इवेंट हैंडलिंग तंत्र को परिभाषित करना होगा।
तो, ये कदम यहाँ प्रमुख कदम हैं।
अब, हमें यहां प्रत्येक चर्चा के लिए एक-एक करके सभी चरणवार देखें।
अब, इस चरण में यह पहला कदम है जो हम करते हैं वह है, जैसा कि हम यहाँ देखते हैं कि हम धीरे-धीरे चलते हैं, ताकि आप इसके बारे में समझ सकें।
इसलिए, हम एक कैलकुलेटर बना रहे हैं जो JFrame का विस्तार करता है और ActionListener को लागू करता है क्योंकि हम वहां घटना को शामिल करना चाहते हैं।
अब, तो, पहले हम एक JFrame बनाते हैं और यह एक फ़िल्टर फ्रेम है और फिर टेक्स्ट फ़ील्ड जो कि l और 0 s 1 और s 2 के रूप में दी जाती है, वे 3 स्ट्रिंग्स हैं जिन्हें हमने 2 स्पष्ट और एक परिणाम के लिए माना है।
तो, एक कैलकुलेटर बा कंस्ट्रक्टर है शुरू में वे मूल रूप से अशक्त धारा हैं और इसलिए शुरू में, कैलकुलेटर का मूल रूप से अशक्त मूल्य है और फिर हमें मेनफ्रेम मुख्य विधि पर जाना होगा।
मुख्य विधि स्विंग कैलकुलेटर का उपयोग करके एक फ्रेम च बनाता है।
तो, यह मूल रूप से यहां शीर्षक होगा या इसे यहां प्रदर्शित किया जाएगा।
तो, कैलकुलेटर में तो जैसे दिखते हैं, इन चीजों के साथ, यह मूल रूप से इस तरह का निर्माण करेगा।
अब अगर हम अगला कदम रखते हैं;
हमारा चरण 2 और फिर चरण 2 में जैसा कि हम देखते हैं कि हम केवल एक UIManger का उपयोग करते हैं यह एक जावा स्विंग में स्वयं SetLookAndFeel में परिभाषित किया गया है।
UI Manger। सिस्टम लुक और फील क्लास नाम प्राप्त करें।
तो, मूल रूप से स्वचालित रूप से परिभाषित किया जाता है जो भी आपके पास हो सकता है।
तो, यह मूल रूप से यह एक डिफ़ॉल्ट रूप है कि हमने इसे यहां इस्तेमाल किया है और यदि यह मान लें कि यह इस UIManger को तय करने में सक्षम नहीं है, तो यह बस इस तरह एक त्रुटि फेंक देगा।
किसी भी तरह से हम इसे एक कर सकते हैं और सिस्टम को देख सकते हैं और महसूस कर सकते हैं कि एक वर्ग का नाम मूल रूप से आपको दे रहा है कि UIManager क्या हैं जिन्हें आप शामिल कर रहे हैं।
यह लेआउट मैनेजर कॉन्सेप्ट के समान ही है, यह यहाँ जावा स्विंग एक्सप्रेशन में है जिसे यूजर इंटरफेस मैनेजर यूआईमंगर जैसे कहा जाता है।
वैसे भी हम एक कैलकुलेटर ऑब्जेक्ट बनाते हैं c एक प्रकार है जिसे हमने पहले से ही कंस्ट्रक्टर को डिजाइन किया है जिसमें शुरुआती मूल्य s 0 के बराबर है 1 s के बराबर है 2 गैर-स्ट्रिंग के बराबर है और फिर हम एक टेक्स्ट फ़ील्ड बनाते हैं जो वे तब टेक्स्ट फ़ील्ड है और संपादन योग्य सेट करें;
इसका मतलब है, पाठ क्षेत्र संपादन योग्य हो सकता है हम यहाँ कुछ कोशिश कर सकते हैं यही कारण है कि यह संपादन योग्य बनाता है और यह एक गलत साधन है कोई संपादन योग्य संभव नहीं है।
इसलिए, हम यहां कुछ भी टाइप नहीं कर सकते हैं और फिर हम ऐसा बनाते हैं, कई बटन बी 0 से बी नौ तक संख्यात्मक बटन और बी 8 से बीएम इसके अलावा घटाव और विभाजन गुणन के लिए बराबर और बी बराबर बी बराबर बी बी बराबर अन्य 2 भी हैं वैसे भी बनाया।
और फिर हम इन सभी बटन को जोड़ते हैं या हम
कुछ स्तर के साथ एक बटन v 0 बनाएं जैसा कि यहां दिखाया गया है।
इसलिए, हम अभी हम चरण 2 को फिर से जारी रख रहे हैं, क्योंकि वहाँ और कुछ वस्तुओं को जोड़ा जाना है।
तो, हम इन सभी वस्तुओं को जोड़ रहे हैं सभी बटन वहाँ हैं 0 0 से 9 बटन इन सभी को मूल रूप से कुछ अतिरिक्त घटाव गुणा किया गया है ये सभी बटन लेबल के साथ हैं ये सभी चीजें हैं और 10 बी एक और बटन डॉट के साथ बनाया गया है।
तो, बिंदु है और बी के बराबर एक और बटन भी जोड़ा जाएगा।
अब, JPanel p नए पैनल के बराबर है जो हम 1 पैनल बनाते हैं जो एक पैनल है जिसे हम मूल रूप से शामिल करना चाहते हैं यह मूल रूप से है क्योंकि हम फ्रेम के बजाय यह कह सकते हैं कि यह वास्तव में एक पैनल है।
इसलिए, इस पैनल में, हम इन सभी चीजों को वहां जोड़ना चाहते हैं।
अब हम यहां एक्शन श्रोता पद्धति को परिभाषित कर रहे हैं।
तो, इस वर्ग घटक के लिए bn bd bs ba वास्तव में यहाँ है, इस मामले में, घटक की गणना करें।
इसलिए, हम कुछ तरीकों को जोड़ रहे हैं कि अगर हम bn दबाते हैं तो यह किस क्रिया का उत्पादन करेगा।
तो, ये वही चीजें हैं जिन्हें यहां घोषित किया गया है।
इसलिए, ये उन सभी घटकों के लिए क्रिया श्रोता हैं, जिन्हें हमने यहां शामिल किया है, हमने इसे वहां जोड़ा है।
और फिर अगला चरण मूल रूप से एक बार सभी घटकों को बटन में जोड़ा जाता है और हमें प्रत्येक के लिए किए गए कार्य को परिभाषित करना होगा जिसे घटक कहा जाता है।
तो, यहां पर कार्रवाई के लिए एक रूटीन है कि आपको इसे लिखना होगा।
अब यहाँ अगर s dot 0;
इसका मतलब है, पहला वर्ण 0 है या यह 9 से कम है या यह एक है।
तो, यह मूल रूप से यहाँ पर चल रहा है।
तो, अगर आप यहां इस एक में कुछ टाइप करते हैं।
तो, अगर आप यहां इस एक में कुछ टाइप करते हैं।
तो, 45.6।
तो, यह 45.6 की तरह यहाँ प्रदर्शित किया जाएगा।
तो, यह मूल रूप से पहली चीज है जो हम कर रहे हैं और फिर।
तो, यह मूल रूप से निरंतरता है।
इसके बाद यहां हम यह स्पष्ट कर रहे हैं कि क्या अलग-अलग चीजें उदाहरण के लिए एक ऐप हैं, अगर यह सही है, तो यह चीज़ समान है और फिर मूल रूप से योग है और फिर यदि यह स्पष्ट है।
तो, सी बटन है अगर हम तो यह मूल रूप से क्या होगा और फिर होगा।
तो, ये विभिन्न क्रियाएं हैं यदि प्लस या माइनस या विभाजन के लिए कुछ हुआ है तो यह मूल रूप से है कि यह इन सभी चीजों को क्या करेगा।
इसलिए, जब भी आप इसका सामना करते हैं तो मूल रूप से एक स्ट्रिंग दूसरे रीड स्ट्रिंग पढ़ें।
ताकि, उन स्ट्रिंग और वहाँ संलग्न करें और फिर परिणाम प्राप्त किया जाएगा।
तो, यह वह प्रक्रिया है जिसके द्वारा विभिन्न क्रियाएं सुन सकती हैं और इन क्रियाओं के लिए, परिणाम वहां जोड़ा जा सकता है और संचालन होगा।
तो, सेट टेक्स्ट एक स्तर है जिसका मतलब है कि टेक्स्ट फ़ील्ड क्षेत्र इसे यहाँ दिखा सकता है।
अब तो, विचार करें कि एक कैलकुलेटर कैसे डिज़ाइन किया जा सकता है मैंने इसके बारे में एक विचार दिया है।
इसलिए, दो चीजें हैं पहले आपको पूरे लेआउट की योजना बनानी होगी और फिर लेआउट के अनुसार, हमें यह तय करना होगा कि अलग-अलग घटकों को क्या शामिल किया जाना है और फिर आप उन्हें शामिल करते हैं
घटकों और फिर आपको एक्शन हैंडलिंग तंत्र को जोड़ना होगा जो सभी है।
तो, इस तरह से आप हम कर सकते हैं।
इसलिए, यह कार्यक्रम जैसा कि मैंने आपके अभ्यास के लिए दिया है, मुझे आपको इस कार्यक्रम को चलाने की सलाह देनी चाहिए, और फिर आप देखेंगे कि यह कैसे काम कर रहा है और फिर भाग द्वारा कार्यक्रम निष्पादन बेहतर है, ताकि आप इस अवधारणा को स्पष्ट रूप से समझ सकें।
वैसे भी, हमने एडब्ल्यूटी और स्विंग के बारे में सीखा है और ये चीजें विंडो प्रोग्रामिंग के लिए बहुत आवश्यक हैं, साधारण प्रो प्रोग्रामिंग के अलावा जो हमने मल्टी-थ्रेडिंग इनपुट-आउटपुट हैंडलिंग और फिर कैपसुलेशन में सीखी हैं, वे सभी चीजें हैं , लेकिन यह वास्तव में आपके प्रोग्रामिंग क्षेत्र में अधिक रंग जोड़ देगा।
और यहाँ स्पष्ट रूप से, आपके पास यह जवाब हो सकता है कि क्या स्वेट स्ट्रिंग और एडब्ल्यूटी दोनों को एक साथ छिद्रित किया जा सकता है या नहीं;
जाहिर है, यह संभव है और फिर जैसा कि आप देखते हैं यदि आप AWT और स्ट्रिंग की तुलना करते हैं तो वे कई अन्य मापदंडों के संदर्भ में तुलनीय हैं, लेकिन 1 पैरामीटर यह है कि स्विंग आपको AWT की तुलना में बहुत अधिक तत्व देता है।
यह वास्तव में बहुत अधिक है।
अब मैं इसे एक अभ्यास के रूप में बताता हूं कि आप कितने वर्गों का उपयोग कर सकते हैं।
तो, AWT के लिए चिंतित है और इसमें कितने स्विंग हैं।
अब आप इसे गिन सकते हैं और आप बस यह जान सकते हैं कि स्विंग मो बहुत अधिक विस्तृत और अधिक चमकदार है।
हालांकि, AWT की तुलना में इसका उपयोग करना आसान है और यह आपको और अधिक देता है जिसे स्मार्ट-लुकिंग प्रोग्राम डेवलपमेंट कहा जाता है।
तो, इस मॉड्यूल में भाग लेने के लिए धन्यवाद।
कंप्यूटर विज्ञान इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर व्याख्यान में जावा प्रो। देबासीस सामंता विभाग में प्रोग्रामिंग - 12 प्रदर्शन - वी पिछले मॉड्यूल में, हमने जावा में स्थिर गुंजाइश भूमिका के बारे में सीखा है और एक पुनरावर्ती कार्यक्रम लिखने के बारे में भी थोड़ा-बहुत।
इस प्रदर्शन में, हमारे पास सीखने और फिर पुनरावर्ती कार्यक्रम लेखन के दायरे के नियमों के बारे में विभिन्न अवधारणाओं का एक त्वरित चित्रण है।
इससे पहले कि हमारे पास बुनियादी नियंत्रण संरचना होनी चाहिए, मुझे पता है कि आप, यदि आप पहले से ही उन सभी बुनियादी नियंत्रण संरचनाओं के लिए एक अनुभवी सी प्रोग्रामर हैं, तो आप के लिए जाना जाता है, लेकिन उन लोगों के लिए नए हैं यह सिर्फ स्थिरता बनाने के लिए है हम बस जल्दी से चर्चा करेंगे।
इसलिए, अलग-अलग लूप संरचनाएं हैं और फिर स्विच केस को कवर किया जाएगा और फिर अंत में, स्कोर्स नियम और फिर जावा प्रोग्राम राइटिंग पर एक रिकर्सर्स फ़ंक्शन का उपयोग करके चर्चा करें।
तो, चलिए पहले हमारे उदाहरण के बारे में क्विक डेमो करते हैं कि कैसे हम लूप का उपयोग कर सकते हैं और प्रोग्राम को देखते हैं।
तो, यह एक कार्यक्रम है क्योंकि आप देख सकते हैं कि यह कार्यक्रम मूल रूप से समय का उपयोग करता है और इसके भीतर कुछ समय और एक शर्त है;
इसका मतलब है, यह लूप तब तक जारी रहेगा जब तक कि गिनती का मान 11 से कम नहीं हो जाता।
और आप अनुमान लगा सकते हैं कि इसमें क्या है जबकि लूप में मूल रूप से प्रिंट स्टेटमेंट शामिल है, यह मूल रूप से 0 के बाद से शुरू होने वाले विषम संख्याओं को प्रिंट करेगा। 0 के बाद अगला नंबर स्टार है, तो 1 1 5 7 इस तरह से।
अब, हम इस प्रोग्राम को चलाते हैं।
तो, आप देख सकते हैं कि यह लूप कैसे रोल करेगा, आप संकलन लिखते हैं, आपको इसे सही जावा सी को संकलित करना है। इसलिए, यह एक प्रोग्राम है जिसे यहाँ संकलित किया गया है, हम देख सकते हैं कि यह प्रोग्राम सफलतापूर्वक संकलित हो गया है। हम इस कार्यक्रम को चलाते हैं।
तो, हाँ, हाँ और जैसा कि आप देख सकते हैं कि यह पहले दस विषम संख्याएँ है।
अब, यह लूप का एक रूप है अब हमें एक और रूप देना है जिसे हम 5.2 प्रोग्राम खोल सकते हैं
तो, यह एक और कार्यक्रम है और यह पहले के कार्यक्रम में एक ही चीज है जो विषम संख्या को प्रिंट कर रहा है, लेकिन जैसा कि आप देख सकते हैं कि यह कार्यक्रम पहले दस सम संख्याओं को प्रिंट करना है।
और यहाँ के बजाय जबकि हम बयान करते समय इस्तेमाल किया है और ज्यादातर एक ही बात है, लेकिन जाहिर है, समय और समय के बीच अंतर है।
अब हम इस प्रोग्राम को चलाते हैं और फिर चलिए पहले हमें इस प्रोग्राम को चलाते हुए इसे हाँ में संकलित करना है।
इसलिए, यह मूल रूप से इसे प्रिंट करता है, अब अगर मैंने आपसे पूछा कि समय और समय के बीच क्या अंतर है?
तो, जबकि मूल रूप से पहले स्थिति की जांच करते हैं, जबकि कम से कम एक लूप रोल करेगा और फिर एक बार एक लूप किया जाता है, तो अंत में स्थिति की जांच करें।
तो, अंतर यह है कि जबकि लूप एक ही लूप में निष्पादित नहीं होता है, लेकिन कम से कम एक लूप निष्पादित किया जाएगा।
अब, जैसे ही करते हैं और करते हैं जबकि जावा में एक और कंस्ट्रक्टर है इसे लूप के लिए कहा जाता है।
लूप के लिए लूप पूरी तरह से अलग है जबकि लूप या लूप करते समय अलग है।
अब, किसी भी लूप के मामले में, तीन चीजों को लूप वेरिएबल के लिए इनिशियलाइज़ेशन माना जाता है, पहले दो उदाहरणों में लूप वैरिएबल को गिना जाता है।
अब, लूप वेरिएबल का इनिशियलाइज़ेशन और फिर कंडीशन चेकिंग;
इसका मतलब है कि क्या लूप पहुंच गया है, यह समाप्ति की स्थिति है या नहीं और फिर लूप चर को अपडेट करना है।
अब एक पंक्ति में कथन के लिए तीनों चीजों का उपयोग किया जा सकता है।
अब यहां हम पहला कथन देख सकते हैं int i, इस मामले में, यह लूप वेरिएबल है;
इसका मतलब है कि, यह वह चर है जो लूप के निष्पादन को नियंत्रित करता है।
तो, यहाँ int i = 1;
इसका मतलब है, लूप वेरिएबल को 1 के रूप में इनिशियलाइज़ करना और यह वह स्थिति है जो यह देखती है कि जब तक आई की वैल्यू 11 से कम नहीं हो जाती है, तब तक जारी रहेगी।
एक बार, i = 11 या उससे अधिक का मान लूप से बाहर निकल जाएगा और i ++ के लूप पूरा होने के बाद एक बार उसका कार्यकाल पूरा हो जाएगा तो यह उस मूल्य को बढ़ा देगा जो मैं अपने आप में है।
अब यहाँ लूप के लिए, जैसा कि आप देख सकते हैं एक साधारण प्रिंट स्टेटमेंट है जो मूल रूप से i के मूल्य को प्रिंट करता है।
इसका मतलब यह है कि यह लूप के लिए i = 1 से i = 10 का 10 वां पहला पूर्णांक नंबर छपेगा।
इसलिए, यदि हम इस कार्यक्रम को चलाते हैं तो हम यह देख पाएंगे कि यह लूप आपके लिए कैसे काम करता है।
इसलिए, यह लूप के लिए जैसा कि हमें उम्मीद थी कि यह लगातार 1 से 10 प्रिंट करता है।
अब, इसलिए, यह लूप के लिए और जावा प्रोग्राम में लूप या तीन लूप संरचनाओं के लिए एक उदाहरण है, यह उन संरचनाओं के समान है जो पहले से ही C और C ++ में हैं।
अब, लूप को नियंत्रित किया जा सकता है या इसे असामान्य रूप से समाप्त किया जा सकता है और इस चीज के लिए इससे पहले कि दो और बयान हों, ब्रेक और जारी है।
तो, जारी बयान का उद्देश्य यह है कि यदि कुछ शर्त पूरी हो जाती है तो यह लूप ब्लॉक के लिए शेष भाग को निष्पादित नहीं करेगा।
उदाहरण के लिए, इस उदाहरण में लूप के लिए हमारे पास यह है अगर मैं;
इसका मतलब है कि, मैं नहीं 2 का मतलब है कि अगर मैं एक सम संख्या है, तो यह अगले कथन को निष्पादित नहीं करेगा अर्थात् system.out प्रिंट ln और यह लूप के अगले दौर में जाएगा।
तो, जारी रखें मूल रूप से लूप में शेष भाग को फिर से लूप पर छोड़ दें।
अब अगर हम इस कार्यक्रम को चलाते हैं, जैसा कि आप अनुमान लगा सकते हैं कि यह लूप के लिए पहला स्टेटमेंट प्रिंट होगा;
इसका मतलब है कि, यह एक लाइन में दो नंबर प्रिंट करेगा और जब भी कोई मोड आएगा यह इस तरह की अगली पंक्ति में जाएगा।
तो, क्या प्रिंट स्टेटमेंट यहां मूल्यों को प्रिंट करेगा।
यहां हम एक पंक्ति में 0 1 देख सकते हैं और फिर मोड, 2 यह अगले और इतने पर जाता है।
इसलिए, जारी रखें विवरण को लूप के लिए प्रत्येक विषम-सम संख्या के बाद निष्पादित किया जाता है।
तो, यह जारी रखने के बारे में विचार है जैसे जारी रखना एक ब्रेक स्टेटमेंट है;
जब भी कोई स्थिति पहुंचती है तो ब्रेक स्टेटमेंट।
तो, यह लूप नियंत्रण समाप्ति मानदंड की संतुष्टि के बिना मूल रूप से लूप को समाप्त करता है।
तो, यह एक उदाहरण है यहां हम यहां देख सकते हैं i मोड 10 इंगित करता है कि जब भी मैं का मान 10 तक पहुंचता है या 10 का एकाधिक जो भी वहां है, तो लूप समाप्त हो जाएगा।
तो, इसमें लूप के लिए जैसा कि हम int i = 1 देख सकते हैं और आप देख सकते हैं कि यहाँ की स्थिति मूल रूप से अशक्त है, हम कोई शर्त नहीं देते हैं;
इसका मतलब है, अगर आप वहां कोई शर्त नहीं लगाते हैं तो वह लूप अनंत समय के लिए निष्पादित होगा।
लेकिन अगर कोई ब्रेक स्टेटमेंट है और अगर कोई शर्त है जो इस शर्त को पूरा करती है तो ब्रेक स्टेटमेंट निष्पादित किया जाता है तो लूप को समाप्त कर दिया जाएगा।
इसलिए, हालांकि यह एक अनंत लूप की तरह दिखता है, क्योंकि ब्रेक के कारण, एक शर्त है कि यह लूप को समाप्त कर देगा।
अब, हम इस कार्यक्रम को चलाते हैं क्योंकि आप देख सकते हैं कि यह i = 1 2 3 और i = 10 तक पहुँच जाएगा;
एक बार i = 10 लूप टूट जाएंगे और यह लूप को समाप्त कर देगा।
तो, यह मूल रूप से अवधारणा है कि ब्रेक स्टेटमेंट कैसे है?
अब तो, हमने बुनियादी नियंत्रण संरचनाओं के बारे में जान लिया है, जबकि मुख्य रूप से करते समय और ब्रेक के साथ और जारी रखते हैं।
अब, सरल नियंत्रण संरचनाओं के अलावा मूल रूप से एक निर्णय संरचना है अगर और;
अगर बहुत सरल है, तो हमें इस पर विस्तृत तरीके से चर्चा नहीं करनी है, लेकिन इस तरह से अगर int है तो स्विच केस के माध्यम से जावा में एक से अधिक निर्णय जाँच की जाती है।
अब, हम स्विच के मामले में अगले कार्यक्रम पर चर्चा करेंगे;
अब स्विच केस स्टेटमेंट पर चर्चा करने के लिए यहां जाने से पहले एक उदाहरण है कि मूल रूप से हम यह परीक्षण कर सकते हैं कि कोई संख्या प्रधान है या नहीं।
तो, यह मूल रूप से लूप के लिए दोनों का उपयोग है और साथ ही अगर अब मूल रूप से आपको एक निश्चित संख्या के प्राइम तक परीक्षण करना है या नहीं, तो शर्त यह है कि मैं संख्या 2 से कम हूं क्योंकि, आपको इस तरह की चीजों की जांच करनी होगी ;
इसका मतलब है, अगर इस संख्या 2 के भीतर कोई संख्या है अगर हमें यह परीक्षण करना है कि क्या संख्या एक प्रमुख है या नहीं।
इसलिए, इन चीजों में से आधे तक हमें इस लूप को रोल करना होगा।
इसलिए, हम जांच सकते हैं कि इस सीमा के भीतर कोई भी संख्या इस संख्या से विभाज्य है या नहीं, इसलिए अंकों की विभाज्यता की जांच संख्या i से नहीं है।
तो, यह मूल रूप से विभाज्यता की जांच करता है।
इसका मतलब है कि यह इस से विभाज्य है जहां मैं मूल रूप से उस सीमा से 2 है और फिर अगर यह वहां है तो यह जांच करेगा कि ठीक है, यदि यह विभाज्य है तो यह एक प्रमुख नहीं है।
इसलिए, प्रत्येक प्राइम एक बूलियन वैरिएबल है जिसे एक झूठा घोषित किया गया है और फिर तोड़ा गया है क्योंकि अधिक परीक्षण की आवश्यकता नहीं है अन्यथा यह जारी रहेगा।
अब, हम कीबोर्ड से इनपुट पास करके इस प्रोग्राम का परीक्षण कर सकते हैं और यहाँ इस प्रोग्राम कैपिटल का निष्पादन है, इसलिए 5.6।
तो, अब, v 6 जैसा कि यह 6 पर है प्रधान है अब हम इस 31 को चलाते हैं;
31is एक प्राइम, तो यह उस प्राइम की जाँच करेगा।
तो, इस तरह से, आप परीक्षण कर सकते हैं कि इस नियंत्रण का उपयोग करके हम इसका परीक्षण कर सकते हैं।
इसलिए, तर्क मूल रूप से किसी भी तर्क का उपयोग करते समय या उसके बाद लागू किया जा सकता है और फिर यदि कोई अन्य तर्क संरचना है तो जैसा कि मैंने आपको बताया था कि स्विच केस संरचना हमें एक सरल प्रोग्राम पर विचार करने देती है।
और यह स्विच केस मूल रूप से यहाँ है जिसे हम देख सकते हैं।
तो, और हम देख सकते हैं कि पहले कुछ ब्लॉक हैं, जबकि ब्लॉक करना मूल रूप से कुछ को प्रिंट करता है जब तक कि आप किसी भी प्रकार को टाइप करने पर 1 से 5 किसी भी संख्या को टाइप करते हैं।
इसलिए, यह लूप जारी रहेगा।
तो, इस लूप से बाहर आने के लिए, आपको या तो 1 या किसी भी संख्या को प्रिंट करना होगा जो वास्तव में 5 से कम है।
इसलिए, यदि आप किसी भी संख्या को 5 से बेहतर लिखते हैं, तो यह मूल रूप से लूप को तोड़ देता है, आइए हम एक बार यहां से चुने गए मूल्य को देखें।
इसका मतलब है कि उपयोगकर्ता किसी भी मूल्य में प्रवेश कर सकता है जो auricles से 5 से 1 या 1 से अधिक है;
अब एक बार मूल्य पढ़ा जाता है और फिर एक मामला होता है।
अब, इसलिए, ये नियंत्रण संरचनाएं हैं जो आपके जावा प्रोग्राम में व्यापक रूप से उपयोग की जाती हैं और आपको यह सीखना होगा कि आपको इसका अभ्यास करना है।
तो, आप इन सभी कार्यक्रमों के बारे में बहुत कौशल होना चाहिए;
अब एक बार जब चीजें हैं तो इस चर्चा प्रदर्शन में हमारे अगले विषय हैं गुंजाइश नियम का उपयोग।
जैसा कि आपने चर्चा की है कि जावा 2 स्कोप के नियम को स्थिर और गतिशील बनाता है, इसलिए इस प्रदर्शन में हम अपनी चर्चा को केवल स्टैटिक स्कोप से ही पूरा करेंगे।
अब, हम इस कार्यक्रम पर एक त्वरित नज़र डालते हैं और यहाँ हम एक वर्ग को परिभाषित कर सकते हैं कि कक्षा का नाम प्रदर्शन_58 है, ये कक्षा का एक नाम है और इस वर्ग के अंतर्गत केवल मुख्य विधि बहुत ही सरल वर्ग है।
और आप उन्हें देख सकते हैं, मुख्य विधि के लिए मिलान और फिर शुरुआत में घुंघराले ब्रैकेट हैं।
इसके अतिरिक्त, हम परिभाषित करते हैं कि एक प्रोग्राम में एक ब्लॉक {} के माध्यम से निर्दिष्ट किया जा सकता है।
तो, यहाँ ब्लॉक यह वहाँ है;
अब इस ब्लॉक के अंदर इस ब्लॉक में, आपको x = 10 दिखाई देता है क्योंकि पूर्णांक चर घोषित किया गया है।
अब तक, गुंजाइश नियम चिंतित है x का मान केवल इस ब्लॉक के भीतर ही मान्य है;
इसका मतलब है, यह मान्य है कि system.out.print ln x सही है।
हालाँकि, इस ब्लॉक के बाहर अगर हम एक system.out.print ln x को एक्सेस करने का प्रयास करते हैं तो यह एक त्रुटि देगा और संकलन समय के दौरान त्रुटियों को रिपोर्ट किया जा सकता है।
अब, हम इसे अंतिम स्टेटमेंट सिस्टम बदलते हैं।
इसका मतलब है, हम इसे प्रिंट करने की कोशिश कर रहे हैं, हालांकि इसमें गुंजाइश नहीं है कि अब इस कार्यक्रम को बचाएं और इस कार्यक्रम को चलाएं और हमें देखें कि क्या होगा।
तो, यह एक त्रुटि देगा क्योंकि System.out.prinln (x) इस वर्ग में अंतिम विवरण उस दायरे से बाहर है जो x नहीं है।
तो, यह मूल रूप से एक संकलन त्रुटि है।
अब, फिर से अगर हम इसे प्रोग्राम को कमेंट करते हैं और फिर हम देखेंगे कि यह प्रोग्राम सफलतापूर्वक संकलित हो जाएगा और निष्पादन योग्य भी इस प्रोग्राम को सहेजेगा।
इसलिए, कार्यक्रम अब सफलतापूर्वक संकलित किया गया है पहले यह एक त्रुटि दे रहा था अब कार्यक्रम परिणाम देगा कि यह x = 10 है।
तो, आप इस दायरे को समझ सकते हैं यह एक बहुत ही सरल उदाहरण है, लेकिन यह समझ में आता है:
एक ब्लॉक के अंदर एक चर का दायरा क्या है।
तो, यह एक ब्लॉक में गुंजाइश है।
अब कुछ और उदाहरण है।
यह एक और उदाहरण है, आप देख सकते हैं और आप यह भी समझ सकते हैं कि इस उदाहरण का दायरा क्या है।
अब आप मुझे बता सकते हैं कि इस उदाहरण की गुंजाइश क्या है;
जहाँ x वह चर है जिसके लिए हम दायरे पर चर्चा करना चाहते हैं।
अब, अगर आप यहाँ int x = 0 देखते हैं, तो इसे लूप के लिए घोषित किया जाता है, इसका मतलब है कि यह केवल लूप के लिए x का स्कोप है।
तो, एक लूप के लिए, एक प्रिंट स्टेटमेंट होता है जो x के मान को प्रिंट करता है, लेकिन इसके बाहर, लूप के लिए, यदि आप इसे प्रिंट करने का प्रयास करते हैं तो यह एक त्रुटि देगा।
इसलिए, हमें इसे अनसुना कर दें और फिर इस प्रोग्राम को चलाएं तब आप समझ पाएंगे कि यह एक कंपाइल-टाइम एरर देगा क्योंकि यहाँ स्टेटमेंट यह स्कोप से बाहर है।
तो, यहाँ x इन मानों का मान चर x इस पाश के लिए है।
तो, यह एक त्रुटि है परिभाषा है कि गुंजाइश नहीं है;
अब फिर से टिप्पणी करें कि यह प्रोग्राम को सेव करें और फिर इस प्रोग्राम को चलाएं यहां कोई संकलन त्रुटि नहीं है और इसे चलाने पर यह मूल रूप से लूप के लिए प्रिंट होगा इस मामले में सफलतापूर्वक निष्पादित किया जाएगा।
तो, लूप निष्पादित होने पर आप इसे देख सकते हैं।
अब आप स्कोप नियम को कैसे बदल सकते हैं अब हमें एक और उदाहरण पर आते हैं, ताकि हम यह देख सकें कि यहाँ स्कोप कैसे बढ़ाया जा सकता है।
तो, अगला उदाहरण पिछले उदाहरण के समान है।
यहाँ आप int x देख सकते हैं जो लूप के लिए बाहर घोषित किया गया है, इसका मतलब है कि लूप का मान पूरे फ़ॉर्शन के साथ-साथ लूप के लिए भी है।
पहले जब इसे इसके भीतर घोषित किया गया था, तब इसे केवल इसके भीतर ही स्कोप किया गया था, लेकिन इस मामले में, यह पूरा कार्यक्रम है।
इसलिए, यह कार्यक्रम स्व-व्याख्यात्मक है क्योंकि हम पहले ही इसके बारे में समझ चुके हैं।
तो, यह गुंजाइश और ठीक की सरल अवधारणा के बारे में है।
तो, आइए एक और उदाहरण पर चर्चा करें, जिसमें गुंजाइश के अलग-अलग संदर्भ हैं आइए हम कार्यक्रम को 5 अंक 5.11 हाँ ठीक चलाते हैं।
x और y अगला कथन मान्य है क्योंकि यह इस दायरे में होगा।
हालाँकि, इस y = 100 के बाहर यह एक त्रुटि देगा।
अब हम इस प्रोग्राम को चलाते हैं और फिर हम देख सकते हैं कि यह कंपाइल-टाइम एरर दे रहा है।
इसलिए, इन सभी त्रुटियों को संकलन समय के दौरान सूचित किया जाएगा;
इसका मतलब है, जावा कंपाइलर आपके लिए सभी वेरिएबल्स के दायरे की जाँच करेगा।
इसलिए, यदि गुंजाइश में कोई त्रुटि है तो यह रिपोर्ट करेगा कि प्रतियोगिता सफल नहीं होगी।
तो, यह संकलन-समय की त्रुटि है जिसे हम कह सकते हैं।
अब, यदि हम इसे टिप्पणी करते हैं तो निश्चित रूप से क्योंकि गुंजाइश अब बंद है और फिर यह है कि यह पूरी तरह से काम करेगा।
तो, यहाँ कोई संकलन त्रुटि कार्यक्रम कार्यक्रम के अनुसार आउटपुट नहीं देगा।
इसलिए, हम यहाँ गुंजाइश की अवधारणा को समझ सकते हैं।
अब, जावा कार्यक्रम में वैश्विक चर विचार पर चर्चा की गई गुंजाइश के बारे में कई और बातें हैं, जावा वैश्विक चर की घोषणा का समर्थन नहीं करता है।
हालांकि, वैश्विक चर की अवधारणा एक वर्ग चर की अवधारणा के माध्यम से है;
एक वर्ग चर और फिर उदाहरण चर, जैसा कि हम पहले ही इसके बारे में जान चुके हैं।
यहाँ, उदाहरण के लिए, xyr ये उदाहरण चर हैं क्योंकि उन्हें एक प्रकार के रूप में सरल घोषित किया जाता है;
दूसरी ओर यदि हम एक स्किवर स्टैटिक के साथ एक वैरिएबल घोषित करते हैं तो इसे क्लास वेरिएबल कहा जाता है, इस मामले में, हम देख सकते हैं कि सर्कल काउंट एक क्लास वेरिएबल का एक उदाहरण है।
इसलिए, हमने यहां एक वर्ग चर नाम दिया है जिसे सर्कल गणना और फिर तीन उदाहरण चर x y r और ये वर्ग सर्कल के निर्माता का सामान्य कोड है।
इसलिए, हम पहले ही चर्चा कर चुके हैं कि मैं इस पर और अधिक चर्चा नहीं करना चाहता और दो तरीकों में हमेशा की तरह त्रुटि है।
अब, हम यहाँ मुख्य विधि पर आते हैं;
अब आपको मुख्य विधि को थोड़ा ध्यान से देखना होगा।
तो, पहले बयान में, हम वर्ग सर्कल का एक ऑब्जेक्ट बनाते हैं, ऑब्जेक्ट का नाम c 1 है और यह c 1.circle काउंट को प्रिंट करेगा।
अब यहाँ एक बार ऑब्जेक्ट c 1 बन जाने के बाद यह अपने कंस्ट्रक्टर को कॉल करेगा।
अब, यहां यह डिफ़ॉल्ट कंस्ट्रक्टर है।
इसलिए, यदि आप डिफ़ॉल्ट कंस्ट्रक्टर में जाते हैं तो आप अंतिम कंस्ट्रक्टर में यहां डिफॉल्ट कंस्ट्रक्टर में देखते हैं जिसे हम देख सकते हैं।
तो, यह मूल रूप से सभी उदाहरण चर को 0 0.1 0.00 और 0 बिंदु 1 xy और r के रूप में आरंभ करेगा और सर्कल को 1 के साथ बढ़ाया जाएगा।
प्रारंभ में जब हम बनाते हैं जब हम परिभाषित करते हैं कि यह वृत्त गणना 0 हो।
तो, वैश्विक चर को 0 के रूप में आरंभीकृत किया जाता है और इसके बाद जब भी निर्माणकर्ता को इसके लिए बुलाया जाता है तो यह इसे बढ़ाएगा।
तो, अब, हम फिर से हाँ करने के लिए मुख्य विधि पर आते हैं।
इसलिए, एक बार सर्कल c 1 बनाए जाने के बाद, c 1 के पास मूल्य सर्कल की गणना है इसका मतलब यह है कि यदि हम इसमें प्रिंट करते हैं तो यह मान 1 प्रिंट करेगा।
दूसरे और अगले सी 2 पर एक वस्तु बनाते हैं।
अब यह एक और कंस्ट्रक्टर 5.0 को कॉल करेगा जो विभिन्न कंस्ट्रक्टरों की लाइन में दूसरा कंस्ट्रक्टर है।
इसलिए, सार्वजनिक सर्कल डबल आर यहां भी सर्कल काउंट ++ का मतलब है कि यह सर्कल की गिनती को 1 से बढ़ा देगा।
इसलिए, मुख्य में c 2 ऑब्जेक्ट बनने के बाद, सर्कल की गिनती 2 हो जाती है।
तो, यह 2 को प्रिंट करेगा और इसी तरह से c c यह 3 कंस्ट्रक्टर है 1 कंसर्ट मैं यह कहना चाहिए कि इसे सर्कल क्लास ऑब्जेक्ट c 3 और फिर c 3 बनाने के लिए इनवाइट किया जाएगा।
और, फिर सर्कल गणना, इस मामले में, फिर से 1 से बढ़ जाएगी और फिर यहां ठीक अधिकार होगा
सर्कल c यह 2 कन्स्ट्रक्टर है जो अभी 2 में है, अब हम इस प्रोग्राम को चलाते हैं और फिर आप आउटपुट देख पाएंगे।
इसलिए, जहां प्रत्येक सर्कल के लिए एक ऑब्जेक्ट बनाया जाता है एक बार सर्कल ऑब्जेक्ट बनाया जाने के बाद स्थिर चर को ऑब्जेक्ट के निर्माण के अनुसार संसाधित किया जाएगा और फिर यह मूल रूप से चलेगा यह इस के वर्तमान मूल्य को प्रिंट करेगा।
और यहां हम समझ सकते हैं कि सर्कल की गिनती एक वैश्विक वैरिएबल लुक है जैसे कि सभी वस्तुओं के उदाहरण इस चर के केवल 1 उदाहरण हैं।
इसलिए, यहां हम देख सकते हैं कि आउटपुट का रनिंग मूल रूप से 1 2 3 है।
अब हम फिर से कार्यक्रम पर आते हैं और आप देख सकते हैं कि हम केवल अंतिम वक्तव्य दे रहे हैं जिस पर यहाँ टिप्पणी की गई है, मैं यहाँ टिप्पणी को हटा रहा हूँ कृपया हमें इस कथन को असहज करें, इस कथन को ठीक करें।
अब, इसे अब थोड़ा कमेंट करें अगर यहाँ विंडो बड़ा है तो ठीक है हाँ अगर हम राइट देखते हैं।
इसलिए, इस c 1 सर्कल को सही बनाने के बाद और हम अब इस कथन में हैं, तो क्या आप मुझे बता सकते हैं कि इसका मूल्य क्या होगा।
तो, यहाँ पहले ऑब्जेक्ट सर्कल की गिनती 1 2 3 बनाई गई है और फिर जब आप यहां आए हैं।
तो, इस c 1 के लिए सर्कल की गणना 3 और फिर से 3 और 3 है।
तो, मूल रूप से, सर्कल गणना के नवीनतम मूल्यों तक पहुंच होगी।
इसलिए, यह मूल रूप से इंगित करता है कि आइए हम इस कार्यक्रम को संकलित करें और इसे चलाएं।
इसलिए, यहां अंतिम विवरण में, हम सर्कल गणना के मूल्य को प्रिंट करेंगे जो इस कार्यक्रम के अंत के बाद अंतिम मूल्य है।
तो, यहाँ आप इसे 3 3 3 को प्रिंट करते हुए देख सकते हैं यह आह के बाद का नवीनतम मूल्य है।
तो, इसका मूल रूप से एक उदाहरण है और फिर इसे किसी भी ऑब्जेक्ट द्वारा अपडेट किया जाता है यह किसी अन्य ऑब्जेक्ट को प्रतिबिंबित करेगा जो मूल रूप से इस मूल्य तक पहुंच है।
अब तो, यह स्थिर चर अवधारणा के बारे में विचार है कि इसी तरह वर्ग विधि और उदाहरण विधि की एक अवधारणा है हमारा अगला कार्यक्रम एक जावा कार्यक्रम में इन दो तरीकों की अवधारणा को वर्ग विधि और एक आवृत्ति विधि का वर्णन करेगा।
हमने पहले ही चर्चा की है कि इस विधि को निष्पादित करने के लिए एक विधि एक उदाहरण विधि है, जो एक वस्तु की आवश्यकता है।
तो, एक वस्तु के माध्यम से, विधि को बुलाया जाएगा।
दूसरी ओर, वर्ग विधि एक ऐसी विधि है जिसे बनाने के लिए किसी भी वस्तु की आवश्यकता नहीं होती है, विधि को ही कहा जा सकता है।
तो, यह उदाहरण मूल रूप से वर्ग विधि और उदाहरण विधि की अवधारणा को स्पष्ट करने के लिए है;
अब हम यहाँ सभी हलकों को मूल रूप से आवृत्ति विधि के रूप में देखते हैं क्योंकि, जब भी आपको कोई ऑब्जेक्ट बनाना होता है तो इन सभी निर्माणकर्ताओं को स्वचालित रूप से कॉल किया जाएगा, कहते हैं कि वे डिफ़ॉल्ट रूप से हैं कि उदाहरण विधि।
अब हम एक विधि की घोषणा करते हैं कि हम यहां वृत्त चित्र सार्वजनिक वृत्त को 2 साल में बड़ा करें।
अब, यह तरीका थोड़ा बड़ा है, हाँ हाँ, खिड़की ठीक है।
अब, पहली विधि है जिसे हम बड़ा देख सकते हैं।
तो, यह विधि सार्वजनिक वृत्त बड़ा वृत्त c है।
इसलिए, विधि मूल रूप से तर्क होगी एक वस्तु चक्र होगा आर रिटर्न सी से अधिक cr;
इसका मतलब है, कि c एक बड़ा वृत्त है और इनको लौटाता है जिसका अर्थ है कि वर्तमान वृत्त।
तो, यह एक सरल विधि है और इसे उदाहरण विधि कहा जाता है।
दूसरी तरफ एक और तरीका बड़ा है जो एक ओवरराइडिंग विधि है जिस पर हमने चर्चा की है, लेकिन यह तरीका पिछली पद्धति से दो चीजों से अलग है;
एक को स्थैतिक कीवर्ड कहा जाता है, दूसरे को स्टेटिक कहा जाता है;
यह इंगित करता है कि यह विधि मूल रूप से वर्ग विधि है और यह तर्क की दृष्टि से भी भिन्न है।
पहले केवल एक तर्क जबकि, यह दो तर्क हैं सभी तर्क प्रकार सर्कल ऑब्जेक्ट्स के प्रकार हैं।
कोड इस तरह से होता है जैसे कि br रिटर्न से बड़ा होता है a फिर एक बड़ा वृत्त होता है और रिटर्न b होता है।
तो, यह मूल रूप से वापस आ जाएगा जो कि एक वापसी प्रकार है इस मामले में यहां एक चक्र है।
अब, हम मुख्य विधि देखते हैं, यहाँ हम एक ऑब्जेक्ट 2 ऑब्जेक्ट, 3 ऑब्जेक्ट, 4 ऑब्जेक्ट बनाते हैं।
वैसे भी, 1 दो ऑब्जेक्ट्स टाइप हैं क्लास सर्कल एब और फिर यहाँ हम बी a.bigger देख सकते हैं।
तो, मूल रूप से, एक बड़ी विधि वस्तु के संदर्भ में आह्वान की जाती है।
तो, यह एक उदाहरण विधि है, दूसरी ओर, दूसरी कॉल।
तो, बड़ी विधि को एक वस्तु के संदर्भ में कहा जाता है यह सर्कल के संदर्भ में एक सर्कल है।
इसका मतलब है, किसी भी वस्तु को बनाने के बिना इस विधि को कहा जाता है।
तो, यह क्लास पद्धति को लागू करने का एक उदाहरण है।
तो, यहाँ दो इनवॉइस उदाहरण हैं
विधि और वर्ग विधि और यह इंगित करता है कि वर्ग विधि का तरीका इस तरह की आवृत्ति विधि की तुलना में अलग तरह से काम करता है।
तो, इसलिए यह एक उदाहरण विधि और वर्ग विधि का एक उदाहरण है।
तो, ये मुख्य अवधारणा हैं जो जावा में हैं इसलिए, अब तक स्थिर गुंजाइश नियम का संबंध है।
अब, हम पहले से ही चर्चा की गई पुनरावर्ती कार्यक्रम के निष्पादन को देने के लिए अपने प्रदर्शन पर स्विच करते हैं, जबकि हम सिद्धांत पर चर्चा कर रहे हैं कि जावा में पुनरावर्ती पुनरावर्ती कार्यक्रम लेखन।
तो, चलिए सबसे पहले पुनरावर्ती गणना पुनरावर्ती मार्ग को चलाते हैं, जो कि फैक्टोरियल की गणना करता है।
इसलिए, यह कार्यक्रम अच्छी तरह से समझा जाता है मेरा मानना ​​है।
तो, यहाँ फैक्टरियल एक विधि है जो वर्ग पुनरावर्ती तथ्य में परिभाषित की जाती है और फिर पुनरावृत्ति मूल रूप से फैक्टरियल गणना की पुनरावर्ती परिभाषा का अनुसरण करती है जो कोड इस तरह है।
समाप्ति की शर्तों के साथ बहुत सरल n factorial = n star factor n minus 1 जो कि 0 factorial = 1 है।
तो, यह एन के इस भाज्य परिभाषा का कार्यान्वयन है;
अब मुख्य विधि में हम यहां क्लास रिकर्सिव फैक्टरियल के प्रकार का एक ऑब्जेक्ट बनाते हैं और फिर कीबोर्ड से इनपुट के रूप में इस विषय पर वैल्यू पास करते हैं और फिर हम इसे x.factorial x.n कहते हैं;
इसका मतलब है, तब हम वर्ग पुनरावर्ती तथ्य के इन विषयों में विधि को कहते हैं और इसे चलाते हैं।
अब हम इस प्रोग्राम को जल्दी से चलाते हैं आप समझ सकते हैं कि यह कैसे रिकर्सिव फाइन चलाएगा।
अब, क्योंकि यह एक इनपुट है, क्योंकि r 0 है।
तो, हमें इनपुट को 5 सही कहना चाहिए अगर हम इस प्रोग्राम को फिर से चलाते हैं तो कुछ बड़े मूल्य के साथ कहते हैं 10 यह आपके लिए भी निष्पादित करेगा।
तो, यह इस तरह है, लेकिन यह उदाहरण के लिए एक बहुत बड़ी संख्या नहीं कह सकता है यदि हम कहते हैं कि 100 आप देखेंगे कि क्या आपका कार्यक्रम अब है।
तो, 100 का एक कारक यदि 0 यह दे रहा है क्योंकि यह इस एक के पाउंड से बाहर है।
तो, उस स्थिति में, एक पूर्णांक की अपनी सीमा होती है।
इसलिए, यदि हम यह घोषित करते हैं कि इंट के बजाय लंबे पूर्णांक यह कुछ बड़े मूल्यों को ले सकता है वैसे भी इसे बदलकर हम इसे बदल सकते हैं, लेकिन हमें इसके लिए बदलना होगा कि यह बाद में आपके लिए प्रयोग किया जाता है।
अब, हम फाइबोनैचि अनुक्रम को प्रिंट करने के लिए एक और पुनरावर्ती कार्यक्रम में आते हैं।
इसलिए, यह वह कार्यक्रम है जो हम पहले ही उस कार्यक्रम से परिचित हैं, जिसकी चर्चा हमने अपने पिछले मॉड्यूल और
तो, यहाँ फिर से, एक nth factorial की पुनरावर्ती परिभाषा मूल रूप से n minus 1 factorial plus n शून्य 2 factorial है और फिर समाप्ति की स्थिति यह है कि 0th factorial = 0 और फिर 1 factorial 1 है।
तो, ये 2 समाप्ति की स्थिति है जिसके बाद पुनरावर्ती परिभाषा होती है यह उसी प्रकार का होता है जिस तरह से हम जिस प्रकार की पुनरावर्ती वस्तु का निर्माण करते हैं उसी प्रकार का लेखन।
यहाँ फाइबोनैचि वह वर्ग है जहाँ हमने पुनरावर्ती विधि को परिभाषित किया है फ़िबोनाकी और हम इसे कहते हैं और लूप के लिए यह मूल रूप से उत्तराधिकार में सभी फिबोनाकी संख्या में प्रिंट होता है जब तक कि xn यह उपयोगकर्ता अलग संख्या है जिस तक आप जिस फिबोनाकी संख्या को प्रिंट करना चाहते हैं ।
अब, मान लीजिए कि आप दसवें फाइबोनैचि संख्या तक प्रिंट करना चाहते हैं।
तो, हम इस प्रोग्राम को पासिंग इनपुट के साथ चला सकते हैं;
यहां इनपुट को कीबोर्ड के माध्यम से पारित करने की आवश्यकता है, इसे 10 होने दें और आप समझ सकते हैं कि यह 10 फाइबोनैचि संख्याओं को फिबोनाची श्रृंखला 10 ठीक में कैसे प्रिंट करेगा।
तो, यह कुछ फाइबोनैचि श्रृंखला में पहले 10 फाइबोनैचि संख्याओं को प्रिंट करता है।
इसलिए, यह मूल रूप से पुनरावर्ती अब हमें GCD गणना में आने देता है जिसे हमने अपने सैद्धांतिक वर्ग में चर्चा की है।
तो, इस जीसीडी गणना में मूल रूप से इस तरह की पुनरावृत्ति नियम है यह एक जैसा है और हमने इसे लागू किया है कुछ और समाप्ति की स्थिति है।
अब, आप पुनरावर्ती तथ्य के मामले में देख सकते हैं कि फिबोनाची के मामले में केवल एक समाप्ति दो समाप्ति की स्थिति है।
जबकि जीसीडी के मामले में वहाँ समाप्ति की स्थिति की एक जोड़ी है और पुनरावर्ती कॉल के बाद सभी समाप्ति की स्थिति है, तो इस मामले में, पुनरावर्ती कॉल gcd mn mod m।
तो, यह इस एक की पुनरावर्ती परिभाषा के अनुसार है।
अब यहां दो पूर्णांक मानों को पारित किया जाना है और फिर जावा प्रोग्राम इस पुनरावर्ती फ़ंक्शन के लिए कॉल करेगा, जिसे यहाँ एक एलसीडी के रूप में परिभाषित किया गया है और हम इसे दो मूल्य के साथ एलसीडी को कॉल करते हैं और यह कॉल करेगा।
तो, जी इस प्रकार की एक वस्तु है जिसे इस वर्ग द्वारा बनाया गया है और इस फ़ंक्शन को कॉल करें और फिर यह हमें इस प्रोग्राम को चलाने देगा ताकि आप इसके निष्पादन के बारे में ठीक से समझ सकें।
पहले हमें 31 और फिर 13 में प्रवेश करते हुए देखें।
तो, यह 2 इनपुट है आपको इसे 2 इनपुट 31 और 13 13 देना होगा।
उदाहरण के लिए, यदि हम इस कार्यक्रम को गैर-अभिन्न मान बताते हुए चलाते हैं, तो यह रन टाइम में स्वीकार्य नहीं है, लेकिन जावा रन टाइम इनविटेशन में एरर देते हुए कहते हैं।
तो, यह मूल रूप से आपको हमेशा अभिन्न मूल्य देना होगा।
अब तो, हमने गुटीय गणना के बारे में जान लिया है;
इसलिए, फैक्टोरियल कैलकुलेशन, फाइबोनैचि सीरीज़ कैलकुलेशन, जीसीडी गणना इस तरह की जाती है।
तो, सबसे महत्वपूर्ण बात यह है कि आपको यह समझना चाहिए कि कैसे आप पुनरावर्ती परिभाषा का पालन करके एक कार्यक्रम कास्ट कर सकते हैं।
यदि हर प्रोग्राम में इसका लूप होता है, तो इस प्रोग्राम में वास्तव में रिकर्सन का प्रतिरूप होता है।
इसलिए, अगर किसी प्रोग्राम को कुछ लूपिंग कंस्ट्रक्शन के माध्यम से हल करने की आवश्यकता होती है, तो उसी प्रोग्राम को लूप रीर्सिव वर्जन के माध्यम से भी हल किया जा सकता है।
अब हम इस सरल उदाहरण का एक त्वरित रूप देखते हैं जिसे आप समझ सकते हैं कि यह वह कार्यक्रम है जिसे हमने पुनरावर्ती घोषित किया है।
इसलिए, यह मूल रूप से यहाँ है मेरी विधि एक पुनरावर्ती विधि है जिसे 517 के तहत कक्षा के प्रदर्शन में घोषित किया गया है और इस पद्धति की समाप्ति है और एक महत्वपूर्ण बात यह है कि प्रत्येक पुनरावर्ती कार्य को समाप्ति कथन होना चाहिए।
समाप्ति के बिना, पुनरावृत्ति अनंत निष्पादन पर जाएगी कभी नहीं समाप्त यह वांछनीय नहीं है।
इसलिए, प्रत्येक पुनरावर्ती कार्यक्रम इस मामले में होना चाहिए, हम देख सकते हैं कि काउंटर पुनरावर्ती 0 है।
तो, काउंटर के साथ = 0 नहीं है, इसलिए काउंटर के साथ नहीं = 0 यह गिनती पर जाएगा और इस मामले में मेरी विधि जब भी पहली बार कॉल करेगी तो यह गणना के मूल्य को प्रिंट करेगा और फिर मेरे विधि कॉल को फिर से बुलाया जाएगा गिनती के मूल्य को कम करना।
इसलिए, यदि हम कहते हैं कि काउंटर वैल्यू यह बाद में इतने पर कम काउंटर कॉल करेगा।
और फिर सभी 10 काउंटरों को प्रिंट करें और जब पुनरावृत्ति खत्म हो जाएगी तो पिछले काउंटर मूल्य पर आ जाएगी।
तो, अब, यदि आप देखते हैं कि जब भी पुनरावर्ती कॉल से पहले यह पिन होगा और फिर पुनरावृत्ति पर, यह कुछ मूल्यों को पिन करेगा और मुद्रण पर जाएगा।
और फिर हमें देखने दें:
इस कॉल का आउटपुट क्या है।
इसलिए, यदि हम इस पुनरावर्तन को 10 मान के साथ काउंटर के रूप में कहते हैं कि यह कैसे करेगा;
मैं समझा सकता हूं कि यह आउटपुट क्यों है जहां आप यह भी बता सकते हैं कि यह आउटपुट इस प्रोग्राम के लिए कैसे हुआ।
आप यहां देख सकते हैं कि दो प्रिंट स्टेटमेंट की वजह से स्टेटमेंट की दो सीरीज़ हैं और फिर रिकर्सन इस एक को प्रिंट करने के लिए चल रहा है और फिर रिकर्सिव कॉल।
तो, बयान की दो श्रृंखलाएं हैं और पुनरावृत्ति वास्तव में एक स्टैक का उपयोग करने के लिए पुनरावृत्ति प्रदर्शनी है जो मूल रूप से पुनरावृत्ति को समाप्त करने से पहले इसे पुनरावृत्ति के कॉल पर जाती है।
तो, इसलिए यह वहाँ है।
तो, यह एक उदाहरण है अब हमें अपने स्वयं के अभ्यास के लिए एक और उदाहरण का त्वरित रूप दें।
तो, फिर से आप इसे पिछले उदाहरण के एक ही पंक्ति में इन श्रृंखलाओं से सीख सकते हैं;
आप अनुमान लगा सकते हैं कि इसे फिर से p को क्या इनपुट देना चाहिए, वह विधि है जिसे यहाँ पुनरावर्ती रूप से परिभाषित किया गया है।
अब इस प्रोग्राम को p के मान से निष्पादित करने के बाद इस पर इसे चलाते हैं क्योंकि 5 यहाँ हमें 5 मान देने की आवश्यकता नहीं है यह इसे प्रिंट करेगा।
वैसे भी, गुंजाइश के बारे में, नियंत्रण संरचनाओं और फिर पुनरावर्ती कार्यक्रम लेखन अभ्यास का विषय है।
इसलिए, मैं आपको सलाह देता हूं कि आप अधिक से अधिक कार्यक्रमों का अभ्यास करें
यह लाइन इतनी है, कि आप इसे सीख सकते हैं।
अपने स्वयं के अभ्यास के लिए, यदि आपको उन सभी पाठ्यक्रमों की आवश्यकता है, जो हमने यहां दिए गए हैं, तो आप हमें एक अनुरोध भेज सकते हैं।
इसलिए, हम इसे आपके पास भेज सकते हैं, आपको बहुत-बहुत धन्यवाद और जावा प्रोग्रामिंग के लिए अधिक मजा कर सकते हैं।
धन्यवाद।
कंप्यूटर विज्ञान और इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर व्याख्यान में जावा प्रो। देबासीस सामंता विभाग में प्रोग्रामिंग - 54 प्रदर्शन - XXI तीन चीजें हैं जहां अब तक जेडीबीसी का संबंध है;
एक डेटाबेस प्रबंधन प्रणाली है जो मूल रूप से इस सीखने में हमने MySQL पर विचार किया है और फिर दूसरा है कि JDBC ड्राइवर जो मूल रूप से आप सर्वर से कनेक्ट करेंगे और फिर तीसरा घटक मूल रूप से जावा अनुप्रयोग है।
तो, JDBC वह मध्य है जो मूल रूप से आपके प्रोग्राम को कनेक्ट करेगा अर्थात सर्वर पर जावा एप्लिकेशन।
अब इस सत्र में, हम JDBC ड्राइवर के बारे में विवरण के बारे में जानने की कोशिश करेंगे।
तो, पहले, हमें इस MySQL सर्वर के लिए बिल्कुल देखना चाहिए, उचित JDBC ड्राइवर को स्थापित करने की आवश्यकता है।
तो, हम इस बारे में चर्चा करेंगे कि कैसे JDBC ड्राइवर हमारे जावा एप्लिकेशन को MySQL सर्वर से जोड़ने के लिए जिम्मेदार होगा।
इसलिए, JDBC ड्राइवर डाउनलोड करना और फिर एक बार JDBC ड्राइवर डाउनलोड करने के बाद सफलतापूर्वक इंस्टॉल हो जाना;
जाहिर है, स्थापना हम देखेंगे कि यह कैसे स्थापित किया जा सकता है।
और फिर अंत में, JDBC ड्राइवर और फिर जावा प्रोग्राम के माध्यम से हम कुछ स्टेटमेंट, SQL स्टेटमेंट को कैसे निष्पादित कर सकते हैं;
और हम अपने जावा एप्लिकेशन जावा से SQL स्टेटमेंट निष्पादित करेंगे
कार्यक्रम, और फिर हम कंसोल से उनके परिणाम फिर से देखेंगे;
इसका मतलब है, फिर से जोड़ने के माध्यम से उन्हें निष्पादित करने के बाद MySQL सर्वर है।
यह मूल रूप से इस बारे में एक विचार देता है कि हम जिस भी टिप्पणी को लागू करने का इरादा रखते हैं, वह आवेदन को निष्पादित करता है चाहे वह सफलतापूर्वक निष्पादित हो या नहीं।
बाद में आयोजित होने वाले हमारे अगले सत्र में हम ठीक उसी तरह देखेंगे कि कैसे परिणाम भी प्राप्त किए जा सकते हैं जो कि शुद्ध रूप से आवेदन से ही प्राप्त हो सकते हैं।
अब हम इस बारे में शुरुआत करते हैं कि JDBC ड्राइवर को कैसे स्थापित किया जा सकता है।
JDBC ड्राइवर का स्थान हमने दिया है हमने लिंक दिया है।
तो, यह मूल रूप से वह लिंक है जहां से आप MySQL कनेक्टर के लिए JDBC ड्राइवर प्राप्त कर सकते हैं।
आप बस लिंक पर जाएं और अंत में, आप वहां उचित प्रोग्राम सेट कर पाएंगे |
यह बस डाउनलोड करना शुरू कर देता है।
तो, आप मूल रूप से अब डाउनलोड करें।
तो, यह फ़ाइल आपको केवल सादगी के लिए MySQL में बदलनी चाहिए, आप कोई भी नाम दे सकते हैं, लेकिन सुविधा के लिए आप इसे एक दे सकते हैं और फिर अंत में, आपको जार फ़ाइल MySQL.jar फ़ाइल को किसी अन्य प्रोग्राम के साथ रखना चाहिए जिसमें शामिल है यह JDBC का उपयोग करके, जो कमांड प्रॉम्प्ट जावा माइनस cp MySQL.jar से एक कमांड द्वारा किया जाना चाहिए और फिर सभी फ़ाइल नाम ठीक है।
तो, आप बस इस जार फ़ाइल को इस एक अधिकार में कॉपी करें।
इसलिए, हमने इसे कॉपी किया है।
इसलिए, हमने इस MySQL जार फ़ाइल को कॉपी कर लिया है और इसे और फिर हमें आखिरकार सिस्टम फ़ाइल से classpath नाम सेट करना होगा ताकि इस JDBC ड्राइवर को किसी भी स्थान से पहचाना जा सके।
यदि आप इसे निष्पादित करते हैं, तो, आपको कक्षापथ को भी वहां सेट करना होगा।
वैसे भी, हमारा जेडीबीसी कनेक्शन यही है, इससे आपको जेडीबीसी कनेक्शन के बारे में पूरी प्रतिस्पर्धा मिलती है।
अब, हम कुछ जावा प्रोग्राम लिखना चाहते हैं, जिसके द्वारा आप कुछ SQL स्टेटमेंट्स को निष्पादित कर सकते हैं और फिर स्टेटमेंट के निष्पादन के बाद, हम परिणाम देख पाएंगे।
अब देखिए कुछ कदम हैं;
जाहिर है, शामिल।
पहली बात यह है कि आपको कुछ वस्तुओं का निर्माण करना होगा;
पहला यह है कि कनेक्शन ऑब्जेक्ट हम कॉन के रूप में नाम देते हैं।
हम कनेक्शन ऑब्जेक्ट को परिभाषित करते हैं और फिर हम ठीक परिभाषित करते हैं।
तो, यह मूल रूप से कनेक्शन स्थापित कर रहा है और फिर उपयोगकर्ता नाम रूट है, हमें लिखना है उपयोगकर्ता नाम रूट पासवर्ड रूट है, URL मूल रूप से आप इसे नोट कर सकते हैं JDBC MySQL यह मूल रूप से स्थानीयहोस्ट है और यह वह संख्या है जो वहां है, एक है पोर्ट नंबर 3306 और JDBC है, ड्राइवरों को एक विशेष डेटाबेस से कनेक्ट होना चाहिए।
तो, अंतिम फ़ील्ड मूल रूप से डेटाबेस का नाम है।
और फिर हमें JDBC ड्राइवर को लोड करना है, मूल रूप से "Class.forName.com.MySQL.cj.jdbc.Driver" कथन का उपयोग करके ।newInstance यह तरीका है और इसलिए, यह मूल रूप से JDBC ड्राइवर को आपके लोड करने के लिए है। आवेदन वास्तव में ठीक है।
तो, यह सही है और फिर हमें उस कनेक्शन को स्थापित करना होगा जो ऑब्जेक्ट के संग्रह का एक उदाहरण है, जिसके लिए DriverManager वहां वर्ग है।
तो, DriverManager.getConnection और URL दे रहा है।
जो भी URL आपने वहाँ दिया है, आप यहाँ तर्क दें URL, userName, पासवर्ड;
अन्यथा आप इस विधि में भी कर सकते हैं आप दोहरे उद्धरण के भीतर टाइप कर सकते हैं सभी तर्क यह भी काम करेगा, लेकिन सुविधा के लिए, हम इसे संग्रहीत करते हैं और फिर इसे विधि तर्क के रूप में पास करते हैं।
तो, यह मूल रूप से कनेक्शन ऑब्जेक्ट बनाता है और फिर यदि कनेक्शन प्रोग्राम से सफल होता है, तो हम प्राप्त करेंगे कि कोई कनेक्शन सफल नहीं है तो यह एक त्रुटि देगा।
अब देखते हैं कि त्रुटि है या नहीं।
इसलिए, त्रुटि से निपटने के लिए, हमने पहले ही सब कुछ को पकड़ने-पकड़ने वाले ब्लॉक के तहत संलग्न किया है।
तो, ये प्रथागत प्रयास-पकड़ने वाला ब्लॉक है जिसे हमने अभी ठीक किया है।
तो, इस प्रोग्राम को चलाएं जावा माइनस सीटी हां।
तो, अब हम पहले से ही इसे यहाँ लोड कर रहे हैं जावा माइनस सीपीपी MySQL.jar कनेक्ट।
अब कनेक्शन है।
अब हम इस कार्यक्रम को संकलित कर सकते हैं।
इसलिए, कार्यक्रम सफलतापूर्वक संकलित किया जाता है और निष्पादन होने के बाद निष्पादित किया जाता है।
यदि हम देखते हैं कि डेटाबेस कनेक्शन स्थापित डेटाबेस कनेक्शन अब समाप्त हो गया है।
अब, अगर मुझे लगता है कि या तो कुछ नाम कहने के लिए कोई गलती है या कुछ कहते हैं कि रूट पासवर्ड बदल गया है;
इसलिए, अतिथि अतिथि, मान लीजिए कि यह एक गलत पासवर्ड है तो अगर हम फिर से इसे जोड़ने की कोशिश करते हैं, तो जावा माइनस सीपीपी MySQL.jar कनेक्ट करें क्योंकि आप इसे मूल रूप से देखते हैं।
संकलन किया जाता है और फिर इस कार्यक्रम को चलाया जाता है, जैसा कि आप देखते हैं कि यह इस कारण से डेटाबेस सर्वर से कनेक्ट नहीं हो सकता है।
इसलिए, पासवर्ड रूट हाँ का उपयोग कर उपयोगकर्ता रूट लोकलहोस्ट के लिए एक अपवाद को अस्वीकार कर दिया जाता है।
तो, यह मूल रूप से कनेक्शन प्राप्त करने से इनकार करता है।
तो, रूट वह पासवर्ड है जो इस समय सही या सफल कनेक्शन के लिए आवश्यक है।
तो, इस तरह से आप देख सकते हैं कि कैसे JDBC के साथ JDBC के साथ कनेक्शन किया जा सकता है।
अब हम इस बारे में चर्चा करेंगे कि सरल कथन को कैसे निष्पादित किया जा सकता है।
यहां हम जिस सरल कथन को निष्पादित करने जा रहे हैं, वह है, टेबल जावा कोर्स बनाना क्योंकि इस समय कोई तालिका नहीं है।
इसलिए, जैसा कि कोई तालिका नहीं है हम किसी भी इन्सर्ट, डिलीट, अपडेट कमांड को पूरा करने में सक्षम नहीं होंगे।
तो, पहले, हमें तालिका बनानी होगी।
अब, यह एक कार्यक्रम है जैसा कि हम देखते हैं।
यह कार्यक्रम मूल रूप से बताता है कि हम एक टेबल कैसे बना सकते हैं।
अब यहाँ आप यह देखते हैं कि कनेक्शन ऑब्जेक्ट बनाया गया है और फिर स्टेटमेंट ऑब्जेक्ट क्लास स्टेटमेंट से बना है, इसे मूल रूप से सेट करें, यह परिणाम सेट लौटा देगा;
इस मामले में, हम सभी पर विचार नहीं करेंगे, लेकिन यह परिणाम दे सकता है।
और यहाँ मूल रूप से उपयोगकर्ता नाम है;
रूट और फिर पासवर्ड भी रूट जो हमने संचित किया है और फिर URL यहाँ JDBC है;
JDBC MySQL लोकलहोस्ट यह मूल रूप से इस मामले में हमारे MySQL सर्वर का URL है।
फिर हम इस कमांड Class.forName.com MySQL.cj.jdbc.Driver को .newInstance का उपयोग करके कनेक्शन स्थापित करते हैं।
यह मूल रूप से वाक्यविन्यास है जिसके लिए कनेक्शन बनाया जा सकता है।
जब कनेक्शन सफल होता है, तो हमें DriverManager getConnection के माध्यम से कनेक्शन ऑब्जेक्ट बनाना होता है ताकि तर्क दिया जा सके;
URL, userName और पासवर्ड जो मूल रूप से यहां असाइन किए गए हैं।
और फिर, यह मूल रूप से कनेक्शन को पूरा करता है और यहां मूल रूप से हम एक स्टेटमेंट ऑब्जेक्ट बना रहे हैं।
तो, con.createStatement ऑब्जेक्ट के लिए स्टेटमेंट बनाया जाता है और फिर इस स्टेटमेंट ऑब्जेक्ट को एक स्टेटमेंट क्रिएट टेबल बनाया जाता है;
जावाकोर्स रोल इंटेगर प्राथमिक कुंजी, नाम वर्चर 30, मार्क्स इंटेगर शून्य नहीं, ग्रेड वरचर 2।
तो, यह मूल रूप से यह सामान्य तरीका है, कि चार क्षेत्रों जैसे रोल नंबर नाम के निशान और ग्रेड जैसे एक तालिका बनाई जा सकती है।
और इसलिए, अब, यह मूल रूप से फायरिंग को पूरा करता है और फिर यदि कोई त्रुटि है या जो कुछ भी है तो यह स्पष्ट रूप से, ट्राइ-कैच ब्लॉक द्वारा पकड़ होगा।
तो, यह मूल रूप से प्रोग्राम है जो मूल रूप से JDBC ड्राइवर के माध्यम से सर्वर से कनेक्ट होने वाली कनेक्शन ऑब्जेक्ट बनाता है और अंत में, एक नया टेबल बनाने के लिए एक स्टेटमेंट निष्पादित करता है और कमांड यह है कि जावा माइनस cp MySQL.jar और फिर एक टेबल बनाएं। हमारे द्वारा बनाए गए वर्ग का नाम।
तो, यह मूल रूप से प्रोग्राम है और फिर सर्वर में, हम सर्वर पर कंसोल पर आ रहे हैं और यहां टेबल-टेस्ट टेस्ट शो टेबल दिखा रहे हैं।
इसलिए, हम देखते हैं कि परीक्षण डेटाबेस के तहत नया टेबल जावा पाठ्यक्रम बनाया गया है।
तो, यह पहला चरण है या यहां तालिका बना रहा है।
अब इस तालिका से कुछ अन्य कथनों को निष्पादित करते हैं।
पहला यह है कि हमें तालिका में कुछ अभिलेख सम्मिलित करने होंगे।
तो, हम ठीक उसी तालिका को देखेंगे जो आपने अभी हमारे जावा एप्लिकेशन से बनाई है कि कैसे कुछ डेटा डालने के लिए उसी का उपयोग किया जा सकता है, हम जितने चाहें उतने रिकॉर्ड बनाएंगे।
यहां हम एक एसक्यूएल स्टेटमेंट के साथ चार रिकॉर्ड डालने पर विचार करेंगे।
अब, यह एक कार्यक्रम है जैसा कि आप देखते हैं कि यह एक कार्यक्रम है।
आप यहाँ देखिये सबसे पहले ये हैं
तो, यह कनैक्शन कनैक्शन ऑब्जेक्ट है, STMT स्टेटमेंट ऑब्जेक्ट है और फिर मूल रूप से यूजरनेम और पासवर्ड और URL है, ये तीन पैरामीटर हैं जो DriverManager को इंस्टॉल करने के लिए आवश्यक हैं।
इसलिए, हम इन ऑब्जेक्ट का उपयोग करते हैं और फिर आखिरकार DriverManager के माध्यम से इसे कनेक्ट करते हैं।
तो, कॉन ऑब्जेक्ट अब तैयार है;
इसका मतलब है, इसका कनेक्शन स्थापित है और फिर हम केवल एक स्टेटमेंट ऑब्जेक्ट बनाते हैं और फिर स्टेटमेंट मूल रूप से एक के बाद एक चार इंसर्स्क रिकॉर्ड के साथ निष्पादन के लिए बनाया जाता है।
यहाँ आप देखते हैं कि यह पहला इंसर्टन है, फिर सेमीकोलन, फिर दूसरा स्टेटमेंट। दूसरा इंसर्ट और दूसरा स्टेटमेंट। तीसरा इंस्यूट्यूट करें और फिर इस चौथे एग्जीक्यूट स्टेटमेंट के लिए चौथी इंसर्ट करें।
तो, इस तरह हमने चार को एक स्टेटमेंट जारी किया है और फिर हम इस स्टेटमेंट ऑब्जेक्ट के लिए एग्जीक्यूटिव मेथड को कहते हैं।
यह मूल रूप से अनुरोध JDBC के माध्यम से सर्वर तक जाएगा, और सर्वर इसे निष्पादित करेगा और फिर अंत में, हम देखेंगे कि क्या सर्वर ने अनुरोध के अनुसार चीजों को सही ढंग से किया है या नहीं।
तो, यहां फिर से, हम कार्यक्रम चला रहे हैं, यह क्लासिक सम्मिलित रिकॉर्ड का नाम है।
तो, ठीक है |
तो, आम है जावा माइनस cp MySQL.jar कि आपको इसे कोलन देना है फिर आपको InsertRecord देना होगा।
यदि आप संवाद करना चाहते हैं, तो यह सिंटैक्स है।
इसलिए, कोई त्रुटि संदेश नहीं है जिसका अर्थ है कि इसे निष्पादित किया गया है।
तो, चलिए फिर से यहाँ टेबल पर वापस आते हैं।
तो, हम जावा कोर्स से चुनिंदा स्टार देख सकते हैं, यह पहले से ही है।
यहाँ भी अगर हम लिखते हैं कि desc table java course भी इसे हमेशा की तरह ही देगा क्योंकि तालिका को सफलतापूर्वक उस संरचना के साथ बनाया गया है जिसे हमने वहाँ दिया है।
फिर से हम यहाँ कोड को देखेंगे।
यह कोड हमेशा की तरह है, यह कनेक्शन, स्टेटमेंट ऑब्जेक्ट्स हैं और ये यूजरनेम, पासवर्ड हैं और फिर यह यूआरएल है और हम यूजरनेम, पासवर्ड और फिर यूआरएल को पास करते हुए Class.forName बनाते हैं।
और फिर अंत में, हम कॉन ऑब्जेक्ट बनाते हैं;
इसका मतलब है, URL, userName और पासवर्ड के साथ DriverManager.getConnection पद्धति को कॉल करने में कनेक्शन ऑब्जेक्ट और फिर यह वह कथन है जो अब आग लगाने के लिए तैयार है।
अब यहाँ आप जिस स्टेटमेंट को देखते हैं, हम उसे कमांड, SQL कमांड का इस्तेमाल करते हैं।
नाम इस के बराबर है जहां नाम इस एक के बराबर है।
तो, यहां बुनियादी है और आप पहली तालिका में देखते हैं कि हमने चर्चा की है एक प्रविष्टि मूल रूप से पहली प्रविष्टि है जिसके लिए नाम देबाशीष डीबासिस एच है।
तो, यह मूल रूप से इस आदेश को इस प्रविष्टि को adebasi s के रूप में बदलने का अनुरोध किया जाता है।
तो, अब, हम यह प्रोग्राम है जो अब तैयार है और फिर इस प्रोग्राम को संकलित करते हैं और फिर ठीक करते हैं।
तो, यह कार्यक्रम हाँ।
तो, अद्यतन रिकॉर्ड यह फ़ाइल हां का नाम है।
अब रिकॉर्ड अपडेट कर दिया गया है और कमांड प्रॉम्प्ट पर वापस आते हैं।
तो, कमांड प्रॉम्प्ट फिर से बस ठीक से देखें स्टार से आप देख सकते हैं कि अपडेशन सफल है।
तो, इस तरह से कमांड रिलेटिव अपडेट को जावा एप्लिकेशन से निकाल दिया जा सकता है और फिर हम कमांड को बिल्कुल डिलीट कर देंगे, हम टेबल से एक रिकॉर्ड को डिलीट करने जा रहे हैं, यहाँ और यहाँ जावा कोर्स है।
इसलिए, यह मूल रूप से यह कार्यक्रम है जैसा कि हम देखते हैं।
इसलिए, यह सामान्य चीजें हैं जो हम वहां हैं, हम पहले से ही इस बात से परिचित हैं, पिछले उदाहरणों में और यह भी स्पष्ट है कि मैंने अभी-अभी यहां बदलाव किया है।
इसलिए, हमने अभी JavaCourse से डिलीट बनाया है जहाँ निशान 66 से कम हैं।
तो, रिकॉर्ड में, कुछ निशान हैं अगर यह 66 से कम है, तो 65 को हटा दिया जाएगा।
तो अब, हमें करते हैं।
इसलिए, यह केवल एक बयान है जिसे हम करने जा रहे हैं।
इसलिए, रिकॉर्ड हटाएं।
तो, यह अब वहाँ है जैसा कि आप वहाँ देखते हैं।
अब मैं यहाँ केवल एक छोटा सा परिवर्तन करने जा रहा हूँ।
तो, जैसा कि आप पहले ही देख चुके हैं।
इसलिए, एक से अधिक SQL स्टेटमेंट निष्पादित किए जा सकते हैं।
तो, वास्तव में यह मूल रूप से एक कथन है। यह विधि है।
इसलिए, मैं सिर्फ आपको बदल रहा हूं बस एक और स्टेटमेंट जोड़ें। इसे डिलीट करने के बजाय डिलीट करें यहां डिलीट करें, फिर राईट देखें रोल नंबर 7 अमित मार्क्स यहां नहीं हैं, बस अगले स्टेटमेंट को कॉपी करें। फिर से राइट करें।
इसलिए, इन्हें हटा दिया जाता है जिसे हम निष्पादित करने जा रहे हैं।
तो, सही डालें।
सही जावा कोर्स में डालें फिर 0 नाम रोल वैल्यू हाँ।
तो, ठीक है, तो, अमित।
तो, मूल्यों को जावा कोर्स के मूल्यों में सम्मिलित किया जाना चाहिए, मानों मान 12 अमित, 85, यह एक सही है।
अब हम एक और रिकॉर्ड सम्मिलित कर रहे हैं, मैं अभी यहाँ जा रहा हूँ।
इसलिए, हमें इस कार्यक्रम को सहेजना होगा जिसे हमने बदल दिया है।
अब यह दो चीजों पर अमल करेगा;
डिलीट के साथ ही इंसर्ट भी करें।
तो, हाँ कहीं नहीं आप सही देख सकते हैं।
तो, जैसा कि आप देख रहे हैं कि नई प्रविष्टि यहाँ बनाई गई है।
इसलिए, एसक्यूएल स्टेटमेंट को एक प्रोग्राम से निष्पादित किया जा सकता है, जैसा कि आपने देखा है कि आपने इसे दो पर परीक्षण किया है;
इसलिए, यह आवश्यक नहीं है कि दो से अधिक दो कथन भी एक ही कार्यक्रम से निष्पादित किए जा सकते हैं।
इसलिए, आपकी आवश्यकता के आधार पर जो भी SQL कथन हैं, कि हम इसे सम्मिलित करने में सक्षम होंगे।
नहीं, ड्रॉप टेबल वैसे भी हट जाएगी।
तो, अब, एक और डिलीट कमांड है;
डिलीट करें यदि आप डेटाबेस का नाम सही देते हैं।
तो, JavaCourse से हटाएं।
तो, अंत में, हम पूरी तालिका को भी हटा सकते हैं तालिका और फिर।
तो, यह इस कार्यक्रम का कार्यक्रम है।
इसलिए, एक स्टेटमेंट को निष्पादित किया जा सकता है और फिर यदि हम टेबल दिखाते हैं तो ड्रॉप टेबल प्रोग्राम को सफलतापूर्वक निष्पादित किया जाता है।
तो, ड्रॉप टेबल वास्तव में पूरी तालिका को स्थायी रूप से हटा देगा और आप देख सकते हैं कि यहां कोई तालिका नहीं है।
इसलिए, यदि आप देखते हैं, तो चयन और शो टेबल भी, इसलिए, इस तरह से इसमें कोई टेबल नहीं है।
अब तो, हमने यहां जो सीखा है वह यह है कि हम कनेक्शन कैसे स्थापित कर सकते हैं और फिर कनेक्शन सफल होने के बाद हम जावा एप्लिकेशन से SQL स्टेटमेंट निष्पादित कर पाएंगे।
इसलिए, इस प्रदर्शन में हालांकि हमें लोकलहोस्ट का उपयोग करना है, लेकिन जैसा कि आप जानते हैं कि URL विनिर्देश जो हमने अपने नेटवर्किंग चर्चा के दौरान चर्चा की है, प्रोटोकॉल और फिर संसाधन नाम और पोर्ट नाम सहित सभी चीजों का सही उपयोग करते हुए पूरा विनिर्देशन URL है। नंबर वगैरह, तो यह मूल रूप से आपके एकत्रीकरण को उस विशेष रिमोट सर्वर पर पुनर्निर्देशित कर देगा, चाहे वह नेटवर्क के माध्यम से जुड़ा हो या यह लोकलहोस्ट हो, वास्तव में यह कोई समस्या नहीं है जिसका आप वास्तव में उसी तरह उपयोग कर सकते हैं।
इसलिए, इस मामले में, सभी दूरस्थ कनेक्शन के माध्यम से इस समय स्थापित करना संभव नहीं है, हालांकि आप ऐसा कर सकते हैं, लेकिन वैसे भी आपने इसे किया है, लेकिन प्रक्रिया केवल वही है जिसे URL को बदलना होगा।
और आपको अपने उपयोगकर्ता नाम और पासवर्ड का उपयोग करके अपने SQL सर्वर तक पहुंचने का विशेषाधिकार होना चाहिए, जो आपके साथ भी तैयार होना चाहिए, तभी आप किसी भी कनेक्शन को स्थापित करने में सक्षम होंगे और इस तरह किसी भी SQL स्टेटमेंट को निष्पादित कर सकते हैं।
तो, यह आज की योजना के लिए है और हमारे अगले सत्र में, हम इस बारे में चर्चा करेंगे कि मूल रूप से किसी विशेष एसक्यूएल विवरण को निष्पादित करने के बाद सभी परिणाम कैसे प्राप्त होंगे, जो कि एसक्यूएल सर्वर को वापस कर देगा हमारे जावा एप्लिकेशन द्वारा ही संभाला जाएगा।
इसलिए, हमारे अगले सत्र में इस पर चर्चा की जाएगी।
आपका बहुत बहुत धन्यवाद।
देबास समता विभाग के कंप्यूटर साइंस एंड इंजीनियरिंग इंडियन इंस्टीट्यूट ऑफ टेक्नोलॉजी, खड़गपुर व्याख्यान में 59 वर्षीय केस स्टडी - IV में आपका स्वागत है।
इस सत्र में हम कुछ और परियोजनाओं पर चर्चा करेंगे।
इसलिए, परियोजनाएं वास्तव में विचार करती हैं ताकि आप परियोजनाओं पर काम कर सकें और फिर अपने कौशल में सुधार कर सकें, इसलिए परियोजनाओं की श्रृंखला में यह 8 वीं परियोजना है जिसकी हम इस सप्ताह में चर्चा कर रहे हैं।
यह परियोजना टिक-टैक-टो खेल विकास पर आधारित है।
टिक-टैक-टो गेम बहुत ही परिचित गेम है और आप मोबाइल में आजकल उपलब्ध कुछ ऐप भी पा सकते हैं।
तो, यह गेम उपलब्ध है और फिर यह गेम उपयोगकर्ता और मशीन, सिस्टम, कंप्यूटर के बीच खेला जा सकता है।
तो, एक पार्टी;
एक खिलाड़ी उपयोगकर्ता है और दूसरा खिलाड़ी कंप्यूटर है।
हालांकि, इस गेम में हम इस बारे में चर्चा करेंगे कि गेम को दो उपयोगकर्ताओं द्वारा कैसे खेला जा सकता है;
जाहिर है, अपने स्वयं के कंप्यूटर और दो कंप्यूटरों के साथ वे खिलाड़ी जो वे गेम खेल रहे हैं, नेट के माध्यम से जुड़े हुए हैं।
तो, यह वह आवश्यकता है जो यहां आवश्यक है।
अब, हम इस खेल के बारे में विचार करें।
अब, इस विचार पर चर्चा करने से पहले कि बुनियादी कौशल की क्या आवश्यकता है ताकि आप इस परियोजना का सामना कर सकें।
जाहिर है, आपके पास जावा स्विंग के बारे में अच्छा ज्ञान होना चाहिए और फिर थोड़ा सा ग्राफिक्स भी होना चाहिए |
इवेंट हैंडलिंग तंत्र शामिल है।
तो, यह मूल रूप से जीयूआई प्रोग्रामिंग से संबंधित मुद्दे हैं और नेटवर्किंग अवधारणा की आवश्यकता है।
इसलिए, यदि आपके पास उन सभी अवधारणाओं को कवर करना है तो आप इस परियोजना के लिए तैयार हैं।
अब, इसलिए, इस परियोजना के बारे में विचार;
यहाँ जैसा कि हम टिक-टैक-टो बोर्ड को देखते हैं जैसा कि यह दिखाई देता है और यह एक परिचित रूप है जैसा कि यहाँ दिखाया गया है यह विचार टिक-टैक-टो बोर्ड है और निशान हैं।
इसलिए, दो प्रकार के अंकन हैं जैसा कि आप यहां देखते हैं;
एक अंकन पार है और दूसरा 0 है।
तो, एक खिलाड़ी द्वारा क्रॉस मार्किंग जबकि 0 मार्किंग किसी अन्य खिलाड़ी द्वारा इंगित की जाएगी।
तो, इस टिक-टैक-टो खेल का एक सरल रूप जैसा कि हम यहां देखते हैं कि एक 3 क्रॉस 3 बोर्ड है।
कुछ जटिल संस्करण भी हो सकते हैं 4 क्रॉस 4, 5 क्रॉस 5 और बहुत कुछ भी।
वैसे भी हमें बस 3 क्रॉस 3 के साथ काम करना चाहिए, बाद में यदि आपका समय परमिट और यदि आपकी रुचि बढ़ती है तो आप आसानी से 4 क्रॉस 4 या 5 क्रॉस 5 तक बढ़ा सकते हैं।
वैसे भी, हम यहां 3 क्रॉस 3 टिक-टैक-टो खेल पर विचार करेंगे।
अब, जैसा कि मैंने केवल उल्लेख किया है कि यह खेल दो खिलाड़ियों के बीच होगा।
दो खिलाड़ी अपनी मशीनों से खेल खेलेंगे;
मशीनें दूरस्थ रूप से स्थित हैं और निश्चित रूप से, मशीनें नेटवर्क के माध्यम से जुड़ी हुई हैं।
अब इसलिए, दो अनुप्रयोग इसलिए हमें विकसित करने होंगे, बल्कि दो कार्यक्रम हमें विकसित करने होंगे;
दो प्रोग्राम हम कह सकते हैं दो सॉकेट प्रोग्राम अधिक सटीक रूप से दो सॉकेट प्रोग्राम को मशीनों की मेजबानी करने के लिए निष्पादित किया जाएगा जो उपयोगकर्ताओं की मशीनों में हैं।
और, फिर दो गेम जो दो सॉकेट प्रोग्राम हम समवर्ती रूप से सीखेंगे;
एक साथ दो मशीनों में एक ही समय पर प्रोग्राम चलाने के लिए कहते हैं और फिर एक बार प्रोग्राम के निष्पादन के दौरान उपयोगकर्ता गेम खेल सकता है।
और, जो गेम हम जारी रखेंगे, आप एक समय को ठीक कर सकते हैं या गेम तब तक जारी रखा जा सकता है जब तक उपयोगकर्ता ऐसा करना चाहता है।
तो, यह इस खेल के बारे में विचार है।
अब, देखते हैं कि हम इस परियोजना से कैसे निपट सकते हैं।
अब, हम फिर से कदम दर कदम वृद्धि प्रक्रिया का पालन करेंगे ताकि हम इस खेल को आसानी से विकसित कर सकें।
पहला काम गेमिंग विंडो को डिज़ाइन करना है जैसा कि हम देखते हैं कि यह एक फ्रेम है और इस फ्रेम में आप 4 फ़ील्ड्स शामिल कर सकते हैं, बल्कि हम कह सकते हैं 4 बटन सॉर्ट चीज़ सॉरी नहीं 4 एक 9 बॉटम सॉर्ट चीज़ है और हम आसानी से कर सकते हैं यह फ्रेम वास्तव में आसानी से काम करते हैं।
तो, यह एक बहुत ही तुच्छ कार्य है और यह स्पष्ट रूप से, परियोजनाओं का पहला चरण है और हमारे अगले भाग में है।
इसलिए, अगर हम कहते हैं, तो हैंडलिंग की घटना भी इसी तरह से होगी, ऐसे लोग जिन्हें हम एक विशेष बटन का चयन करेंगे और फिर एक खिलाड़ी के चयन को X के साथ चिह्नित किया जाएगा। इसलिए, दूसरे खिलाड़ी का चयन 0 के रूप में किया जाएगा और फिर जारी रहेगा।
और, फिर हर बार खिलाड़ी को चयन को चिह्नित करने के लिए अपनी बारी आएगी और एक खिलाड़ी द्वारा खेल को जीतने के बाद स्वचालित रूप से एक संदेश बॉक्स दिखाई देगा कि यह खिलाड़ी ए या खिलाड़ी बी ने मैच जीता।
तो, यह इंटरफ़ेस है जिसे आपको पहले विकसित करना है और यह कार्यक्रम का पहला संस्करण है।
कार्यक्रम के हमारे दूसरे चरण में, हम कह सकते हैं कि यह टिक-टैक-टो खेल का दूसरा संस्करण है।
यहां हमें गेमिंग विंडो में कुछ और फंक्शन्स जोड़ने होंगे।
अब, देखते हैं कि यहाँ पर क्या कार्यक्षमता पर विचार किया जा सकता है।
तो, शुरू में प्रारंभिक इंटरफ़ेस है।
अब, प्रारंभिक इंटरफ़ेस के बाद एक स्टार्ट या स्टॉप बटन होगा;
वह बटन एक टॉगल बटन हो सकता है ताकि एक बार शुरू होने के बाद यह स्वचालित रूप से स्टॉप पर जाए।
इसलिए, यदि हम इसे स्वचालित रूप से चुनेंगे तो वह भाग वहां होगा।
इसलिए, यदि कोई खिलाड़ी अपना खेल शुरू करना चाहता है, तो खिलाड़ी;
स्टार्ट बटन होना चाहिए।
और रीस्टार्ट का मतलब है मान लीजिए कि आप गेम को बीच रास्ते में छोड़ना चाहते हैं तो आप उस स्टार्ट बटन को फॉलो कर सकते हैं।
अब, एक बार प्रारंभ होने के बाद या तो प्रारंभ होता है फिर से शुरू करने के बाद एक निष्पादन योग्य होगा, अगर यह रोक है कोई पुनः आरंभ बटन नहीं।
तो, यह आपके द्वारा चुने गए पहले बटन के आधार पर एक सक्षम, अक्षम है।
एक बार स्टार्ट बटन को स्टार्ट और रिस्टार्ट या स्टार्ट या स्टार्ट और स्टॉप और रीस्टार्ट बटन के अलावा अन्य चुना जाता है, तो हमें उपयोगकर्ता को किसी अन्य मशीन से जोड़ने के लिए एक दूसरे की पहल या सुविधाओं को भी करना पड़ता है;
कुछ अन्य उपयोगकर्ता;
कोई और खिलाड़ी।
तो, एक कनेक्ट बटन इसके लिए ध्यान रखेगा और मूल रूप से डिस्कनेक्ट हो जाएगा यदि आप गेम को छोड़ना चाहते हैं।
तो, एक उपयोगकर्ता;
एक खिलाड़ी एक कनेक्ट बटन पर क्लिक करता है, फिर यह एक विंडो पॉप अप करेगा, इसलिए, यह मूल रूप से गेम आईडी है।
तो, आपका नाम फिर से गेम आईडी हो सकता है।
अब, यदि आप पहले से ही उपयोग कर रहे हैं या सभी या कहें कि सभी उपयोगकर्ता पहले से ही उस पर काम कर रहे हैं तो उसी गेम आईडी का उपयोग किया जा सकता है।
मान लीजिए कि खिलाड़ी X पहले से ही सक्रिय है, जिसका मतलब है कि मैं सक्रिय हूं तो हम गेम एक्स को वास्तव में खेल सकते हैं अन्यथा यदि आप गेम को केवल अपनी तरफ से बनाना चाहते हैं।
तो, आप अपनी गेम आईडी दे सकते हैं।
अब, वह गेम आईडी उन सभी उपयोगकर्ताओं के लिए उपलब्ध होगी जो नेट में जुड़े हुए हैं और फिर वे यह चुन सकते हैं कि वे घर पर हैं, वे यह सब खेलना चाहते हैं।
एक बार जब गेम बन जाता है तो फिर जॉइन का ऑप्शन होगा, ताकि अगर यूजर गेम में शामिल हो सके।
और फिर गेम आईडी बनाते ही गेम को एक आईडी दिखाई देगी जो कि खेल आईडी है जिसे हमने बनाया है।
तो, अब, यह एक खिलाड़ी पक्षों से एक खेल के सत्र की शुरुआत है।
इसलिए, अन्य खिलाड़ी यह जानते हुए कि गेम आईडी क्या उपलब्ध है, वह चयन कर सकता है और फिर जुड़ सकता है और फिर मैं गेमिंग शुरू कर सकता हूं।
और यह मूल रूप से एक तरफ से है, इसलिए एक मशीन, एक सॉकेट जिसे हम कह सकते हैं।
तो, में;
दो सॉकेट में यदि प्रोग्राम चलाए जाते हैं तो नेटवर्क कनेक्टिविटी हम इन निष्पादन के बारे में ध्यान रखेंगे।
तो, यह तीसरा संस्करण है कि आपने चीजों को केवल एक साइड में एक स्टैंडअलोन में विकसित किया है और दो कार्यक्रम दो अलग-अलग मशीनों में समवर्ती कैसे चल सकते हैं और वे नेट के माध्यम से जुड़े हुए हैं।
इसलिए, यहां नेटवर्किंग की आवश्यकता है ताकि सभी सॉकेट दोनों खिलाड़ियों के बीच संवाद स्थापित कर सकें।
अब, संचार के एक हिस्से के रूप में कुछ चीजों के बारे में जिन्हें हमें ध्यान रखना है;
इसलिए, यह टिक-टैक-टो बोर्ड दोनों उपयोगकर्ताओं को सूचना की एक ही स्थिति को जारी रखने से दिखाई देना चाहिए।
इसलिए, शुरू में यह रिक्त है कि कोई क्लिक नहीं है, अब कोई टिक नहीं है, मान लीजिए कि खिलाड़ी 1 यहां और खिलाड़ी 2 है, वे खेल खेल रहे हैं और खिलाड़ी 1 इसे टिक कर रहा है।
इसलिए जैसे ही उसकी टिक टिक खत्म होगी, उसके बाद उसे चिन्हित किया जाएगा और वही मार्किंग दूसरे खिलाड़ी को भी दिखाई देगी।
अब, यह खिलाड़ी की बारी है और यहां जब खिलाड़ी की बारी होती है, तो खिलाड़ी 1 किसी भी कदम की पहल नहीं कर सकता है, इसकी अनुमति नहीं है।
इसलिए, खेल इस बारे में ध्यान रखेगा।
तो, खेल हम करेंगे;
आप खिलाड़ी का खेल खत्म होने तक इंतजार करेंगे;
अपनी चाल समाप्त कर दी।
अब, यहां फिर से खिलाड़ी 2 हम आगे बढ़ेंगे।
तो, खिलाड़ी 2 हम क्लिक करेंगे और फिर इस क्लिक के अनुसार हम उसके अपने बोर्ड में दिखाई देंगे और साथ ही अन्य पार्टियों के बोर्ड में भी दिखाई देंगे।
तो, यह जारी रहेगा और यह उस प्रकार का गेम है जिसे आपको लागू करना है और निश्चित रूप से सॉकेट प्रोग्रामिंग की आवश्यकता है और फिर GUI
प्रोग्रामिंग की आवश्यकता है।
ये दो हैं, जिसका अर्थ है कि इस परियोजना में प्रोग्रामिंग पहलुओं का प्रयोग किया जाना है।
अब, हम अगले प्रोजेक्ट पर आते हैं।
यह प्रोजेक्ट वैसा ही है जैसा हमने इस प्रोजेक्ट का शीर्षक डॉक्यूमेंट ब्राउजर दिया है, आप बिल्कुल ब्राउजर जानते हैं।
ब्राउज़र मूल रूप से एक इंटरफ़ेस अधिकार है, जैसे इंटरनेट एक्सप्लोरर या कहें कि मोज़िला या क्रोम आपको पता है कि ये ब्राउज़र हैं।
अब, इसलिए ब्राउज़र मूल रूप से एक लिंक लेता है और लिंक या ब्राउज़र के आधार पर हम I माध्य लिंक ले लेंगे और फिर वे उस लिंक पर नेविगेट करेंगे और फिर यह कुछ चीजें लाएगा।
कुछ समय ब्राउज़र भी अगर यह एक खोज इंजन है जैसे उदाहरण के लिए, Google तो वे एक लिंक लेंगे और साथ ही वे कुछ कीवर्ड भी लेंगे।
और फिर कीवर्ड से संबंधित वे पूरे इंटरनेट पर खोज करेंगे और फिर और जो भी दस्तावेज इस कीवर्ड के साथ मेल खाते हैं, वे इसे उपयोगकर्ता को लाएंगे।
हो सकता है कि यह जो भी हो, लाख लिंक हो, लेकिन जो भी है, उसके लाखों दस्तावेज हैं।
अब, इसलिए, एक खोज इंजन है, किसी भी कार्यक्रम से खोज इंजन तक पहुँचा जा सकता है।
वास्तव में, ट्रिक्स के बारे में थोड़ी-बहुत तरकीबें हैं जो इंटरनेट से आसानी से उपलब्ध हो सकती हैं यदि आप बस एक त्वरित खोज करते हैं और फिर आप इसके लिए कई समाधान पा सकते हैं।
फिर भी, मैं उस चर्चा पर बाद में विस्तार से चर्चा करूंगा।
तो, इस बारे में क्या विचार है कि एक ब्राउज़र मूल रूप से ब्राउज़ करेगा;
इस अर्थ में ब्राउज़ करें कि यह नेट सर्फ करेगा और फिर दस्तावेज़ को ब्राउज़र मशीन या उपयोगकर्ता मशीन कहेगा।
इसलिए, उपयोगकर्ता सिस्टम को ब्राउज़ करेगा।
तो, यहां उपयोगकर्ता एक ब्राउज़र है और उपयोगकर्ता एक इंटरफ़ेस के माध्यम से ब्राउज़ करेगा।
वह इंटरफ़ेस जिसे हम विकसित करने जा रहे हैं और हम एक दस्तावेज़ ब्राउज़र हैं।
निश्चित रूप से यह ब्राउज़ नहीं करेगा आप इसे थोड़ा सरल बनाना चाहते हैं ताकि हम एक विशेष प्रकार के दस्तावेजों तक सीमित रह सकें, यह केवल एक पीडीएफ दस्तावेज़ है।
इसका मतलब है कि वे नेट में उपलब्ध दस्तावेज हैं।
बहुत सारे I मतलब है कि लाखों दस्तावेज़ हैं, अरबों दस्तावेज नेट में उपलब्ध हैं जो मूल रूप से एक पीडीएफ प्रारूप में हैं।
वैसे भी, इसलिए यदि यह दस्तावेज़ ब्राउज़र केवल उन पीडीएफ सामग्री को खोजेगा जो इंटरनेट में उपलब्ध हैं, तो www डॉट w में जिसे वास्तव में वर्ल्ड वाइड वेब लिंक कहा जाता है।
अब, इस परियोजना के बारे में चर्चा करते हैं।
तो, यहां मूल रूप से आपको एक जावा प्रोग्राम विकसित करना होगा जो एक उपयोगकर्ता की मदद करेगा, उपयोगकर्ता एक I माध्य उपयोगकर्ता है जिसका अर्थ है कि हम किसी भी पीडीएफ दस्तावेज़ के लिए नेट में एक दस्तावेज खोज रहे हैं।
उपयोगकर्ता प्रदान करेगा
निश्चित रूप से एक कीवर्ड।
एक कीवर्ड शब्दों का एक समूह हो सकता है या जो कुछ भी हो, कोई समस्या नहीं है।
तो, एक कीवर्ड शायद एनपीटीईएल का कहना है कि यह कीवर्ड है।
तो, यह वहाँ की तरह सभी पीडीएफ फाइल से संबंधित एनपीटीईएल पाठ्यक्रम प्राप्त होगा।
इसलिए, वैसे भी एक बार जब उपयोगकर्ता एक खोज शब्द प्रदान करता है;
इसलिए कीवर्ड्स सही हैं, फिर आपका प्रोग्राम कुछ सर्च इंजन का उपयोग करके खोज करेगा और कीवर्ड के साथ मिलान के साथ सभी दस्तावेजों को लाएगा, यही वह अवधारणा है जिसे आपको इसे लागू करना है।
सभी दस्तावेज़ों को ब्राउज़र की स्थानीय मशीन में आपकी सूची में पॉपुलेट किया जाएगा।
तो, इसका मतलब है, यह बिल्कुल वैसा नहीं है जैसा कि Google जैसा सर्च इंजन आपके लिए करता है, यह मूल रूप से सभी डॉक्यूमेंट का लिंक देता है तो यूजर को कुछ स्निपेट के साथ क्लिक करना होता है।
हालाँकि, मैं बता रहा हूं कि आप इसे ला सकते हैं, लेकिन हमें इस चरण को थोड़ा कम करना होगा, जो मूल रूप से खोज इंजन रिटर्न है और फिर पीडीएफ फाइल प्राप्त करें, और अपनी खुद की इन पीडीएफ फाइल को डाउनलोड करें और फिर अपने आप में एक सूची बनाएं मशीन।
तो, यह अतिरिक्त कदम है जो आपके ब्राउज़र को करना चाहिए या प्रस्तावित ब्राउज़र को करना चाहिए।
और फिर एक बार जब दस्तावेज़ों की सूची को उपयोगकर्ता मशीन में लाया जाता है तो एक उपयोगकर्ता प्रत्येक पसंद के किसी भी दस्तावेज़ को सूचीबद्ध किए गए सभी दस्तावेजों के शीर्षक को चुन सकता है।
और, फिर दस्तावेज़ को उपयोगकर्ता द्वारा पढ़ा जाना चाहिए।
यहां फिर से कुछ फंक्शंस जोड़े जाने हैं यहां उन फंक्शनालिटीज हैं जो डॉक्यूमेंट ओपन होंगी, डॉक्यूमेंट को चिन्हित किया जाएगा, एक डॉक्यूमेंट को सेव किया जाएगा, एक डॉक्यूमेंट को रेट किया जाएगा जो भी हो।
तो, आप प्रस्ताव कर रहे हैं कि यदि दस्तावेज़ की तरह दस्तावेज़ कुछ भी कहते हैं, तो हम 10 बिंदु दे सकते हैं और यदि वह बिल्कुल पसंद नहीं करता है, तो यह 0 बिंदु है।
इसलिए, 0 से 10 तक एक लिकर्ट स्केल में एक दस्तावेज को रेट किया जा सकता है।
और, फिर इस रेटिंग को दस्तावेज़ में ही रखा जा सकता है और उपयोगकर्ता भविष्य में आगे पढ़ने के लिए इस दस्तावेज़ को बचा सकता है।
इसलिए, दस्तावेज़ को इस रेटिंग बिंदु और सब कुछ के साथ संग्रहीत किया जाएगा।
तो, ये चीजें हैं जो आपके दस्तावेज़ ब्राउज़र को उपयोगकर्ता के लिए सुविधाजनक होंगी।
अब, देखते हैं कि हम इस दस्तावेज़ को चरण दर चरण कैसे विकसित कर सकते हैं।
इसलिए, पहले हमें एक सरल लेआउट बनाना होगा जैसा कि हमने यहां दिखाया है कि लेआउट में सरल पाठ क्षेत्र स्तर और फिर बटन शामिल होगा।
तो, यहाँ स्तर मूल रूप से वह कीवर्ड है जिसे आप एंटर टेक्स्ट की तरह सप्लाई करना चाहते हैं और फिर यह एक टेक्स्ट फील्ड है जहाँ कीवर्ड जो मूल रूप से उपयोगकर्ता है वह प्रदान करेगा और फिर अंत में सर्च करेगा।
इसलिए, जब भी बटन पर क्लिक किया जाएगा, यह मूल रूप से Google खोज इंजन या किसी अन्य खोज इंजन से जुड़ जाएगा, जिसे आप अपनी मशीन में उपयोग करना चाहते हैं और फिर इस खोज इंजन को कहें।
फिर, आपको इस खोज कीवर्ड को केवल खोज इंजन में संचार करना होगा;
खोज इंजन इसे लेता है, खोज इंजन आपके लिए दस्तावेज़ लाएगा, स्निपेट्स और लिंक वाले सभी पृष्ठ लौटाएगा और सब कुछ होगा, फिर आपका प्रोग्राम लिंक को सही ढंग से ब्राउज़ करेगा और फिर दिए गए लिंक के अनुरूप नेटवर्क कनेक्ट करेगा और दस्तावेज़ लाएगा।
यहां एक नेटवर्किंग समस्या है।
तो, आपको सभी चीजों को संसाधित करना होगा और फिर और फिर नेटवर्क संचार करने की आवश्यकता है ताकि यह फ़ाइलों और सब कुछ को पुनः प्राप्त कर सके।
वैसे भी, यह पहला स्तर का इंटरफ़ेस है जिसे आपको विकसित करना है।
जब भी उपयोगकर्ता खोज कीवर्ड दर्ज करता है तो थोड़ा सा भारी कोड शामिल होता है।
यह थोड़ा समय लेने वाला काम है और थोड़ा सा नवाचार भी हैं क्योंकि यह वास्तव में इतना आसान काम नहीं है, लेकिन अगर आप कोशिश करते हैं और फिर यदि आप थोड़ा अनुभवी उपयोगकर्ता हैं तो यह बहुत ही सरल बात है।
एक तरह का अनुभव यदि आप इकट्ठा करते हैं, यदि आप इसे सीखते हैं, तो यह इस तरह के सॉफ़्टवेयर विकास के भविष्य के विकास में वास्तव में उपयोगी है।
अब, यहाँ, एक उदाहरण है।
इसलिए, उपयोगकर्ता द्वारा खोज इंजन पर क्लिक करने के बाद, यह मूल रूप से खोज इंजन से संपर्क करेगा और फिर यह मूल रूप से लिंक को लौटाएगा, जैसा कि आप देख रहे हैं कि विभिन्न लिंक जो पीडीएफ फाइल जारी रख रहे हैं और सभी पीडीएफ फाइल को दस्तावेजों के लिए अगले के रूप में लाया जाएगा के बदले में।
अब, यहाँ आप इंटरफ़ेस का हमारा अगला संस्करण देखते हैं, जिसे आपको लाने के लिए डॉक्यूमेंट जोड़ना होगा और वे लिस्ट बॉक्स होंगे।
जैसा कि हम यहां मूल रूप से देखते हैं;
इसलिए, यह मूल रूप से सूची बॉक्स है, जिसमें सिस्टम में इन कीवर्ड के आधार पर सभी दस्तावेज शामिल होंगे।
तो, यह वहाँ उपकरण होगा।
फिर उपयोगकर्ता इस सूची को नेविगेट कर सकता है और फिर इसे स्क्रॉल कर सकता है फिर इस पूरी सूची पर क्लिक करना एक गठित होगा और फिर अपनी रुचि की एक सूची का चयन करें।
एक विशेष दस्तावेज़ का चयन किया जाता है तब खुला बटन होगा यदि इसे क्लिक किया जाता है, तो दस्तावेज़ खोला जाएगा।
और फिर इन दस्तावेज़ों को खोलने के लिए एक और इंटरफ़ेस होना चाहिए;
इसका मतलब है, आपको एक और एक उपयोगकर्ता प्रोग्राम विकसित करना होगा जो मूल रूप से दस्तावेज़ को खोलेगा।
आपको किसी भी एडोब पीडीएफ या कुछ पीडीएफ, ब्राउज़र का उपयोग नहीं करना चाहिए;
आपको अपने स्वयं के ब्राउज़र दस्तावेज़ को विकसित करना होगा ताकि यह मूल रूप से ब्राउज़र विंडो हो।
अब, ब्राउज़र विंडो आमतौर पर इस तरह दिखेगी, मान लीजिए कि यह इंटरफ़ेस है और फिर ब्राउज़र विंडो है और यहाँ ब्राउज़र विंडो की नज़र है।
इसलिए, यह एक और GUI है जिसे आपको उपयोगकर्ता द्वारा दिखाई देने वाले खुले बटन का चयन करने के बाद विकसित करना होगा।
और इस ब्राउजर में आपको कुछ सुविधाएं जोड़नी हैं जैसे कि आप कहते हैं प्लस और माइनस।
इसलिए, यदि आप प्लस पर क्लिक करते हैं, तो दस्तावेज़ को थोड़ा अधिक रिज़ॉल्यूशन जूम किया जाएगा और यह शून्य से कम होगा।
इसलिए, उपयोगकर्ता की पसंद और आवश्यकता के आधार पर, दस्तावेज़ को या तो ज़ूम इन या ज़ूम आउट किया जाएगा।
और, फिर बैक बटन भी होना चाहिए, बैक बटन अगले पिछले पेज से स्क्रॉल होगा और अगला बटन भी हम यहां भी लागू कर सकते हैं, ताकि यह अगले पेज पर जाए।
इसलिए, यह पेज अप है, पेज डाउन तरह की चीजें हैं।
इसके अलावा, एक स्क्रॉलबार होना चाहिए यदि दस्तावेज़ आकार में बहुत बड़ा है, तो स्क्रॉलबार का पालन करने की आवश्यकता है।
इसलिए, स्क्रॉलबार उपयोगकर्ता का उपयोग करके दस्तावेज़ को ऊपर और नीचे भी इस तरफ से उस तरफ भी स्क्रॉल कर सकते हैं।
तो, ऊर्ध्वाधर स्क्रॉल बार और क्षैतिज स्क्रॉलबार दोनों को इसमें शामिल किया जा सकता है जिसे दस्तावेज़ पाठक कहा जाता है वास्तव में आप कह सकते हैं।
इसलिए, यह विचार है और इसके अलावा हम रेटिंग जैसी कुछ और सुविधाएं भी जोड़ सकते हैं और जैसा कि मैंने आपको रेटिंग दी है और फिर भविष्य के रेफरल के लिए दस्तावेज़ को सहेज रहा है।
इसलिए, इसे तीसरे संस्करण के रूप में आपकी परियोजना के अगले चरण के रूप में किया जा सकता है।
जैसा कि आप यहां देख रहे हैं, इसके अलावा इन सभी चीजों के बारे में हम पहले ही चर्चा कर चुके हैं।
अब, मैं सिर्फ दस्तावेज पाठक में केवल कुछ और चीजें जोड़ना चाहता हूं जैसा कि आप यहां देखते हैं।
तो, दर जैसे एक बटन पर;
इसका मतलब यह है कि यदि आप इस दस्तावेज़ को पढ़ते हैं तो आप इस दस्तावेज़ को 0 से 10 तक लिख सकते हैं और दोनों समावेशी पैमाने पर इसे सहेज सकते हैं।
यहाँ एक और बटन है;
इसका मतलब है, यदि आप इस दस्तावेज़ को पसंद करते हैं और यदि आप इस दस्तावेज़ को सहेजना चाहते हैं तो यह मूल रूप से यह देगा।
जब आप इसे क्लिक करेंगे तो यह सेव लोकेशन और फिर उस फाइल का नाम जिसे आप इसे सेव करना चाहते हैं, आप कर सकते हैं और फिर सेव बटन पर क्लिक किया जा सकता है और फिर यह आपकी खुद की मशीन में डॉक्यूमेंट को सेव करेगा।
इसलिए, जब भी यह दस्तावेज़ सहेजा जाता है;
यह रेटिंग मूल्यों के साथ भी सहेजा जाएगा।
तो, दो चीजों को बनाए रखा जाना है;
तदनुसार बचत पैटर्न बनाया जाना चाहिए।
तो, यह विंडोज ऑपरेटिंग सिस्टम या अन्य बचत के रूप में सरल बचत नहीं है, अन्य तरीके आपके लिए करते हैं।
तो, आपको थोड़ा सा करना होगा कि कैसे दो चीजों को बनाए रखा जा सकता है।
यह एक बहुत बड़ा काम नहीं है आप एक साधारण लॉक फ़ाइल को बनाए रख सकते हैं और लॉक फ़ाइल में आप इन सभी जानकारी को लाइव शामिल कर सकते हैं।
इसलिए, यह मूल रूप से दस्तावेज़ ब्राउज़र के बारे में विचार है और मुझे आशा है कि आप इसे समझ गए होंगे।
समझने के लिए कुछ कठिनाइयों के मामले में आप मेरी टीम के लिए मुझसे संपर्क करने के लिए स्वतंत्र महसूस कर रहे हैं
इसके अलावा, वे लगातार आपके समर्थन के लिए उपलब्ध रहेंगे।
इसलिए, यह दो परियोजनाओं के बारे में विचार है और हम अगले सत्र में कुछ और परियोजनाओं पर चर्चा करेंगे।
ध्यान देने के लिए धन्यवाद।
कंप्यूटर विज्ञान इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर लेक्चर के जावा प्रो। देबासीस सामंता विभाग में प्रोग्रामिंग, 02 जावा प्रोग्रामिंग एनवायरनमेंट तो, इस व्याख्यान में, हम इस बारे में जानने वाले हैं कि हम कैसे अपना कार्यक्रम लिख सकते हैं और फिर वही कार्यक्रम हो सकता है। हमारी मशीन में निष्पादित।
तो, आज हम जावा में प्रोग्रामिंग के विभिन्न चरणों पर बहुत ही सरल तरीके से चर्चा करेंगे।
इसलिए, यदि आपके पास कोई विचार नहीं है, तो यह मुश्किल नहीं है, आप इसका पालन करने में सक्षम होंगे।
अब, देखते हैं कि हम अपना पहला जावा प्रोग्राम कैसे लिख सकते हैं। पूर्व कथन सही है, कहते हैं।
तो, यहाँ मूल रूप से शामिल है और फिर यह मूल रूप से मुख्य है।
तो, मुख्य फ़ंक्शन जैसा कि आप जानते हैं कि सी प्रोग्रामिंग मूल रूप से कार्य करने वाली प्रोग्रामिंग है।
तो, मुख्य फ़ंक्शन नामक एक फ़ंक्शन होना चाहिए।
तो, यह प्रोग्राम सी प्रोग्रामिंग में लिखा गया है और आप देख सकते हैं कि यह प्रोग्राम मूल रूप से अगर आप इसे चलाते हैं तो यह
हैलो, वर्ल्ड! नामक संदेश प्रिंट करेगा।
अब, देखते हैं कि जावा प्रोग्राम लिखकर उसी सही कार्य को कैसे निष्पादित किया जा सकता है।
अब, एक जावा प्रोग्राम आम तौर पर इस तरह दिखेगा।
अब, आप दो कार्यक्रमों के बीच अंतर देख सकते हैं:
एक प्रोग्राम C में है और दूसरा जावा में है।
तो, यह सी में 'शामिल' है, लेकिन यहां यह जावा में 'आयात' है।
और यहाँ आप मुख्य लिखते हैं, यहाँ हम इस तरह से मुख्य लिखते हैं, लेकिन एक अजीब बात है कि अगर सिंटैक्स।
अजीबोगरीब वाक्यविन्यास इस सार्वजनिक स्थैतिक शून्य की तरह है जिसे केवल int की आवश्यकता नहीं है या कुछ शून्य वहाँ C. में हो सकते हैं, तो यहाँ विशेष बात है जो हम इन बातों के अर्थ के बारे में सीखते हैं जो जावा में आवश्यक हैं।
संदेश प्रिंट करने के लिए C में प्रिंट स्टेटमेंट है।
यहां जावा में एक ही काम करने के लिए हमें इस तरह के सिंटैक्स की आवश्यकता है - System.out.println ("") और फिर इस दोहरे उद्धरण के भीतर उस संदेश को मुद्रित करना होगा जिसे मुद्रित करने की आवश्यकता है।
तो, अनिवार्य रूप से दो कार्यक्रम एक ही काम करेंगे, लेकिन वे एक अलग वाक्यविन्यास और विभिन्न भाषा निर्माण में लिखे गए हैं।
तो, यह इस बारे में विचार है और यह आपका पहला कार्यक्रम है और एक और बात जो मुझे यहां बताई जानी चाहिए वह यह है कि जावा आपत्तिजनक प्रोग्रामिंग है।
इसलिए, हमें एक वस्तु विकसित करनी होगी।
एक वस्तु मूल रूप से एक वर्ग को परिभाषित करने के माध्यम से विकसित की जाती है।
तो, यहाँ यह उस वर्ग का नाम है जिसे मूल रूप से हम चलाने के लिए उपयोग करेंगे;
मेरा मतलब है, इस कार्यक्रम को एक वस्तु के रूप में चलाएं।
तो, यहाँ क्लास का नाम HelloWorldApp रखा गया है। यह वह नाम है जिसे आप 1, 2 जैसे यह भी दे सकते हैं।
लेकिन कुछ चीजें हैं जो आपको विशेष नाम देने से पहले इसका पालन करना होगा और जो भी हो।
अब, हमें यह जानना होगा कि हम एक संदेश को प्रिंट करने के लिए जावा में एक प्रोग्राम कैसे चला सकते हैं और यह इस कार्यक्रम का एक विशिष्ट रूप है, आपको यह थोड़ा मुश्किल लग सकता है।
इसलिए, कि अलग-अलग वाक्यविन्यास और सब कुछ क्या हैं, लेकिन जैसे-जैसे समय बीतता है और फिर आप कई चीजों पर चर्चा करेंगे।
तो, ये सभी चीजें आपके लिए आसान होंगी और तब आप इस अवधारणा के आदी हो पाएंगे।
इसलिए, आपको इस बारे में चिंतित नहीं होना चाहिए।
अब, इसे चलाने के बाद और एक और महत्वपूर्ण बात यह है कि एक केस सेंसिटिव के रूप में, दोनों प्रोग्रामिंग लैंग्वेज, जैसा कि आप जानते हैं या यदि आप पहले से ही C प्रोग्रामिंग जानते हैं, तो आप जानते हैं कि C एक केस सेंसिटिव है और Java एक केस सेंसिटिव भी है।
उदाहरण के लिए केस सेंसिटिव का अर्थ है, जहां सिस्टम इसे इस तरह से भरता है।
तो, पहला चरित्र पूंजी एस है और यह मायने रखता है।
इसलिए, यदि आप इस कार्यक्रम को लिखते हैं जो छोटी पूंजी, छोटे अक्षरों में सभी वर्णों को छोटे अक्षरों में लिखता है, तो यह वैसी बात नहीं है जैसी होनी चाहिए।
और यहां, उदाहरण के लिए, नाम
कक्षा का नाम हैलोवर्ल्ड है और आप देखते हैं कि कुछ बड़े अक्षर हैं कुछ छोटे अक्षर हैं इसका मतलब यह है कि वे अलग-अलग हैं।
इसलिए, यदि आप सभी को छोटे अक्षरों में लिखते हैं, तो इसका मतलब है कि यह एक नया वर्ग और इस तरह परिभाषित करता है।
तो, ये मूलतः केस सेंसिटिव हैं और जावा केस सेंसिटिव प्रोग्रामिंग लैंग्वेज है।
फिर जब आप प्रोग्राम टाइप करते हैं तो आपको विचार करना चाहिए कि उनके पास सही पत्र हैं या नहीं।
अब, यहाँ फिर से, C प्रोग्रामिंग बनाम जावा प्रोग्रामिंग के बारे में और हमारे द्वारा उपयोग किए जाने वाले प्रतिमानों के बारे में कुछ और अंतर हैं, इस प्रतिमान द्वारा, दो प्रोग्राम भाषाएं पूरी तरह से अलग हैं।
और, सी प्रोग्रामिंग भी प्लेटफ़ॉर्म स्वतंत्र नहीं है जबकि, जावा प्रोग्रामिंग प्लेटफ़ॉर्म स्वतंत्र है।
और कुछ चीजें आप इस तालिका से नोट कर सकते हैं कि कई चीजें जो सी प्रोग्रामिंग का समर्थन करती हैं लेकिन जावा प्रोग्रामिंग का समर्थन नहीं करती हैं।
यह थोड़ा आश्चर्यचकित करने वाला हो सकता है, लेकिन आश्चर्य की बात नहीं है वास्तव में जावा डेवलपर प्रोग्रामिंग को जितना संभव हो उतना सरल बनाना चाहता है, जितना आसान प्रोग्रामर के लिए यह संभव है।
तो, यही कारण है कि जावा प्रोग्रामिंग सेटिंग में कई महत्वपूर्ण और फिर जटिल मुद्दे जो मूल रूप से बहुत सारी त्रुटियों की ओर ले जाते हैं, को ध्यान से अनदेखा किया गया है।
तो, यही कारण है कि कई चीजें हैं जो जावा प्रोग्रामर द्वारा समर्थित नहीं हैं और इसके अलावा कुछ चीजें ऐसी भी हैं, जो सी जैसी कार्य करने वाली प्रोग्रामिंग में संभव नहीं है, लेकिन यह जावा प्रोग्रामिंग में संभव है।
उदाहरण के लिए, वंशानुक्रम एक अवधारणा जिसे हमने पिछले व्याख्यान में चर्चा की है।
यह मूल रूप से C में संभव नहीं है जबकि, यह संभव है
जावा।
एक संकेतक त्रुटियों का एक बड़ा सौदा है और फिर वास्तव में क्षमताओं को सीखना है, इसलिए इस अवधारणा का सामना करना आमतौर पर बहुत मुश्किल होता है।
तो, जावा डेवलपर ने इसे अनदेखा किया है इसका मतलब है कि जावा प्रोग्रामिंग में पॉइंटर का कोई व्यवसाय नहीं है;
कुछ चीजें बहुत आवश्यक हैं।
अब तक वितरित प्रोग्रामिंग और फिर इंटरनेट अनुप्रयोगों को वे मल्टीथ्रेडिंग कहते हैं और उन चीजों को इंटरफेस करते हैं।
और, मजबूत और सबसे विश्वसनीय प्रोग्रामिंग बनाने के लिए जावा ने अवधारणा पेश की जो अपनी तरह का नया है।
वास्तव में, इसे अपवाद हैंडलिंग कहा जाता है जो सी प्रोग्रामिंग भाषा में नहीं है, लेकिन यह जावा प्रोग्रामिंग में आसानी से उपलब्ध है।
और, डेटाबेस कनेक्टिविटी आमतौर पर C डेटाबेस कनेक्टिविटी का समर्थन नहीं करता है, लेकिन जावा के साथ, हम डेटाबेस को कनेक्ट करने में सक्षम होंगे।
ये सभी मूल रूप से सी प्रोग्रामिंग पर सुविधा है और हम जावा प्रोग्रामिंग वातावरण से आनंद ले सकते हैं।
अब, इसलिए हमने पहले कार्यक्रम पर चर्चा की है जिसे हम जावा प्रोग्रामिंग में लिख सकते हैं, हमें इसके बारे में एक विचार है।
अब, देखते हैं कि हम इस प्रोग्राम को कैसे टाइप कर सकते हैं, हमें क्या सेटिंग करनी चाहिए।
अब, आप किसी भी एडिटर का उपयोग कर सकते हैं, एक टेक्स्ट एडिटर है जैसे कि नोटपैड या MSWord या यूनिक्स में एडिट कमांड जो भी है वहां है।
यूनिक्स में कुछ अन्य कमांड एडिटर भी हैं जैसे vi, emacs और gedit।
तो, आप किसी भी संपादक का उपयोग कर सकते हैं और फिर अपने जावा प्रोग्राम की तरह कोई भी पाठ टाइप कर सकते हैं, जिसकी चर्चा हमने कुछ स्लाइड्स में की है। HelloWorldApp आप इसे लिख सकते हैं।
और जब आप इस कार्यक्रम को बचाते हैं तो विशेष देखभाल, ठीक है, मेरा मतलब है कि कार्य को ध्यान में रखा जाना चाहिए जो कि कार्यक्रम का नामकरण है।
तो, और फिर वह निर्देशिका जिसे आप देख सकते हैं;
यहां सेव करने के बाद आप देख पाएंगे कि इस तरह का प्रोग्राम आपके वर्तमान वर्किंग डायरेक्टरी में सुरक्षित है।
तो, एक बार तो यह मूल रूप से संपादन का कार्य है;
इसका मतलब है कि आप gedit संपादक या Notepad या MSWord जैसे संपादक का उपयोग करके अपना कार्यक्रम कैसे टाइप कर सकते हैं।
अब, मैं इस चर्चा पर आता हूं कि आप इस कार्यक्रम को कैसे संकलित कर सकते हैं अर्थात इस कार्यक्रम का अनुवाद कर सकते हैं।
जैसा कि आप जानते हैं कि java फाइल मूल रूप से एक हाईलेवल प्रोग्राम है, जिसका अर्थ है एक हाईलेवल भाषा में लिखा गया प्रोग्राम।
तो, इस कार्यक्रम को निष्पादित करने के लिए इसे मशीन स्तर कोड बाइनरी कोड फॉर्म में अनुवाद किया जाना चाहिए।
अब, मैं इस बात पर चर्चा करूंगा कि इसका मतलब मैं कैसे संकलित या अनुवादित कर सकता हूं।
अब, इस अनुवाद के लिए जावा डेवलपर द्वारा प्रदान किया गया एक कार्यक्रम है और कार्यक्रम का नाम या आप कह सकते हैं कि कमांड को जावा c javac कहा जाता है इसे javac कहा जाता है;
यह जावा कंपाइलर का मूल रूप से संक्षिप्त रूप है।
तो, आप एक कमांड के रूप में javac का उपयोग कर सकते हैं और फिर इस javac को java फ़ाइल के नाम से टाइप कर सकते हैं।
उदाहरण के लिए, javac HelloWorldApp। जावा।
इसलिए, यदि आप इसे चलाते हैं और यदि आपके कार्यक्रम में कोई त्रुटि नहीं है, तो जावा इस कार्यक्रम को सफलतापूर्वक संकलित करेगा।
तो, यह मूल रूप से वह कार्य है जो संकलन हम आपके लिए करेंगे और फिर इसका मतलब निष्पादन होगा।
तो, आपके द्वारा पहले से बनाई गई क्लास फ़ाइल उसी निर्देशिका से उसी फ़ाइल को निष्पादित कर सकती है यदि आप निर्देशिका से कमांड टाइप करते हैं।
तो, निर्देशिका में जो क्लास फाइल है, वह कहती है कि आप डायरेक्ट्री और फिर डायरेक्टरी से काम कर रहे हैं, यदि आप यह कमांड चलाते हैं, तो वह प्रोग्राम चलाएगा।
और, यहाँ आप इस कार्यक्रम को चलाते समय देखते हैं कि आपको उन्हें निर्दिष्ट करने की आवश्यकता नहीं है। वर्ग, बस फ़ाइल का नाम बिना किसी विस्तार के यह आपके कार्यक्रम को चलाएगा।
और, यदि रनटाइम के दौरान कोई त्रुटि नहीं होती है, तो कभी-कभी एक त्रुटि भी होती है, तो यह प्रोग्राम स्क्रीन पर आउटपुट का उत्पादन करेगा या यह आउटपुट स्टोर करेगा।
इसलिए, हम इस बारे में सीखते हैं कि किसी प्रोग्राम को कैसे संपादित किया जाए, फिर इसे कैसे संकलित किया जाए और प्रोग्राम को कैसे निष्पादित किया जाए।
इसलिए, यह अवधारणा बहुत सरल है और इससे निपटने के लिए मुझे कुछ साधनों की आवश्यकता है।
इसलिए, हमारे एक प्रदर्शन में, हम आपको पर्याप्त कार्यक्रम देंगे, ताकि आप अपने दम पर अभ्यास कर सकें।
अब, हमारी अगली चर्चा में जाने से पहले मैं केवल कुछ बातों पर प्रकाश डालना चाहता हूं।
मैंने कई बार बताया कि प्रोग्रामिंग एक प्लेटफ़ॉर्म स्वतंत्र है जबकि, सी प्रोग्रामिंग नहीं है;
वास्तव में इसका क्या मतलब है।
तो, यहाँ अर्थ को यहाँ समझा जा सकता है।
उदाहरण के लिए, यह वह प्रोग्राम है जिसे आपने किसी भी एडिटर नोटपैड का उपयोग करके लिखा है और फिर प्रोग्राम का नाम है हैलोवर्ल्ड जावा।
और, इस कार्यक्रम का अनुवाद एक कंपाइलर द्वारा किया जाता है जिसे जेवैक कहा जाता है।
फिर प्लेटफ़ॉर्म इंडिपेंडेंट का मतलब यह है कि आपके द्वारा विकसित की गई एक ही फाइल को एक मशीन में निष्पादित किया जाना चाहिए जिसे हम विंडोज 32 कहते हैं, दूसरी मशीन में हम कहते हैं कि विंडोज़ 64 या किसी अन्य मशीन में सोलारिस कहते हैं या एक मैकओएस या जैसा है।
तो इसका मतलब है, जो प्रोग्राम सफलतापूर्वक संकलित किया गया है वह किसी भी ऑपरेटिंग सिस्टम में निष्पादन योग्य होना चाहिए चाहे वह विंडोज हो या यह यूनिक्स हो या फिर यह मैकओएस हो, तब इसे प्लेटफॉर्म इंडिपेंडेंट कहा जाता है।
इसलिए, यह अवधारणा मूल रूप से यहां संभव है।
इसका मतलब यह है कि फ़ाइल जिसे हमने संकलित करके बनाया है इसका मतलब है। क्लास फाइल मूल रूप से एक प्रकार की चीज है जिसे कोई भी मशीन ठीक समझ सकती है।
यदि यह स्वतंत्र मंच नहीं है, तो इसका मतलब है कि संकलक एक कोड को संकलित करेगा जो मूल रूप से केवल एक विशेष मशीन इसे समझ सकता है।
तो, सी कंपाइलर मूल रूप से अलग सी कंपाइलर हैं या प्रोग्राम को विभिन्न मशीनों में अनुवाद कर रहे हैं यही कारण है कि यह पूरी तरह से प्लेटफॉर्म से संबंधित है।
इसका मतलब वही मशीन है जो मूल रूप से है
इस मशीन के लिए संकलन दूसरी मशीन में निष्पादित नहीं किया जा सकता है।
हो सकता है कि उच्च स्तरीय भाषा कार्यक्रम समान हो, लेकिन अंतिम निष्पादन योग्य बात मूल रूप से अलग है।
तो, यही कारण है कि सी प्रोग्रामिंग हमें प्लेटफ़ॉर्म-स्वतंत्र अवधारणा प्रदान नहीं कर सकती है, लेकिन यहां मूल रूप से अवधारणा के कारण है। कक्षा।
अब, यहाँ फिर से, सवाल यह है कि इसमें क्या खास बात है। कक्षा।
तो, यह विचार मूल रूप से की अवधारणा है। क्लास मूल रूप से एक कोड है जिसे मूल रूप से कोई भी मशीन समझ सकता है;
इसका मतलब है कि, यह निष्पादन योग्य कोड मूल रूप से एक आभासी मशीन को लक्षित करके विकसित किया गया है।
अब, इस अवधारणा के बारे में, हम विवरण में चर्चा करेंगे जब भी आप मंच के स्वतंत्र मुद्दे पर अधिक विस्तार से चर्चा करेंगे।
अब, एक प्रोग्रामिंग भाषा है और मुख्य रूप से यह एक वस्तु-उन्मुख प्रोग्रामिंग भाषा है।
जैसे बाजार में आने से पहले एक अन्य वस्तु-उन्मुख प्रोग्रामिंग भाषा है, उस समय एक और प्रोग्रामिंग भी बहुत लोकप्रिय है;
इसे C ++ कहा जाता है।
प्रोग्रामिंग मूल रूप से C का विस्तार है, C एक फ़ंक्शन-ओरिएंटेड है जबकि, C + + ऑब्जेक्ट-ओरिएंटेड है, लेकिन ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग के माध्यम से सभी दो प्रोग्रामिंग भाषा में मौलिक रूप से कई अलग-अलग विशेषताएं हैं।
तो, आइए जल्दी से देखें कि दो प्रोग्रामिंग वातावरण C या C ++ और Java में क्या अंतर हैं।
अब सबसे पहले अब तक प्रोग्राम बिल्डिंग और सॉफ्टवेयर डेवलपमेंट एक चिंता का विषय है, जिसे पूरा करने के लिए वे अलग-अलग काम करते हैं;
C, C ++ में अनुसरण किए जाने वाले कार्य को यहां दिखाया गया है।
इसलिए, यदि आप एक प्रोग्राम लिखते हैं, जिसे आप प्रोग्राम फ़ाइल कहते हैं, तो स्रोत फ़ाइल यह है और
स्रोत फ़ाइल में कुछ प्रीप्रोसेसिंग है;
इसका मतलब है, यह लिंक करेगा और अगर यह किसी भी पुस्तकालय और सब कुछ है।
इसलिए, वे पहले प्रीप्रोसेसिंग के माध्यम से गुजरते हैं और फिर अंत में, पूर्व प्रस्तावित चीजों को संकलित किया जाएगा।
और, फिर संकलन के बाद, यह विधानसभा कोड का उत्पादन करता है।
असेंबली कोड मूल रूप से संख्यात्मक में कार्यक्रम है, इस तरह से तेज।
फिर असेंबलर वहाँ होगा जो मूल रूप से असेंबलर का उपयोग करके मशीन कोड में असेंबली कोड का विधानसभा कोड अनुवाद करेगा।
और यहाँ ये असेम्बलर मूल रूप से अलग-अलग असेम्बलर हैं जो अलग-अलग हैं जिन्हें आर्किटेक्चर कहा जाता है।
इसी तरह, अलग मशीन, अलग आर्किटेक्चर, अलग ऑपरेटिंग सिस्टम के कारण अलग कंपाइलर अलग असेंबली कोड का पालन करते हैं।
और फिर अलग हार्डवेयर, माइक्रोप्रोसेसर वास्तव में एक ही विधानसभा भाषा प्रोग्रामिंग से अलग मशीन स्तर कोड का पालन करते हैं।
तो, कोडांतरक .c या में लिखे गए एक उच्च-स्तरीय कार्यक्रम को परिवर्तित कर देगा। C ++ के लिए cpp और फिर अंत में, एक ऑब्जेक्ट फ़ाइल का निर्माण करें।
और, कभी-कभी ये ऑब्जेक्ट फ़ाइल कुछ पुस्तकालयों की मदद ले सकती हैं या कार्यक्रम में निर्माण कर सकती हैं।
तो, यह एक अंतर्निहित कार्यक्रम है जिसे लिंक करने की आवश्यकता है और अंत में, निष्पादन योग्य फ़ाइल बनाई जाएगी।
तो, यह हमारे लिए पारंपरिक C या C ++ प्रोग्रामिंग का तरीका है;
इसका मतलब है, प्रोग्राम लिखने से लेकर प्रोग्राम क्रिएट करने तक।
अब, हम उसी चीज़ को देखते हैं कि यह सिस्टम, पर्यावरण में कैसे काम करता है;
यह वास्तव में बहुत आसान है।
यह इतना जटिल कार्य नहीं है, बल्कि यह मूल रूप से जावा फाइल प्रोग्राम है जो जावा में लिखा गया है। जावा फ़ाइल और फिर एक संकलक है।
यह संकलक एक ही संकलक है, मशीन के बारे में क्या आप एक मुद्दे का उपयोग नहीं करते हैं।
यह संकलक में अनुवाद करेगा। कक्षा फ़ाइल,। प्रौद्योगिकी में वर्ग फ़ाइल को प्रोग्राम कहा जाता है जो बाइनरी फॉर्म में नहीं है या मशीन स्तर कोड में नहीं है बल्कि यह कोड के रूप में है इसे बाइट कोड कहा जाता है।
यह एक मशीन स्तर कोड की तरह 1 0 0 0 1 1 जैसा दिखता है, लेकिन इसके प्रारूप इसका सिंटैक्स बिल्कुल अलग है।
तो, यह बाइट कोड है, बाइट कोड अब हम कह सकते हैं कि कार्यकारी कोड है;
तब इन बाइट कोड को चलाने के लिए हमें एक दुभाषिया की आवश्यकता होती है।
तो, मूल रूप से, यह एक है जिसे दुभाषिया कहा जाता है, एक दुभाषिया और दुभाषिया, जैसा कि आप जानते हैं कि दुभाषिया मूल रूप से एक कोड लेता है, इसे चलाएं और फिर अगले भाग पर जाएं जैसे कि यह।
तो, यह एक व्याख्यात्मक मोड है, यह नहीं है कि जिस तरह से संकलक और फिर कार्यकारी कोड अंत में, इस मशीन के लिए निर्मित होता है और फिर यह निष्पादित करेगा।
अब, यहाँ आप सोच सकते हैं कि यहाँ C या C ++ में सब कुछ है
मूल रूप से संकलन जबकि, दो चीजों के मामले में दोनों व्याख्याएं हैं और साथ ही एक संकलन भी हैं।
तो, यह आधे रास्ते को बाइट कोड में प्रोग्राम को संकलित करता है और फिर अगले आधे रास्ते में यह मूल रूप से बाइट कोड को संबंधित मशीन में निष्पादित करता है।
तो, इस बारे में यह विचार कि यह बायोटेक जो उत्पादन किया जाएगा, यह एक काल्पनिक मशीन को लक्षित कर रहा है, भले ही यह वहां की वास्तुकला के बावजूद हो।
और, प्रत्येक वास्तुकला के लिए दुभाषिया एक संगत दुभाषिया है।
तो, इन दुभाषियों को पता है कि यदि यह एक बाइट कोड है तो इस के साथ कैसे काम करना है और फिर पर्यावरण के मामले में मशीन की स्वतंत्रता यहां बनी हुई है।
तो, यह दो अलग-अलग प्रोग्रामिंग अवधारणाओं के निष्पादन के बारे में विचार है, उदाहरण के लिए, C C ++ और इस चीज़ के अलावा कुछ और अंतर हैं।
इसलिए, अब तक दो प्रोग्रामिंग भाषाएं दोनों ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग लैंग्वेज C + + और Java हैं, मैं जल्दी से यहां मौजूद विभिन्न कॉन्सेप्ट को संक्षेप में प्रस्तुत करूंगा। वही।
उदाहरण के लिए, C ++ आमतौर पर पुस्तकालय प्रबंधन प्रणाली, कर्मचारी प्रबंधन प्रणाली जैसे एक बहुत बड़े सॉफ्टवेयर को विकसित करने के लिए बेहतर है, फिर इस तरह एक यात्री रेलवे आरक्षण प्रणाली।
जबकि इसका उपयोग इन सभी प्रकार की प्रणालियों को विकसित करने के लिए किया जा सकता है, लेकिन इसके अतिरिक्त यह एक बहुत ही खास प्रोग्रामिंग है
भाषा जो विशेष रूप से संचार या इंटरनेट अनुप्रयोग संबंधित सॉफ्टवेयर विकास को विकसित करने के लिए उपयुक्त है।
उदाहरण के लिए, यदि आप नेटवर्किंग तकनीक विकसित करना चाहते हैं, नेटवर्किंग में कई प्रोटोकॉल विकसित करना चाहते हैं तो आपको C ++ के बजाय उपयोग करना चाहिए।
इंटरनेट प्रोग्रामिंग के लिए;
इसका मतलब है, ब्राउज़र कैसे काम करता है, रिमोट डेस्कटॉप कैसे काम कर सकता है;
ये सभी चीजें सबसे उपयुक्त हैं।
यदि आप वेब पेज को विकसित करना चाहते हैं, तो वेब पेज एक बहुत ही सामान्य बात है आजकल कई संगठन हैं जो किसी भी जानकारी और फिर कई सेवाओं सहित अपने वेब पेजों को बनाए रखते हैं।
इसलिए, वेब सेवाएं, उदाहरण के लिए, बैंक और सब कुछ।
तो, जिस वेबपेज को आप विकसित कर सकते हैं और फिर वेब ब्राउज़र भी;
इसका मतलब है, यह किसी भी वेबपेज को ब्राउज़ करेगा यदि यह इंटरनेट या www पर उपलब्ध है।
तो, ये प्रोग्रामिंग हैं जो आप प्रोग्रामिंग का उपयोग करके बेहतर कर सकते हैं और सी ++ में कभी-कभी वे संभव या संभव नहीं हैं।
इसलिए, ये कार्य में अंतर है कि दो प्रोग्रामिंग भाषाएं हैं।
तो, ये प्रोग्रामिंग हैं जो आप प्रोग्रामिंग का उपयोग करके बेहतर कर सकते हैं और सी ++ में कभी-कभी वे संभव या संभव नहीं हैं।
अब, यहाँ मैंने कुछ महत्वपूर्ण बातों का उल्लेख किया है जो C ++ में संभव हैं और जो इसके विपरीत संभव नहीं हैं।
अब इसलिए, एनकैप्सुलेशन के लिए, हमने चर्चा की है कि एक वस्तु-उन्मुख प्रोग्रामिंग है और एनकैप्सुलेशन एक प्रोग्रामिंग सुविधा है।
इसलिए, C ++ दोनों और एनकैप्सुलेशन प्रदान करता है और इसका मतलब है, वे हमें अपनी क्लास फाइल विकसित करने की अनुमति देते हैं।
बहुरूपता यदि आप दोनों सी ++ देखते हैं और ए प्रदान करते हैं
बहुरूपता और बंधन;
इसका मतलब है कि, अलग-अलग कार्य या विधियों के डेटा को कैसे अलग किया जा सकता है।
बंधन नामक एक अवधारणा है और दो प्रकार के बंधन हैं;
स्थैतिक और गतिशील दोनों प्रकार की बाध्यकारी संभव है और साथ ही C ++ में भी।
और, फिर यहाँ वंशानुक्रम C ++ और Java में थोड़ा अलग है।
C ++ सपोर्ट दोनों सिंगल होने के साथ-साथ मल्टीपल हैं, मल्टीपल एक बहुत ही जटिल इनहेरिटेंस मैकेनिज्म है।
दूसरी ओर, कई विरासतों का समर्थन नहीं करता है, केवल एक विरासत का समर्थन करता है।
और, फिर ऑपरेटर ओवरलोडिंग यह एक और महत्वपूर्ण बात है;
इसका मतलब है, कि अलग-अलग ऑपरेटर, उदाहरण के लिए, प्लस-प्लस का उपयोग दो संख्याओं को जोड़ने के लिए किया जा सकता है, प्लस का उपयोग इस तरह के दो दस्तावेजों को जोड़ने के लिए किया जा सकता है;
यह वास्तव में एक बहुलक प्रिंट अवधारणा है।
तो, ऑपरेटर ओवरलोडिंग बहुरूपता की एक अवधारणा है।
C ++ ऑपरेटर को ओवरलोडिंग की अनुमति देता है जबकि, Java ऑपरेटर को ओवरलोडिंग की अनुमति नहीं देता है।
और, फिर टेम्पलेट क्लास इन मूल रूप से C ++ टेम्पलेट क्लास की अनुमति देते हैं;
इसका मतलब है, एक टेम्पलेट का मतलब है बुनियादी वर्ग विकसित किया जा सकता है जो मूल रूप से एक वस्तु बनाने के लिए उपयुक्त नहीं है, लेकिन यह केवल एक टेम्पलेट है।
लेकिन जावा टेम्पलेट क्लास बनाने के लिए कोई सुविधा नहीं देता है।
पॉइंटर जैसी कुछ और चीजें हैं।
जावा में पॉइंटर संभव नहीं है जबकि, C ++ में पॉइंटर संभव है।
और, इंटरफ़ेस और पैकेज जावा इसके बारे में एक बहुत अच्छी सुविधा है जबकि, C ++ में नहीं है।
अब, यहाँ हम कई चीजें देख सकते हैं;
उदाहरण के लिए कई चीजें, यहां C ++ में, जबकि जावा, उनके पास नहीं है और कुछ चीजें हैं, निश्चित रूप से, जावा के पास C ++ नहीं है।
अब यहाँ स्पष्ट रूप से, मैंने आपको बताया कि इसके पीछे क्या कारण है।
कारण यह है कि जावा हम एक उपयोगकर्ता के अनुकूल एक प्रोग्रामिंग वातावरण विकसित करना चाहते हैं।
एक उपयोगकर्ता प्रोग्रामिंग उपयोगकर्ता के अनुकूल वातावरण बनाने के लिए जावा डेवलपर कई जटिल विशेषताओं को नीचे करता है जो मूल रूप से बहुत सी त्रुटियों से जुड़े होते हैं;
प्रोग्राम की सूची में प्रोग्राम की बहुत सारी त्रुटियां जो एक मजबूत प्रोग्राम या विश्वसनीय प्रोग्राम नहीं है।
इसलिए, कुछ सुविधाओं को समाप्त करना जो बहुत जटिल और गलत हैं इसलिए, हम एक विश्वसनीय और मजबूत जावा प्रोग्रामिंग बना सकते हैं;
यह जावा प्रोग्रामिंग की सुंदरता है और यही कारण है कि जावा एक महान प्रोग्रामिंग भाषा बन गई है।
और एक और अंतर यह स्पष्ट रूप से वहाँ है एक और अंतर देखें सी ++ फिर से एक ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग है, लेकिन यह प्लेटफ़ॉर्म स्वतंत्र नहीं है।
इसका मतलब है कि विभिन्न संकलक को विभिन्न प्रोग्रामिंग भाषाओं में सी ++ कोड का अनुवाद करना आवश्यक है, जबकि, जावा एक प्लेटफ़ॉर्म स्वतंत्र प्रोग्रामिंग भाषा है, जिसका अर्थ है कि।
तो, जावा कोड एक बाइट कोड बनाएगा और फिर बाइट कोड की एक अलग प्रोग्रामिंग वातावरण में व्याख्या की जाएगी।
और इस तरह से मंच स्वतंत्र;
इसका मतलब है, जहाँ भी आप इसे चलाना चाहते हैं, उसी कोड को निष्पादित किया जा सकता है।
लेकिन यहां अलग प्रोग्रामिंग वातावरण में आपके उसी प्रोग्राम को चलाने के लिए अलग कंपाइलर की आवश्यकता होती है।
तो, यह दो प्रोग्रामिंग भाषाओं सी + + और जावा के बारे में विचार है और उनके बीच बुनियादी अंतर ठीक है।
इसलिए, हमने इस व्याख्यान में जावा में प्रोग्रामिंग के विभिन्न चरणों की प्रोग्रामिंग के बारे में विचार सीखा है और कैसे जावा प्रोग्रामिंग सी ++ या सी प्रोग्रामिंग या अन्य कार्यात्मक प्रोग्रामिंग अवधारणा से अलग है।
अब, अब तक हमने एक बहुत ही सरल कार्यक्रम पर चर्चा की है जिसमें केवल एक वर्ग शामिल है।
हमारे उदाहरण में, हमने HelloWorldApp.java नाम से एक वर्ग पर विचार किया है, लेकिन क्या यह संभव है कि एक कार्यक्रम में एक से अधिक वर्ग शामिल हो सकते हैं।
और, यदि इसमें एक से अधिक वर्ग हैं या नहीं, तो संकलन और निष्पादन के लिए समान तकनीकें हैं या नहीं या हमें विभिन्न अवधारणाओं का पालन करना है या नहीं।
और, यह भी कि एक ब्राउज़र जावा प्रोग्राम को कैसे निष्पादित कर सकता है;
उन जावा में दिलचस्प चीजें हैं।
इसलिए, इन सभी चीजों को हम अपने अगले व्याख्यान में शामिल करेंगे।
आपका बहुत बहुत धन्यवाद।
देवांश समता विभाग के कंप्यूटर विज्ञान और इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर लेक्चर - 36 एपलेट प्रोग्रामिंग - III में जावा में प्रोग्रामिंग, इसलिए हम एप्लेट के बारे में चर्चा कर रहे हैं।
और आखिरी मॉड्यूल में, हमने उन मानक तरीकों पर चर्चा की है, जिन्हें एक एप्लेट में शामिल किया जा सकता है।
अब, हम HTML अवधारणा के बारे में चर्चा करेंगे, जैसा कि आप जानते हैं कि किसी एप्लेट को स्वतंत्र रूप से निष्पादित नहीं किया जा सकता है।
इसलिए, एप्लेट देखने के लिए, हमें इस एप्लेट कोड को HTML पेज में होस्ट करना होगा।
और फिर इस HTML पेज को वेब एक्सप्लोरर या नेटस्केप नेविगेटर या हॉट जावा ब्राउज़र जैसे वेब ब्राउज़र के माध्यम से ब्राउज किया जाएगा।
और जावा JDK में, अंतर्निहित दर्शक भी है जिसे एपलेट दर्शक भी कहा जाता है।
अब, यह जो कुछ भी है, पहले विचार यह है कि एप्लेट को HTML पृष्ठ में HTML पृष्ठ द्वारा होस्ट किया जाना चाहिए।
इसलिए, इस मॉड्यूल में, हम देखेंगे कि HTML संपर्क का उपयोग करके यह होस्टिंग कैसे संभव है।
दरअसल, एक विशिष्ट टैग जो HTML में है;
HTML का अर्थ है HyperText Markup Language को एप्लेट टैग कहा जाता है।
तो, हमें यहां एप्लेट टैग के बारे में चर्चा करनी होगी।
अब, एप्लेट टैग मूल रूप से आइए पहले देखते हैं कि आमतौर पर HTML पेज कैसा दिखता है।
अब, आप देख रहे हैं कि HTML एक मूल टैग-आधारित है जैसा कि हमने कहा, अब यह है
मूल रूप से HTML, और यह अंत है।
तो, ये टैग हैं, इसे HTML टैग कहा जाता है इसका मतलब है कि यह इंगित करता है कि यह HTML पृष्ठ 1 है।
इसलिए, यदि यह टैग है और फिर ब्राउज़र इसका उपयोग करता है तो कोई समस्या नहीं है, ब्राउज़र को यहां रिक्त पृष्ठ दिखाई देगा, क्योंकि इस टैग में यह कुछ भी नहीं है।
अब, अगला जो हम कर सकते हैं वह है सिर।
तो, सिर मूल रूप से हम लिख सकते हैं, शीर्षक क्या है जो वहां होगा।
तो, सिर मूल रूप से एक HTML ब्राउज़र के साथ है, यह दिखाएगा, यहाँ ब्राउज़र दृश्य नहीं है।
इसलिए, यदि आप इसका उपयोग करते हैं तो एक साधारण HTML फ़ाइल, ब्राउज़र यह दिखाएगा।
और फिर इस शरीर के भीतर, हमारे पास एक पाठ है एक हेडर 1 है, हेडर 1 एक बहुत बड़ा फ़ॉन्ट है बड़ा फ़ॉन्ट।
तो, यह हेडर फ़ॉन्ट में यहाँ प्रदर्शित करेगा।
अब, आप देखते हैं कि हम जिस अलग टैग का उपयोग कर रहे हैं, इसलिए यह एक और टैग बी है। तो, बी टैग इंगित करता है कि, यह एक बोल्ड के साथ-साथ आई टैग को प्रदर्शित करने के लिए कुछ फ़ॉन्ट प्रदर्शित करेगा।
तो, यह मूल पाठ बोल्ड और इटैलिक रूप में प्रदर्शित किया जाएगा।
अगला टैग एच 2 है, एच 2 मूल रूप से पाठ छोटा टैग है।
और यहाँ H 1 बहुत बड़ा फ़ॉन्ट नहीं है, H 2 थोड़ा छोटा मध्यम आकार का फ़ॉन्ट है, इसलिए यह यहाँ प्रदर्शित होगा।
और आप देखते हैं कि एक और रेफरी मूल रूप से लिंक है, इसलिए यह एक और टैग और फिर समापन टैग है।
इसलिए, हर टैग यहां शुरू हो रहा है और फिर वाक्य रचना बंद कर रहा है।
और फिर ये मूल रूप से लिंक को देखते हैं, जिसका अर्थ है कि यह हाइपरलिंक है यदि हम इसे करते हैं, तो यह और इस में मूल रूप से हाइपरलिंक है।
हाइपरलिंक का अर्थ है यदि हम इसे क्लिक करते हैं, तो यह वास्तव में इस लिंक पर जाएगा, इसका मतलब है कि यह ब्राउज़र को स्थानांतरित करता है इस पृष्ठ पर ध्यान केंद्रित करें इस पृष्ठ से किसी अन्य दूर के पृष्ठ पर।
फिर कई अन्य चित्र भी पाठ में शामिल किए जा सकते हैं।
और एक छवि को शामिल करने के लिए, इसलिए छवि img उसके लिए टैग है।
तो, ये मूल रूप से आपकी स्क्रीन पर इस तरह की छवि प्रदर्शित करते हैं।
और टिप्पणी यदि आप HTML में शामिल करना चाहते हैं, तो यह मूल रूप से टिप्पणी इस कोणीय, फिर विस्मयादिबोधक डॉट के भीतर शामिल किया जाएगा, और फिर यह बंद हो रहा है यह एक है।
इसलिए, ये कुछ टैग हैं जो मैंने यहां दिखाए हैं, ताकि केवल टैग का उपयोग करके HTML पृष्ठ को कैसे डिज़ाइन किया जा सके।
और ब्राउज़र मूल रूप से चलाया जाता है और HTML पेज।
इसलिए, HTML पेज चलाने वाला ब्राउज़र, यह मूल रूप से एक व्याख्यात्मक तरीके से है।
तो, यह मूल रूप से पहला टैग, फिर दूसरा टैग, अगला टैग और इसी तरह होगा।
जैसा कि यह व्याख्यात्मक है कि संकलन कुछ भी नहीं है।
इसलिए, अगर इन टैग्स में कोई गलती है, तो मान लीजिए कि एच 1 है, इसे बंद नहीं करना है, तो इसका मतलब है कि यह पूरी तरह से अनदेखा कर देगा।
इसलिए, ब्राउज़र कुछ भी अनदेखा नहीं करेगा, इसका मतलब यह नहीं है कि अगले भाग को निष्पादित नहीं किया जाएगा।
इसलिए, अगले भाग की व्याख्या और निष्पादन किया जाएगा।
तो, यह एक दुभाषिया है, और यह हर टैग को देखेगा, और हर टैग की व्याख्या करेगा, और फिर स्क्रीन पर प्रदर्शित या पेंट करेगा।
तो, मूल रूप से, ब्राउज़र वास्तव में एक खिड़की पर पेंट करेगा।
तो, यह मूल रूप से HTML पेज अवधारणा है, और एक और महत्वपूर्ण बात यह है कि HTML टैग जो भी आप कर सकते हैं वह एक मामला असंवेदनशील है चाहे पूंजी पत्र, छोटा पत्र, यह ब्राउज़र के लिए कोई फर्क नहीं पड़ता, ब्राउज़र इसे सही ढंग से करेगा।
तो, एक मामला ऐसा है कि क्या किसी ऊपरी मामले पर निचला मामला है कि वहाँ मुद्दा नहीं है;
इसलिए, इस तरह से HTML पेज को वहाँ निष्पादित किया जा सकता है।
अब, हमने विभिन्न टैग्स के बारे में चर्चा की है।
एक विशेष टैग है जिसे एप्लेट टैग कहा जाता है।
तो, यह विशेष टैग मूल रूप से उस कोड को शामिल करने के लिए है जिसे आप HTML पेज में शामिल करना चाहते हैं।
तो, टैग एक एप्लेट की तरह दिखता है, और यह कोड बताता है कि जावा एप्लेट प्रोग्राम के जावा क्लास कंपाइल वर्जन में क्लास फाइल क्या है।
और फिर यह मूल रूप से चौड़ाई और ऊंचाई है जिसका मतलब है, यह दर्शाता है कि विंडोज़ में एप्लेट का आकार कितना होगा जो ब्राउज़र आपके एप्लेट को प्रदर्शित करने के लिए ले जाएगा।
तो, ये बहुत मामूली एप्लेट टैग अवधारणा है जो वहां है।
और फिर आप इसका उपयोग कर सकते हैं, और आप ऐसा कर सकते हैं यदि आप इसे कर सकते हैं, तो आपका ब्राउज़र मशीन वर्तमान मशीन से आपके एपलेट को चला सकता है।
अब, इस बारे में विचार है, लेकिन वहाँ कुछ काज है कि अब एप्लेट इस अर्थ में बहुत कम अवहेलना है कि कई ब्राउज़र, वे तब तक समर्थन नहीं करते हैं जब तक आप उसके लिए एक विशेष प्लगइन का उपयोग नहीं करते हैं।
हालाँकि, क्रोम HTML पृष्ठ में किसी भी एप्लेट टैग को पूरी तरह से अनदेखा करता है।
संस्करण 4.0 तक इंटरनेट एक्सप्लोरर, यह समर्थन कर रहा था और उसके बाद, यह समर्थन करना बंद कर देता है।
यदि आप उसके लिए एक विशेष प्लगइन का उपयोग करते हैं तो मोज़िला समर्थन कर सकता है।
और यह नेटस्केप नेविगेटर है, यह हमेशा एक HTML पृष्ठ में एप्लेट कोड एप्लेट टैग का समर्थन करता है, जिसका अर्थ है, नेटस्केप नेविगेटर सफलतापूर्वक ब्राउज़ करें।
और ओपेरा एक अन्य ब्राउज़र भी है जो इसका समर्थन नहीं करता है।
इसलिए, कई ब्राउज़र वे प्लगइन के उपयोग के तहत सशर्त रूप से कई ब्राउज़र समर्थन का समर्थन नहीं करते हैं, चाहे वह कुछ भी हो।
तो, ये मूल प्रतिबंध हैं, और प्रतिबंध इस तरह के प्रतिबंध का एक निश्चित कारण है, मुख्य रूप से यह सुरक्षा के दृष्टिकोण से है।
इसलिए, कई ब्राउज़रों ने HTML में एप्लेट कोड का समर्थन करना बंद कर दिया है।
एप्लेट कोड में जो पैरामीटर होते हैं, वे कुछ ऐसे होते हैं जो कुछ विनिर्देशन वैकल्पिक होते हैं, और कुछ आवश्यक होते हैं।
वे वैकल्पिक हैं, जो वर्ग ब्रैकेट में लिखे गए हैं जैसे दिखते हैं।
इसलिए, उदाहरण के लिए, यह एप्लेट टैग प्रारंभिक है, और यह एप्लेट की शुरुआत है।
और वहां अगर आप देखते हैं कि कुछ हिस्से हैं जिन्हें आप शामिल कर सकते हैं, और फिर यह एप्लेट भाग में है;
इसलिए, यह बहुत महत्वपूर्ण है।
तो, यह और फिर घुंघराले
कोष्ठक मूल रूप से भिन्न पैरामीटर है जिसे एप्लेट टैग आपके एप्लेट के विशेष देखने के लिए निर्दिष्ट करने की अनुमति देगा।
तो, यह वहाँ है, और क्या खास बात है जो आप यहाँ देख सकते हैं।
और कोडबेस एक पैरामीटर है, अभिलेखागार उनके कोड हैं जिनके बारे में हम पहले ही चर्चा कर चुके हैं, फिर एक ऑब्जेक्ट, अल्ट, नाम, चौड़ाई, ऊंचाई, एलाइन, वेस्पेस, और हेस कुछ चीजें हैं जो हमारे पास हैं।
और इस परम नाम के अलावा भी कुछ चीजें हैं।
यदि परम नाम है, तो प्रत्येक पैरामीटर नाम के लिए अलग कोणीय कोष्ठक का उपयोग किया जाना चाहिए।
परम नाम शायद पैरामीटर या HTML पेज से एक एप्लेट में पासिंग इनपुट के लिए है, हमने चर्चा की है कि आप याद कर सकते हैं।
अब, यहाँ हम इस अलग विनिर्देश को देख सकते हैं जो एक एप्लेट के लिए संभव है, कुछ चीजें अनिवार्य हैं।
ये कोड, चौड़ाई और ऊंचाइयां हैं, ये अनिवार्य हैं इसका मतलब है, आपको इसे देना होगा।
यदि आप इसे नहीं देते हैं, तो आपके एप्लेट टैग को ब्राउज़र द्वारा सफलतापूर्वक निष्पादित नहीं किया जाएगा।
जबकि अन्य कोड आधारित, अभिलेखागार, वस्तु, ऊंचाई, नाम और संरेखित, ये सभी चीजें वैकल्पिक हैं।
और फिर परम नाम भी वैकल्पिक है, आपके पास हो सकता है आपके पास भी न हो।
तो, ये अलग-अलग टैग विनिर्देश हैं;
इसलिए, एप्लेट टैग के लिए चिंतित हैं।
अब, हमारी अगली कुछ स्लाइड्स में, हम देखेंगे कि एप्लेट टैग में प्रत्येक विनिर्देशन का अर्थ क्या है?
और जैसा कि मैंने आपको बताया कि HTML के विभिन्न संस्करण भी हैं।
और HTML5 आगे, एप्लेट टैग समर्थित नहीं है।
एप्लेट टैग के बजाय, उन्होंने कुछ अन्य अवधारणा का समर्थन किया, इसे ऑब्जेक्ट कहा जाता है, मैं इस बात पर चर्चा करूंगा।
इसलिए, हम आम तौर पर दोहरे उद्धरण में डालते हैं, लेकिन इसे लगाने की आवश्यकता है
हमेशा दोहरे उद्धरण।
तो, यहाँ एक उदाहरण है, इसलिए यह सही भी है, और यह सही भी है।
तो, ये कोड हैं और यह कोड और ऊंचाई और चौड़ाई के साथ अनिवार्य चीजें हैं।
अनिवार्य का मतलब है, आपको इसका उपयोग करना होगा बिना आप ऐसा नहीं कर सकते।
अब, हम कोडबेस की अवधारणा पर आते हैं।
तो, कोडबेस मूल रूप से आपके एप्लेट के आपके या आधार पते के सापेक्ष पते को दिखा रहा है।
अब, क्या वास्तव में यह विचार है कि यदि आप चाहते हैं कि मैं अपने स्थानीय के अलावा अपने स्थानीय से दूरी मशीन से अपनी श्रेणी की फ़ाइल आयात करूँ।
तो, ब्राउज़र किस मशीन से ब्राउज़ कर रहा है, इसे उस ब्राउज़र को स्थानीय कहा जाता है।
और यदि आप कुछ दूरस्थ मशीन रिमोट मशीन से एक्सेस करना चाहते हैं, तो एक ब्राउज़र के माध्यम से जो जुड़ा हो सकता है।
यहां एक उदाहरण दिया गया है कि https बताता है कि यह दूरस्थ रिपॉजिटरी का स्थान है, जहां यह क्लास फाइल है।
तो, इसका मतलब है कि आपका ब्राउज़र इस आकार से कनेक्ट हो जाएगा, और फिर यह जांचें कि क्लास फ़ाइल इसे आपके स्थानीय मशीन में आयात करती है, और फिर इस एप्लेट कोड को निष्पादित किया जाएगा।
इसलिए, एपलेट कोड को दूर से अपनी मशीन से निष्पादित करने के लिए आवश्यक नहीं है।
आमतौर पर, इंटरनेट प्रोग्रामिंग के मामले में, हम ऐसा कर रहे हैं।
आप अपने HTML पृष्ठ को दूरस्थ मशीन से आयात कर सकते हैं, और आयात का अर्थ है कि सभी वर्ग फ़ाइल एप्लेट, सभी छवि, सभी ऑडियो, वीडियो फ़ाइलें, जो भी आवश्यक हो।
आपकी ब्राउज़र मशीन में लाने की आवश्यकता है, और फिर इसे आपके ब्राउज़र में निष्पादित किया जाएगा
मशीन, तो कोडबेस उस उद्देश्य के लिए है।
हम स्पष्ट रूप से उल्लेख कर सकते हैं कि वह स्थान कहां है जहां आपकी कक्षा की फाइल है।
भले ही आप अपने स्थानीय मशीन में भी एक ही चीज का उपयोग करें, लेकिन यह है कि HTML फ़ाइल एक निर्देशिका से संबंधित है, जबकि वर्ग फ़ाइल अलग निर्देशिका से संबंधित है।
तो, आधार मूल रूप से यहां है, जो कि आधार निर्देशिका है और इस आधार के संबंध में, जो कि क्लास फाइल है जिसे आप उपयोग करना चाहते हैं।
तो, कोडबेस में यह भी है कि हम इसका उपयोग कर सकते हैं, लेकिन उस स्थिति में, हमें यहां फ़ाइल कमांड का उपयोग करना होगा।
तो, फ़ाइल और फिर निर्देशिका का स्थान, और फिर उस वर्ग फ़ाइल का नाम जिसे आप इसका उपयोग करना चाहते हैं।
तो, यह कोडबेस टैग का उपयोग है।
और संग्रह इस उद्देश्य के लिए है कि मान लीजिए मान लीजिए, जैसा कि मैंने आपको बताया कि एपलेट को आपके स्थानीय मशीन से देखा जा सकता है जिसमें दूरी मशीन से इसके तत्व होते हैं।
यदि आप ऐसा करना चाहते हैं, तो हर बार जब आप चाहते हैं कि कुछ चीजें आपके एप्लेट में शामिल हों, तो इसे आपकी रिमोट मशीन से जोड़ा जाना चाहिए और फिर इसे आयात करना होगा, और फिर इसे स्टोर करना होगा, और फिर प्रदर्शित करना होगा।
इसलिए, उस HTML पेज के लिए जो भी फाइलें आवश्यक हैं, उसके बजाय आप एक जार फ़ाइल में एक संग्रह में डाल सकते हैं जिसे यहां कहा जाता है, उदाहरण के लिए, HTML पृष्ठ के लिए आवश्यक सभी फाइलें एक जार फ़ाइल में डाली जा सकती हैं।
फिर जो ब्राउज़र यह करेगा वह यह है कि ब्राउज़र केवल एक बार रिमोट सर्वर से केवल एक ही कनेक्शन के साथ आयात करेगा, और फिर इसे एक स्थानीय मशीन में लाएगा।
और फिर इस जार फ़ाइल से जो भी फ़ाइल आवश्यक छवि या वीडियो, ऑडियो या किसी अन्य वर्ग की फ़ाइल है, उसे वहां से निकाला जाएगा और इसे इस पर भेजा जाएगा।
तो, यह संग्रह कमांड मूल रूप से उस बारे में एक विचार देगा जो जार फ़ाइल है जिसे देखने के जीवनकाल में केवल एक बार लाने की आवश्यकता है।
तो, यह एप्लेट कोड में संग्रह टैग विनिर्देश के बारे में एक विचार है।
और फिर आपत्ति।
जैसा कि मैंने आपको HTML5, और HTML के ऊपर वाले संस्करण के बारे में बताया, उन्होंने एप्लेट कोड का समर्थन करना बंद कर दिया है।
तो, उस स्थिति में मूल रूप से ऑब्जेक्ट कोड का उपयोग करने की अनुमति है।
तो, वस्तु कोड वास्तव में एप्लेट टैग के समान है;
इसलिए एक एप्लेट नहीं है।
तो, यहां मूल रूप से एप्लेट के बजाय समान है, आप उस वस्तु का उपयोग करते हैं जो सभी है;
तो, यह मूल रूप से के बारे में विचार है।
और अन्य कोड-आधारित, फिर चौड़ाई, ऊंचाई सब कुछ केवल उसी पर लागू होता है।
तो, एक ऑब्जेक्ट एप्लेट टैग का एक विकल्प है जो HTML पृष्ठ में नया संस्करण है।
और यहाँ फिर से यदि आप मान लेना चाहते हैं, तो आपको नहीं पता कि आपका ब्राउज़र समर्थन करेगा, चाहे एचटीएमएल 4 या एचटीएमएल 2 या एचटीएमएल 5 या ऊपर की ओर, कभी-कभी इसे छवियों के लिए अधिक मजबूत बनाने के लिए या किसी भी संस्करण के साथ संगत;
इसलिए कुछ HTML डिज़ाइनर ने दोनों वस्तुओं को एप्लेट कोड के रूप में उपयोग किया।
उदाहरण के लिए, एक ऑब्जेक्ट यहां है, और फिर एक एप्लेट कोड भी है।
इसलिए, यदि यह उदाहरण के लिए, HTML4 के लिए प्राप्त करता है, तो आप चाहते हैं कि आपका ब्राउज़र HTML4 का समर्थन करता है, तो ऑब्जेक्ट उस HTML ब्राउज़र पर लागू नहीं होगा।
तो, उस स्थिति में, आप इस एक का उपयोग कर सकते हैं;
इसलिए इन सभी को नजरअंदाज कर दिया जाएगा, लेकिन उस मामले में एक एप्लेट पर विचार किया जाएगा।
दूसरी ओर, एक और संस्करण जो एचटीएमएल 5 का समर्थन करता है, फिर एकमात्र वस्तु;
इसलिए, यह उस ब्राउज़र द्वारा नजरअंदाज कर दिया जाएगा, केवल इस हिस्से पर विचार किया जाएगा, और उस फ़ाइल को एप्लेट को सफलतापूर्वक ब्राउज किया जाएगा।
तो, यह इस बारे में विचार है कि ऑब्जेक्ट और एप्लेट दोनों को एक साथ मर्ज किया जा सकता है, ताकि यह आपके ब्राउज़र सिस्टम के साथ अधिक संगत हो सके।
और चौड़ाई और ऊँचाई जैसा कि मैंने आपको इस पैरामीटर को बदलकर ऊँचाई और चौड़ाई के विनिर्देश बताए हैं, हम आपके एप्लेट दृश्य का आकार बदल सकते हैं, और यह कि आपके एप्लेट से HTML पृष्ठ से ही किया जा सकता है, इसलिए ठीक है।
HTML देखने से पहले, इसलिए HTML को मल्टीमीडिया दस्तावेज़ में पाठ के एक सेट के सामने रखा जाएगा, जैसे कि इसमें ऑडियो, छवि और फिर वीडियो भी शामिल हो सकते हैं, हाइपरलिंक पाठ के अतिरिक्त, हम कह सकते हैं।
और फिर एप्लेट मूल रूप से इस पाठ के भीतर एक खिड़की है, यह ब्राउज़र के लिए चीजों पर एक जीवित के रूप में प्रकट होता है।
तो, उस स्थिति में, हम आपके प्रदर्शन के कुल दृश्य क्षेत्र की चौड़ाई और ऊँचाई को निर्दिष्ट कर सकते हैं, जो आपके एप्लेट को प्रदर्शित करने में लगेगा।
तो, यह चौड़ाई और ऊंचाई एक आवश्यक एक पैरामीटर ठीक है।
और फिर ऊंचाई।
मान लें कि आपका एप्लेट, आपकी क्लास फाइल में कुछ गलतियाँ हैं या कोई समस्या है कि वह इसे सफलतापूर्वक लोड नहीं कर पा रहा है, तो ब्राउज़र उपयोगकर्ता को कुछ संदेश दे सकता है।
तो, यहाँ संदेश है कि सभी विवरण के माध्यम से दिया जा सकता है।
मामले में, मान लें कि यह एक समस्या सही है, तो आपके ब्राउज़र को इस वर्ग को लाने या इस वर्ग फ़ाइल को निष्पादित करने की समस्या का सामना करना पड़ता है, तो यह वहां होगा;
अन्यथा, यह निष्पादित नहीं किया जाएगा।
तो, यह मूल रूप से उपयोगकर्ताओं को पृष्ठ देखने के बारे में अच्छी बातचीत या इंप्रेशन देने के लिए है।
तो, वहाँ पर ऑल स्टेटमेंट का उपयोग किया जाता है।
तो, ऑल्ट मूल रूप से इस दोहरे उद्धरण के भीतर एक वैकल्पिक पाठ है जिसका उपयोग किया जा सकता है।
और आप एक चीज़ यहाँ देखिये ये सभी चीजें इस एप्लेट टैग के भीतर होंगी, जो कुछ भी इस कोडबेस, कोड, ऊँचाई, चौड़ाई, ऊँचाई, नाम जो भी वहाँ है।
वे इस एप्लेट स्थिति के भीतर हैं और अंत में, इसे अंतिम एपलेट टैग कहा जाता है।
आगे नाम है।
और अपने HTML पेज में, आप एक ही HTML पेज में कई एप्लेट का उपयोग कर सकते हैं या कभी-कभी एप्लेट का उपयोग एक वितरित प्रोग्रामिंग सिस्टम में भी किया जा सकता है।
अपनी मशीन से, आप एक एप्लेट चला रहे हैं।
एक अन्य मशीन से, एक अन्य उपयोगकर्ता, एक और एप्लेट चलाने वाले और दोनों एप्लेट्स को एक दूसरे से संचार करने की आवश्यकता होती है।
और इस संचार के लिए, ताकि वास्तव में एक विनिर्देश जो आवश्यक हो कि कौन से एप्लेट्स का मतलब है कि एक का मतलब है, प्रत्येक एप्लेट्स की अपनी पहचान होनी चाहिए;
इस पहचान का नाम के माध्यम से उल्लेख किया जा सकता है।
इसलिए, नाम एक विनिर्देश है जो वहाँ है जिसके द्वारा हम निर्दिष्ट कर सकते हैं कि यदि प्रत्येक एप्लेट का अपना विशिष्ट नाम है।
और फिर इस नाम से एप्लेट प्रोग्रामिंग में एप्लेट प्रोग्रामिंग को विधि का उपयोग करके एप्लेट का नाम समझा जा सकता है, और यह कहने के तहत कुछ संचार स्थापित किया जा सकता है या कुछ संचार प्रोटोकॉल को लागू किया जा सकता है, इसीलिए यह नाम उस विनिर्देश एप्लेट में रहा है।
और फिर इसलिए नाम getApplet विधि द्वारा प्राप्त किया जा सकता है नाम ठीक नहीं है।
और VSPACE और HSPACE मूल रूप से इस कहावत का उपयोग करते हैं, यह आपके कुल HTML पृष्ठ का कुल HTML दृश्य है।
और कुछ पाठ जैसे, और यहाँ भी कुछ पाठ जैसे और जहाँ आप अपने एप्लेट को मान लेना चाहते हैं।
अब, VSPACE, HSPACE मूल रूप से कितना अंतर है जो आप पाठ और इस एप्लेट के बीच देना चाहते हैं।
और इसलिए यह मूल रूप से VSPACE है।
इसी तरह, यदि कोई अन्य पाठ है, तो यह वहां है या कोई अन्य एप्लेट है जहां आप इसे रखना चाहते हैं, तो मूल रूप से HSPACE का अर्थ है कि वह अंतर जो आप पाठ या इस एक के बीच अनुमति देना चाहते हैं।
तो, मूल रूप से VSPACE है, HSPACE पूरी तरह से कहता है कि इसके अलावा एप्लेट दृश्य है, यह चौड़ाई और ऊंचाई मूल रूप से कितनी जगह है जो आप इसे करना चाहते हैं।
कभी-कभी इसे मूल रूप से एप्लेट्स की एक अच्छी छाप के लिए उपयोग किया जाता है, और फिर इस एप्लेट्स की एक कलात्मक प्रस्तुति होती है कि इसमें HTML है जिसे इस VSPACE, HSPACE कमांड का उपयोग करके नियंत्रित किया जा सकता है।
और पैरामीटर नाम परम एक और महत्वपूर्ण पैरामीटर है, बड़े पैमाने पर इस्तेमाल किया जाने वाला एक पैरामीटर जो एप्लेट को इनपुट निर्दिष्ट करने के लिए आवश्यक है क्योंकि आप जानते हैं कि एप्लेट ब्राउज़र मशीन से प्रत्यक्ष इनपुट नहीं ले सकता है या दूरी मशीन से भी प्रत्यक्ष इनपुट नहीं ले सकता है।
इसलिए, यदि आप अपने एप्लेट में कोई इनपुट पास करना चाहते हैं, तो एचटीएमएल पेज में पैरामीटर नामों का उल्लेख किया जाएगा।
अब, सिंटैक्स इस तरह है।
टैग विनिर्देश को पैरामीटर, पैरामीटर का नाम कहा जाता है।
उदाहरण के लिए, इस उदाहरण में, जैसा कि हम देखते हैं फ़ॉन्ट का नाम एक का नाम है
पैरामीटर, और मूल्य मूल रूप से कूरियर है, तो इसका मतलब है कि, यह पैरामीटर है मान का नाम कूरियर है।
फिर फ़ॉन्ट का आकार एक और पैरामीटर है, जिसका मूल्य वर्तमान में 14 है।
नाम छवि स्रोत है, मान मूल रूप से फ़ाइल स्थान है।
और फिर नाम एक और है कि ऑडियो स्रोत, मूल्य यह एक है।
इसलिए, यहां हम देख सकते हैं कि ये अलग-अलग पैरामीटर हैं, जिनके मूल्य इस तरह हैं, जिन्हें हम इस HTML पेज से इस एप्लेट में तब देना चाहते हैं जब यह निष्पादन में हो।
इसलिए, जब भी एप्लेट अपना निष्पादन शुरू करते हैं, तो यह इस HTML एप्लेट कोड में वहां जो भी पैरामीटर निर्दिष्ट किया जाता है, वह यहां से मूल्य प्राप्त करेगा, और यह इसका उपयोग करेगा।
तो, इस उद्देश्य के लिए पैरामीटर कॉन्सेप्ट परम टैग वहाँ परिभाषित किया गया है।
और यह टैग आप देखते हैं कि यह एक एप्लेट है, एक एप्लेट है, यह एप्लेट हिस्सा है।
हाँ, यह मूल रूप से एप्लेट टैग है, लेकिन इस एप्लेट टैग के भीतर, अलग पैरामीटर टैग का उल्लेख किया जाना है।
तो, और फिर पूरी चीजें मूल रूप से HTML पेज के लिए एप्लेट टैग होंगी।
अब, परम नाम, तो कैसे एक एप्लेट इन मूल्यों को प्राप्त कर सकते हैं।
तो, इस उद्देश्य के लिए, प्राप्त पैरामीटर विधियां एप्लेट वर्ग में परिभाषित की गई हैं, और जिसे इसके लिए कहा जा सकता है।
और फिर इन मूल्यों को HTML से ही प्राप्त किया जा सकता है।
इसलिए, यदि आप अपनी मशीन से इस मान को बदलते हैं, और फिर यह आपके एप्लेट्स के लिए अलग-अलग मान प्रदर्शित करेगा।
अब, इस एक के उपयोग को स्पष्ट करने के लिए एक उदाहरण देखते हैं।
और यह माना जाता है कि HTML पृष्ठ जिसे आपने परिभाषित किया है, और मेरी कक्षा .class हमारा एप्लेट है, जो मूल रूप से इस मूल्य से इनपुट लेना चाहता है।
और फिर एप्लेट कोड कैसे होगा।
अब, यहाँ एप्लेट कोड है जो इस तरह दिखता है यदि आप देखते हैं कि पैरामेडेमो एप्लेट का नाम है, जिसे आप इसे प्रदर्शित करने जा रहे हैं, और ये अलग-अलग पैरामीटर हैं जिन्हें इस वर्ग का क्षेत्र कहा जाता है जैसे कि फॉन्टनेम, फोंटाइज, अग्रणी , सक्रिय।
ये सभी वे चर हैं जैसा कि हमने एक कक्षा में घोषित किया है;
इसलिए यह वर्ग के सदस्य हैं।
और यहाँ आप देखते हैं कि विधियाँ शुरू होती हैं या तो मूल रूप से या तो यह प्रारंभ विधि में होती हैं या विधि को आरंभ करती हैं, आप मूल्य पढ़ सकते हैं।
तो, यहाँ, इस मामले में, हम प्रारंभ विधि या इस तरह से मान पढ़ सकते हैं।
अब, जैसा कि आप सभी पैरामीटर मान देखते हैं जो HTML पृष्ठ से पढ़ा जाएगा, वे एक स्ट्रिंग से पढ़ेंगे।
तो, स्ट्रिंग का नाम परम और पढ़ने दो।
और फिर इस पैरामीटर स्ट्रिंग से, हम एक अलग रूप में परिवर्तित कर सकते हैं।
तो, एक गेट पैरामीटर फ़ॉन्ट नाम है, जो कि एक HTML पृष्ठ में है, आपको यह मिलेगा और फिर फ़ॉन्ट नाम होगा।
तो, यह मूल पैरामीटर है जो एक कूरियर से फ़ॉन्ट नाम, फ़ॉन्ट नाम है।
तो, मान होगा, इसलिए फ़ॉन्ट नाम वर्तमान में कूरियर है।
और यह मूल रूप से ट्राइ-कैच का उल्लेख किया गया है, यदि मान लिया जाए, तो यह मान इस तरह के HTML पृष्ठ में मौजूद नहीं है।
और फिर इसलिए एक और परम है यदि आप पूर्णांक में भी बदलना चाहते हैं, क्योंकि यह एक स्ट्रिंग के रूप में पढ़ा जाता है, इसलिए हम पूर्णांक में बदल सकते हैं।
तो, पूर्णांक वर्ग, फिर वर्तमान, यह स्ट्रिंग को पूर्णांक में परिवर्तित करेगा, इसलिए फ़ॉन्ट आकार, और फिर यह एक ठीक है।
अब, इस तरह विभिन्न मापदंडों के रूप में, पाठ के कुछ और हिस्से हैं जो वहां हैं, कोड है।
विभिन्न मापदंडों को पढ़ा जा सकता है इसका उपयोग पैरामीटर विधि है।
अब, अन्य पैरामीटर भी पैरामीटर को अग्रणी बनाते हैं और फिर सक्षम करने के लिए पैरामीटर खाता प्राप्त करते हैं।
ये सभी मान HTML पेज से पढ़े जाएंगे।
और फिर एक बार जब मूल्य आपके एप्लेट में लोड हो जाता है, और फिर हम उन्हें आपके पेंट विधि में उपयोग कर सकते हैं;
तो, यहाँ पेंट विधि है।
और आप देखते हैं कि जो भी मूल्य हम पढ़ सकते हैं, वह एचटीएमएल पेज से फ़ॉन्ट नाम, फ़ॉन्ट आकार, पढ़ने और सक्रिय है।
और फिर उन्हें इस मामले की तरह स्क्रीन पर मुद्रित किया जा सकता है, और फिर यदि आप HTML ऐप का उपयोग करके इस एप्लेट को चलाते हैं जो हमने पहले दिखाया है, तो यह मूल रूप से यह पसंद करेगा।
इसलिए, हम यहां यह कहना चाहते हैं कि जो भी पैरामीटर हैं, हम एक HTML पेज से एक एप्लेट में पास करना चाहते हैं, उन्हें विशेष टैग विनिर्देश द्वारा परम कहा जाने वाले एपलेट टैग के भीतर HTML पेज में ही एम्बेड किया जा सकता है।
तो, इस तरह हम पैरामीटर पास कर सकते हैं और हम इसे इस तरह से चला सकते हैं।
इसलिए, आमतौर पर HTML पेज डिजाइनर के पास विभिन्न मूल्यों को पारित करने के लिए यह प्रावधान है या कई अन्य तरीके भी हैं, यह वहां हो सकता है।
एप्लेट एक एप्लेट आकार खोजने;
अब कभी-कभी एप्लेट के आकार के साथ बातचीत करना आवश्यक होता है जो कुछ स्थितियाँ, तो हमें यह जानना होगा कि एप्लेट का वर्तमान आकार क्या है।
तो, एप्लेट के वर्तमान आकार को एक अन्य विधि का उपयोग करके समझा जा सकता है जिसे गेट आकार कहा जाता है, जो कि एप्लेट विधियों में परिभाषित किया गया है।
तो, यह मूल रूप से एप्लेट के आकार को प्राप्त करता है।
अब, एक अन्य विधि भी है एक एप्लेट में भी मूल रूप से शो स्टेटस विधि कहा जाता है।
और यहाँ एक सरल उदाहरण है, कैसे इस स्थिति का उपयोग किया जा सकता है।
यहाँ आप देख रहे हैं कि इस पद्धति का उपयोग यहाँ स्थिति दिखाने के लिए किया जा सकता है, और यह स्ट्रिंग है।
और अगर आप इस एप्लेट को चलाते हैं, तो यह मूल रूप से इस स्टेटस बार में दिखाता है कि यह स्टेटस विंडो में दिखाया गया है जैसे।
और हम देखते हैं कि पहले HTML फ़ाइल हमेशा एक एप्लेट को निष्पादित करने के लिए आवश्यक है, जिसका अर्थ है, जैसा कि मैंने उल्लेख किया है कि HTML कोड होना चाहिए, एक HTML फ़ाइल है, लेकिन एक चाल है कि चालें मूल रूप से HTML एपलेट टैग हो सकती हैं सीधे जावा प्रोग्राम में ही एम्बेड किया जाए।
और फिर इसका उपयोग वास्तव में एप्लेट दर्शक द्वारा किया जा सकता है।
अब, यह यहाँ क्या नीति है, इसका मतलब है, जो भी एप्लेट टैग है, वह वहाँ है?
आप बस HTML फ़ाइल के बाद लिखते हैं, उसके बाद या उससे पहले जो कुछ भी वहाँ है जैसा कि कोई समस्या नहीं दिखाई गई है।
फिर उसी .java फ़ाइल का उपयोग किया जा सकता है, इसलिए दो फ़ाइलों को बनाए रखने की कोई आवश्यकता नहीं है।
एक .java फ़ाइल या .class, और फिर .html है, लेकिन केवल एक .java, और फिर संबंधित वर्ग फ़ाइल का अनुपालन संस्करण होना चाहिए।
अब, यहां एक उदाहरण है जैसा कि आप यहां देख सकते हैं, यह एप्लेट प्रोग्राम है जिसे हम पहले से ही जानते हैं;
तो, यह .java फ़ाइल है।
और यहां HTML कोड है, जो मूल रूप से इसे होस्ट करने के लिए है।
अब, मैं केवल एक फ़ाइल को बनाए रख सकता हूं, और फिर फ़ाइल का नाम .java है।
तो, यह है .java स्टेटस विंडो हो सकती है .java एप्लेट फ़ाइल का नाम है इसे संकलित करें।
अब, जब भी आप संकलन के लिए जाते हैं, तो इस टिप्पणी के भीतर वे चीजें शामिल हैं जिनका अर्थ है, आपका संकलक जावा संकलक इस पर ध्यान नहीं देगा।
दूसरी ओर, जब भी कोई एप्लेट दर्शक उनके पास आएगा, एप्लेट व्यूअर इन सभी रास्तों को नजरअंदाज कर देगा, क्योंकि एप्लेट दर्शक इस टैग के बारे में समझ नहीं सकता है और केवल इसे अनदेखा करता है।
लेकिन, जो कुछ भी अंश है, एप्लेट दर्शक इसे समझ सकते हैं, और फिर व्याख्या की जा सकती है।
इसलिए, यदि हम उदाहरण के लिए एप्लेट व्यूअर का उपयोग करते हैं, तो यहां एप्लेट व्यूअर स्टेटस विंडो .java चलाएं।
तो, यहाँ आपको .java लिखना है, यह एक मूल फ़ाइल है।
तो, एप्लेट दर्शक इसे ब्राउज़ करेगा, और फिर प्रदर्शित किया जाएगा।
तो, केवल एक HTML फ़ाइल जिसे आप केवल एक डॉट फ़ाइल की योजना बना सकते हैं। केवल जावा फ़ाइल को बनाए रखा जा सकता है, और फिर स्पष्ट रूप से। Html फ़ाइल को बनाए रखने की आवश्यकता नहीं है।
तो, इस विचार के बारे में है और कई प्रोग्रामर ऐसा करना पसंद करते हैं, कोड HTML टैग क्या है यह आवश्यक है, वे केवल टिप्पणी लाइनों के भीतर .java फ़ाइल में उपयोग करते हैं;
तो यह एक है।
और दूसरा यह है कि यह ग्राफिकल यूजर इंटरफेस बनाने का एकमात्र तरीका है या कई अन्य तरीके हैं।
हमारी अगली चर्चा में, हम AWT द एब्सट्रैक्ट वाइंडिंग टूल किट के बारे में चर्चा करेंगे।
अमूर्त विंडोिंग टूल किट हमें अपना कोड यहाँ शामिल करने की अनुमति देता है।
तो, इस एक का उपयोग करके भी आप इसे कर सकते हैं, लेकिन इस अमूर्त विंडो टूल किट के बारे में, हम इन सभी बातों पर विस्तार से चर्चा करेंगे।
तो, इसका मतलब यह है कि आपके कार्यक्रम में, आप एक आवेदन की तरह लिख सकते हैं, यह वास्तव में एक एप्लेट नहीं है।
लेकिन, यह एक एप्लेट जैसा दिखता है, इसे मूल रूप से फ्रेम या पैनल कहा जाता है, और यह पैनल मूल रूप से एक विंडोज़ प्रोग्रामर है।
तो, ये विंडोज़ प्रोग्राम का एक और संस्करण है, जो एक AWT प्रोग्रामिंग के रूप में आ सकता है।
और इस तरह हम एप्लेट्स के अलावा एक और विंडो प्रोग्राम चला सकते हैं।
तो, AWT वास्तव में एप्लेट प्रोग्रामिंग का एक विकल्प है।
और AWT प्रोग्रामिंग के बारे में एप्लेट, हम अपने अगले मॉड्यूल पर आगे चर्चा करेंगे।
और फिर जावा एडब्ल्यूटी अवधारणा में एक और प्रोग्रामिंग अवधारणा पर चर्चा करेंगे।
आपका बहुत बहुत धन्यवाद।
कम्प्यूटर प्रोफ़ेसर और इंजीनियरिंग इंडियन इंस्टिट्यूट ऑफ़ टेक्नोलॉजी, खड़गपुर लेक्चर के जावा प्रो। देबासीस सामंता विभाग में प्रोग्रामिंग - 58 केस स्टडी - III आइए हम इस पाठ्यक्रम में सीखी गई अवधारणाओं को लागू करने के लिए कुछ और परियोजनाओं के बारे में जारी रखें।
अब, यह तीसरा केस स्टडी है, यहां भी हम दो परियोजनाओं पर चर्चा करेंगे।
पहला प्रोजेक्ट है कि हम एक उन्नत कैलकुलेटर के प्रति व्यवस्थित डिजाइन के बारे में चर्चा करने जा रहे हैं।
अब, हमारे पास पहले से ही एक विचार है कि कैलकुलेटर को कैसे डिज़ाइन किया जा सकता है।
और अब हमने इस बारे में चर्चा की कि कैसे अधिक उन्नत कैलकुलेटर विकसित करने के लिए इसे लागू किया जा सकता है।
इसलिए, पहला चरण जिसे हम साधारण विशेषताओं का उपयोग करके एक साधारण कैलकुलेटर को डिजाइन करने के बारे में विचार करेंगे, यह परियोजनाओं की शुरुआत है।
और फिर हम धीरे-धीरे कुछ और सुविधाओं को जोड़ने की कोशिश करेंगे, उदाहरण के लिए, कुछ और कार्यक्षमताएं, अधिक संचालन, समीकरण, अन्य।
और फिर अंत में, हम एक उन्नत कैलकुलेटर विकसित करेंगे जिसमें इस तरह की जटिल कार्यक्षमताएँ होंगी जैसे कि ब्रैकेटेड एक्सप्रेशन का उपयोग करके, और फिर कुछ अन्य भी।
और फिर अनुकूलन की गुंजाइश, शैलियों और सब कुछ सेट करना।
तो, आइए हम परियोजनाओं के प्रवाह, विभिन्न चरणों या परियोजना के संस्करणों के बारे में चर्चा करें।
पहले संस्करण में, जैसा कि आप इस तरह की परियोजनाओं से बहुत परिचित हैं, और हमने ऐपलेट का उपयोग करके इस तरह की परियोजना विकसित की है, आप यह कर सकते हैं कि यह सरल गैर-एप्लेट प्रोग्राम का उपयोग करके भी स्विंग या एडब्ल्यूटी का उपयोग कर रहा है। इसलिए एप्लेट वर्जन और फिर नॉन-एप्लेट वर्जन प्रोग्राम भी इस उद्देश्य के लिए लिखे जा सकते हैं।
तो, यह बहुत सरल है।
हमारे पास पहले से ही इस बारे में एक विचार है कि यह कुछ बटन हैं, पाठ क्षेत्र क्षेत्र में होंगे, और फिर उपयोगकर्ता कोई भी संचालन करता है।
वे ऑपरेशन मूल रूप से बाइनरी ऑपरेशंस हैं, जैसे कि कोई यूनिरी ऑपरेशन नहीं।
उदाहरण के लिए, वर्गमूल, घन, लॉग, ये सभी चीजें यहां शामिल नहीं हैं।
तो, यह सरल है।
तो, यहाँ आपको केवल लेआउट बनाना है, और फिर उस लेआउट में कुछ घटक शामिल करना है।
और फिर अंत में, हमें श्रोता तरीकों को जोड़ना होगा, ताकि घटनाओं को संभाला जा सके।
तो, कई कार्यक्रम हैं, आप इंटरनेट पर पा सकते हैं।
तो, इसके लिए जावा कैलकुलेटर सही है, आप सभी कार्यक्रमों की जांच कर सकते हैं, जो उपलब्ध हैं उन कार्यक्रमों को समझने का प्रयास करें।
इस पाठ्यक्रम में भी, हमने जावा कैलकुलेटर के लिए कई कार्यक्रमों का उपयोग किया है, एक जावा कैलकुलेटर के रूप में, आप उन कार्यक्रमों को भी पोषण कर सकते हैं।
तब आप इसे सीखने में सक्षम होंगे, फिर आप अपने स्वयं के संशोधित करने की कोशिश कर सकते हैं जैसे कि अलग-अलग फोंट या बटन का रंग सेट करना या जो कुछ भी है, ताकि आप व्यायाम कर सकें, चाहे आप जिस बदलाव को चाहें, चाहे कार्यक्रम में प्रतिबिंबित कर सकते हैं, और आप इसे देख सकते हैं या नहीं।
तो, यह होगा
मूल रूप से बहुत अभ्यास देता है।
और फिर एक कैलकुलेटर के डिजाइन की शुरुआत के रूप में, यह बड़े पैमाने पर संरचना है।
अब, हमारा अगला भाग मूल रूप से है, यदि वे थोड़े सुधार वाले संस्करण हैं।
तो, यह सरल कैलकुलेटर है, हमने साधारण कैलकुलेटर को सीखने के बाद पहले से ही सीखा है।
हमारा अगला चरण, यह मूल सरल कैलकुलेटर है जैसा कि आप देखते हैं और फिर हम मूल रूप से इसे इस एक में बदल देंगे, आप अंतर देख सकते हैं।
यहाँ अंतर मूल रूप से है क्योंकि आप यहाँ अंतर देखते हैं, मूल रूप से कुछ और बटन जोड़ते हैं जैसा कि हमने यहाँ बताया है, इसलिए कुछ और बटन हमने यहाँ जोड़े हैं।
जैसे कि C बटन C का मतलब स्पष्ट है, फिर पिछली गणना जो भी हो, हम मेमोरी में लोड कर सकते हैं, और फिर रीड या मेमोरी स्पष्ट हो सकती है।
और, यहां हमने एक और कार्यक्षमता का उपयोग किया है जो कहता है कि वर्गमूल गणना या वर्ग गणना, जो भी हो।
अब, मैं आपको सलाह दे सकता हूं कि यह एक सामान्य प्रतीक है, न कि चौकोर स्तर।
वर्गमूल प्रतीक वहाँ भी ठीक में रखा जा सकता है।
तो, हमने जाँच की है कि ठीक है, इसको जोड़ने के बाद, इस तरह के लुक के लिए एक ही कैलकुलेटर को कैसे बेहतर बनाया जा सकता है, और इस सीएम या एमआर, एमसी से संबंधित ऑपरेशन को भी कैसे जोड़ा जा सकता है।
हम ऐसा करने की कोशिश करने में सक्षम होंगे, और फिर आप केवल एक चीज है कि आपको अपने विचारों को लागू करना है कि ये चीजें कैसे की जा सकती हैं।
तो, हम देखते हैं, चाहे आप इसे कर सकते हैं या नहीं।
यदि आपको लगता है कि आपको कोई कठिनाई हो रही है, तो हम कोई भी बातचीत करने के लिए उपलब्ध होंगे, न कि सीधे ऑनलाइन इंटरैक्शन के बजाय, आप अपनी समस्याओं को मेल के माध्यम से भेज सकते हैं या आप एक इंटरएक्टिव प्रोग्राम के लिए अनुरोध कर सकते हैं ताकि हम बैठ सकें और फिर चर्चा कर सकें और हल कर सकें समस्याये।
लेकिन, इससे पहले, आपको हमें सभी समस्याओं को आग देना चाहिए, ताकि हम कार्यक्रम की समस्याओं से गुजर सकें, और फिर इसे जल्दी से हल करने के लिए तैयार हो जाएं।
इसका अगला संस्करण मूल रूप से अधिक बेहतर कैलकुलेटर डिज़ाइन है।
तो, यह आखिरी कैलकुलेटर संस्करण है, हमें इसे उनके रूप में बदलना होगा जैसा कि आप इस कैलकुलेटर संस्करण में देखते हैं, हम कई चीजें कर सकते हैं।
तो, पिछले कैलकुलेटर मूल रूप से दो नंबर और ऑपरेशन जोड़ रहा है, फिर यह परिणाम देगा।
लेकिन, यहाँ हम कह सकते हैं कि ऐड, सब,
कई ऑपरेशनों को एक साथ विभाजित करें, और फिर परिणाम को अंतिम रूप दें, इसलिए 5 प्लस 6 प्लस 10 को 2 शून्य से 8 में परिणाम के रूप में गणना की जाएगी।
तो, यह कैलकुलेटर, हम ये सुविधाएं प्रदान करेंगे।
इसके अलावा, इस कैलकुलेटर को ब्रैकेटेड अभिव्यक्ति की अनुमति भी है, ब्रैकेटेड एक्सप्रेशन का मतलब मूल रूप से इस ब्रैकेट के भीतर है, इसलिए 2 प्लस 3 को 5 से गुणा किया जाता है, यह मूल रूप से तदनुसार परिणाम देता है, इसलिए ब्रैकेट।
और फिर जटिल ब्रैकेट सभी मिलान कोष्ठक होना चाहिए, यह होना चाहिए;
यदि मिलान प्रथा में कोई त्रुटि है, तो आपके कैलकुलेटर को स्क्रीन पर त्रुटि संदेश की सूचना देनी चाहिए।
मेरा मतलब है कि पाठ और फिर अंत में, अगले अग्रिम कैलकुलेटर डिजाइन है।
और जैसा कि आप देखते हैं कि छोटे बटन अधिक हैं।
और यहां मैंने इसे आपके लिए थोड़ा खुला स्थान बनाया है ताकि आप इस बारे में सोच सकें कि अधिक उन्नत कैलकुलेटर को और अधिक परिष्कृत कैलकुलेटर कैसे डिज़ाइन किया जा सकता है।
आप एक उदाहरण के लिए अनुसरण कर सकते हैं;
कैसियो गणित कैलकुलेटर जो छात्रों के बीच लोकप्रिय छात्रों में बहुत प्रसिद्ध है।
तो, आप इस कैलकुलेटर का अनुसरण कर सकते हैं, और देख सकते हैं कि क्या आपके जावा वातावरण में इसे विकसित किया जा सकता है।
और आप अपने विंडोज वातावरण में उपलब्ध कई कैलकुलेटर देख सकते हैं, अपने लिनक्स सिस्टम में और साथ ही अगर आपके पास मोबाइल भी है, तो आप पा सकते हैं
वहाँ भी कई कैलकुलेटर।
आप कैलकुलेटर के बारे में सोच सकते हैं, जिस कैलकुलेटर को आप जावा में विकसित कर सकते हैं उसे मोबाइल सेटिंग में निर्यात किया जा सकता है;
इसलिए, कैलकुलेटर के रूप में मोबाइल ऐप का उपयोग किया जा सकता है, आपका अग्रिम कैलकुलेटर।
अब, देखते हैं, कि हम किस एडवांस कंपोनेंट के बारे में सोच रहे हैं, इसलिए पावर बटन जिसे हमने माना है, इसका मतलब है, यदि आप उदाहरण के लिए पावर पर क्लिक करते हैं, तो सभी चीजों को समझा जाएगा, और फिर कोई हाइलाइट नहीं होगी उसके जैसा।
चूंकि यह कैलकुलेटर की तरह बिजली बंद है, इसलिए यह तरह तरह की चीज़ों को चालू और बंद करता है, इसलिए कुछ सेटिंग बदल जाती है।
और इसके बाद बिजली बंद हो जाती है, अगर कोई भी किसी भी कुंजी और सब कुछ का उपयोग करता है, तो कैलकुलेटर हम आपके लिए काम नहीं करेंगे, इसलिए यह अक्षम हो जाता है।
और फिर के बारे में है, इसलिए यहां आप अन्य घटक शैली देख सकते हैं।
मान लीजिए कि आपको पृष्ठभूमि बदलनी है, क्योंकि मुझे ये पृष्ठभूमि पसंद नहीं है, इसलिए उपयोगकर्ता पृष्ठभूमि रंग, अग्रभूमि रंग, फ़ॉन्ट, फ़ॉन्ट आकार और फिर अभिविन्यास को अनुकूलित कर सकता है यदि आप इस प्रकाश या उस सब कुछ में अभिविन्यास बदलना चाहते हैं जो आप चाहते हैं इस एक का उपयोग करने की अनुमति दे सकते हैं।
और मूल रूप से बाहर निकलें यदि आप कुछ परिवर्तन करते हैं, तो जो भी है वह बाहर निकलें।
अब, आप इस एक्जिट बटन को बदल सकते हैं, जिसे अन्य सभी ट्रिगोनोमेट्रिक फ़ंक्शंस जैसे कुछ अन्य बटन पाप, कॉस, टैन, कॉट इस तरह कहते हैं कि अगर आपने इसे क्लिक किया है, और फिर इस ऑपरेटर के भी, हम जोड़ देंगे।
क्योंकि, यदि हम अधिक बटन जोड़ते हैं, तो एप्लेट का आकार बढ़ जाएगा, और फोंट और बटन के आकार की कीमत पर, और फिर त्रुटि होगी।
यदि आप बटन में छोटे आकार के कारण इसे गलती से क्लिक करना चाहते हैं, तो आप किसी अन्य बटन पर जाते हैं या जो कुछ भी है।
तो, उस स्थिति में, लॉग फंक्शंस, त्रिकोणमितीय फंक्शनालिटी या कुछ अन्य फंक्शंस जैसे कुछ अन्य फंक्शंस को भी वहां जोड़ा जा सकता है।
तो, इस तरह से कैलकुलेटर को बेहतर बनाया जा सकता है।
और, सुधार की एक और गुंजाइश यह है कि इतनी लॉग टेबल भी हो सकती है, और फिर कुछ सांख्यिकीय तालिका भी इस कैलकुलेटर में इस लॉग में जोड़ी जा सकती है, ताकि मेमोरी में टेबल संग्रहीत हो जाए।
और जब भी आप किसी मूल्य को स्वतंत्रता की डिग्री कहते हैं, और फिर मूल्य, तो यह बदले में परिणाम देगा।
इसलिए, यदि आप इन सभी चीजों के सांख्यिकीय प्रक्रिया या सांख्यिकीय तालिकाओं या वितरण फ़ंक्शन के बारे में थोड़ा सा ज्ञान रखते हैं, तो वे यह भी सोचते हैं कि इसमें शामिल किया जा सकता है।
सुधार के कई दायरे हैं।
अब, यहां हमने कैलकुलेटर को अंग्रेजी में डिज़ाइन किया है, लेकिन जो लोग उनके लिए अंग्रेजी नहीं जानते हैं, यह कैलकुलेटर कैसे हो सकता है
मदद की।
तो, इन चीजों के लिए सभी चीजें जो अंग्रेजी में हैं, इसे अन्य भाषाओं में परिवर्तित किया जा सकता है हिंदी या कुछ तेलुगु या तमिल।
इसलिए, यहां इन सभी पात्रों को बदला जा सकता है, यह केवल न्यूनतम प्रयास की आवश्यकता है।
तो, शैली फ़ाइल में या सेटिंग फ़ाइल के बारे में या, आप उस कैलकुलेटर को किस भाषा में बदल सकते हैं, इसलिए भाषा सेटिंग भी हो सकती है।
तो, बहुत सारी चीजें की जा सकती हैं।
और इस तरह, आप नवाचार कर सकते हैं कि आप बेहतर कैलकुलेटर कैसे डिज़ाइन कर सकते हैं।
और कैलकुलेटर डिज़ाइन बहुत अच्छा उदाहरण है और आमतौर पर कई शिक्षक, कई लेखक भी, उन्होंने पसंद किया है कि कैलकुलेटर पर चर्चा की जाए जबकि उन्होंने विभिन्न जावा अवधारणाओं पर चर्चा की।
हमने यहां भी वही काम किया है, लेकिन एक शुरुआती बिंदु है, आप इस पर चल सकते हैं, और इसे आगे बढ़ा सकते हैं, और वे कई चीजें सीखते हैं।
अब, हम अगली परियोजनाओं पर आते हैं, यह परियोजना फिर से उस परियोजना के समान है जो आप देख सकते हैं, यदि आप कौन बनेगा करोड़पति से परिचित हैं।
तो, वहाँ एक प्रश्नोत्तरी खेल है, जहां श्री बच्चन, जो मूल रूप से इस एक का संचालन कर रहे हैं।
इसलिए, हम क्विज़ गेम एप्लिकेशन को लागू कर सकते हैं, लेकिन बच्चन को हर समय उपलब्ध नहीं होना चाहिए।
इसलिए, बच्चन के स्थान पर, हमारा कंप्यूटर बच्चन की भूमिका निभा सकता है।
इसलिए, यहां एक क्विज़ रिपॉजिटरी से पॉप अप किया जा सकता है, और फिर उपयोगकर्ता को चयन और विकल्प का चयन करने की अनुमति होगी और यदि यह एक सही विकल्प है, तो उसका स्कोर बढ़ाया जाएगा।
और अगर यह एक गलत विकल्प है या यदि इसे किसी भी परिणाम के बारे में संदेह है, तो हम सिर्फ कौन बनेगा करोड़पति प्रश्नोत्तरी की तरह होंगे, यह मूल रूप से 50 प्रतिशत की छूट देगा, फिर तदनुसार एक स्कोर कम हो जाएगा।
और फिर केवल दो विकल्प दिए जाएंगे, इन दो विकल्पों में से, आपको चयन करना होगा।
उन सभी चीजों को किया जा सकता है।
तो, यह बिल्कुल प्रश्नोत्तरी गेम एप्लिकेशन है, यह वहां है।
अब, यहां क्विज़ गेम एप्लिकेशन के बारे में विचार है।
तो, सबसे पहले, आपको एक प्रश्न बैंक बनाना होगा।
प्रश्न बैंक का अर्थ है, यह मूल रूप से 500, शायद 5000, शायद 50,000, बिल्कुल कोई समस्या नहीं है की कोई सीमा नहीं है, शायद 500, सभी प्रश्नों का सेट है।
और फिर प्रश्न बैंक को तैयार करने की आवश्यकता है, और इस प्रश्न बैंक को एक सर्वर में बनाए रखने की आवश्यकता है।
तो, इस तरह से JDBC तस्वीर में आ रहा है, एक डेटाबेस सर्वर तस्वीर में आ रहा है।
मैं आपको यह विचार बताऊंगा कि इस परियोजना में यह प्रश्न बैंक सर्वर कैसे बनाया जा सकता है।
और फिर उपयोगकर्ता को इस गेम को खेलने की अनुमति दी जाएगी, निश्चित रूप से विकसित होने के लिए एक जीयूआई होना चाहिए।
तो, एक GUI आधारित इंजन को विकसित करने की आवश्यकता है जिसके द्वारा यह गेम खेल सकता है, यह मूल रूप से पूछा जाएगा कि क्या प्रश्न हैं, फिर प्रश्न होंगे, विकल्प होंगे, फिर चयन बटन होगा, अन्य विकल्प होंगे , तो बहुत सी बातें हैं।
तो, GUI प्रोग्राम मूल रूप से उपयोगकर्ता के लिए एक फ्रंट एंड है।
और कई सुविधाएं हैं, लचीलापन है, इसलिए खेल को अलग-अलग ट्विस्ट के अनुसार ट्यून किया जा सकता है, और फिर आवश्यकता का संबंध है।
अब, हम एक-एक करके प्रत्येक चरण पर चर्चा करते हैं, ताकि हम इस बारे में समझ सकें कि परियोजना को एक-एक करके कैसे आगे बढ़ाया जा सकता है।
तो, प्रश्न बैंक डेटाबेस सर्वर निर्माण।
वहाँ दो चीजें हैं जो किया जा सकता है, आप एक कौशल कमांड का उपयोग करके डेटाबेस को जोड़ सकते हैं, यह वहाँ कंसोल पर एक समय में प्रत्येक कमांड टाइप कर रहा है, और फिर डेटाबेस में रिकॉर्ड जोड़ रहा है।
अब, यहां मैं यह कहना चाहता हूं कि यदि डेटाबेस तालिका बनाने की आवश्यकता है, तो तालिका की संरचना क्या होगी, इसमें प्रश्न के बारे में एक ही क्षेत्र है।
फिर अन्य चार फ़ील्ड, चार विकल्पों के लिए।
फिर 6 वें क्षेत्र में एक और क्षेत्र, यह सही विकल्प होना चाहिए क्योंकि यह जानकारी आवश्यक है, ताकि कार्यक्रम इसे संसाधित कर सके।
और फिर जब भी यह डेटाबेस जब भी खेल चालू स्थिति में होता है, तो यह 1 प्रश्न के साथ-साथ सभी विकल्पों और फिर सही विकल्प को चरणबद्ध करेगा।
और फिर हम सवाल के साथ-साथ विकल्पों को भी फेंक देंगे, और फिर यह उपयोगकर्ता से विकल्प का चयन करेगा यदि सही एक है, तो विकल्प को सत्यापित करें और फिर तदनुसार स्कोर की गणना इस तरह की जाएगी।
अब, एक प्रक्रिया जो मैंने आपको बताई थी कि आप एक-एक करके डेटा दर्ज करते हैं, लेकिन 500 डेटा दर्ज करते हैं जो टेक्स्ट और फिर टाइपिंग एरर और सब कुछ टाइप करते हैं, इसलिए यह बहुत मुश्किल है।
इसलिए, हम स्वचालित रूप से एक प्रोग्राम लिख सकते हैं कि प्रोग्राम मूल रूप से एक दस्तावेज़ फ़ाइल के रूप में इनपुट के रूप में ले जाएगा।
और फिर उस फ़ाइल को स्कैन किया जाएगा और प्रत्येक रिकॉर्ड को सर्वर में स्वचालित रूप से दर्ज किया जाएगा, ताकि एक्सेल शीट-जैसे का उपयोग करके उस फाइल को बनाया जा सके, और मैंने यहाँ CSV फ़ाइल को एक विचार दिया है, यह एक्सेल फाइल के समान है अल्पविराम से अलग।
तो, प्रत्येक फ़ील्ड को अल्पविराम द्वारा अलग किया जाएगा, आपको इसे स्कैन करना होगा।
जब भी आप एक अल्पविराम पाते हैं, तो आप यह ले सकते हैं कि यह एक फ़ील्ड मान है, और फिर उस फ़ील्ड मान में, अगला और इतने पर।
तो, इस तरह 6 वें क्षेत्र में चार विकल्पों पर सवाल उठता है, और फिर एक सही विकल्प का चयन किया जाएगा और फिर तदनुसार, डेटाबेस सर्वर पर पॉप्युलेट किया जाएगा।
तो, यहां यह विचार दिया गया है कि यह आपके द्वारा बनाई गई CSV फ़ाइल है, और जिसे काटा जा सकता है और दस्तावेज़ के लिए पेस्ट बनाया जा सकता है, और फिर एक।
और वह प्रोग्राम, यदि आप किसी अन्य CSV फ़ाइल के साथ चलते हैं, तो वह प्रोग्राम को आसानी से डेटाबेस को अपडेट कर रहा है।
इसलिए, प्रोग्राम को विकसित करना केवल मुद्दे हैं, लेकिन यह केवल कुछ लाइनों का कोड आवश्यक है।
आइए हम इसे करने की कोशिश करते हैं, कैसे CSV फ़ाइल को पढ़ा जा सकता है और फिर सामग्री को पुनर्प्राप्त किया जा सकता है, और उसी सामग्री को डेटाबेस सर्वर में सम्मिलित रिकॉर्ड के रूप में भेजा और निष्पादित किया जा सकता है।
तो, इस तरह से यह किया जा सकता है।
और एक और बात यह है कि ठीक है, आप एक डेटाबेस व्यवस्थापक के रूप में हैं, आप जेडडीबीसी से भी डेटाबेस तालिका बना सकते हैं, आप तालिका को पूर्ण रूप से कोई समस्या नहीं बना सकते हैं।
आप वहां जो भी हो, हम वहां कर सकते हैं, और आपके खेल में विभिन्न विषयों को शामिल किया जा सकता है।
तो, कुछ विषय शायद राजनीतिक से संबंधित कह सकते हैं, कुछ शायद मनोरंजन से संबंधित हैं, कुछ शायद अन्य विषय से संबंधित हैं जिन्हें कंप्यूटर विज्ञान कहते हैं
या भौतिकी रसायन इस तरह से एक।
उपयोगकर्ताओं को एक मौका दिया जा सकता है कि वह किस विषय पर खेल खेलना चाहते हैं।
तो, तदनुसार, विषय का चयन किया जा सकता है शायद दो या अधिक शीर्ष का चयन किया जा सकता है, ताकि प्रश्न को पढ़ा जा सके, उन सभी विषयों से प्राप्त किया जा सकता है जिन्हें उपयोगकर्ता ने चुना है।
इसलिए, विषयवार विभिन्न तालिकाओं को भी बनाए रखा जा सकता है, और इसे सर्वर में अपडेट किया जा सकता है या डेटा को संबंधित विषय तालिकाओं और इसी तरह से लोड किया जा सकता है।
तो, यह डेटा प्रविष्टि है।
इसलिए, मेरा मतलब है MySQL सर्वर डेटाबेस निर्माण के लिए चिंतित है।
और यहां बहुत प्रारंभिक चरण में एक जीयूआई माफ है, आप खेल का एक बहुत ही सरल रूप देख सकते हैं जैसा कि आप यहां देखते हैं, यह पहले प्रश्न संख्या पर चर्चा करेगा।
और फिर यहां प्रश्न दिखाई देगा, और फिर विकल्प 1, विकल्प 2, विकल्प 3 जैसे चार विकल्प होंगे।
और फिर सभी विकल्पों पर प्रकाश नहीं डाला गया है।
जब भी उपयोगकर्ता एक विकल्प का चयन करेगा, वह उसे क्लिक करेगा।
और फिर यहां एक अन्य विकल्प कि सही विकल्प, जिसे चुना जाएगा, प्रदर्शित किया जाएगा या यदि जो विकल्प चुना गया है वह सही नहीं है, तो वास्तव में इस प्रश्न के अनुसार सही विकल्प प्रदर्शित किया जाएगा।
वैसे भी, तो यह एक विकल्प के चयन के बाद होगा, सही विकल्प प्रदर्शित किया जाएगा, और तदनुसार स्कोर भी गणना की जाएगी।
तो, यह GUI कार्यक्रम, हम सब कुछ ध्यान रखेंगे।
तो, यहां इंटरफ़ेस विकसित किया जाना है, और इवेंट हैंडलिंग रूटीन के लिए लिखा जाना चाहिए, ताकि यह कर सके
आवश्यकता के अनुसार काम करें।
तो, यह कार्यक्रम के पहले चरण के बारे में विचार है।
दूसरे चरण में, गेमिंग के लिए GUI प्लस प्रोग्राम जैसा कि हमने भेजा है कि फ्रंट-एंड पर GUI दिखाई देनी चाहिए, और बैक-एंड में बहुत सारी अन्य गतिविधि करनी चाहिए।
जिसके लिए हमें सॉकेट प्रोग्राम को विकसित करने की आवश्यकता है, क्योंकि इस GUI को सॉकेट के साथ इंटरैक्ट करना चाहिए जो सॉकेट सर्वर के माध्यम से जिम्मेदार होगा ताकि एक नेटवर्क पर यदि आपका सर्वर एक ही मशीन में उपयोगकर्ताओं से जुड़ा नहीं है, तो आपको यह करना होगा।
वैसे भी, ताकि अगर आपको जेडीबीसी तक पहुंचना है, तो आपके पास कनेक्टिविटी होनी चाहिए और सब कुछ है कि क्या मेजबान मशीन और गेम एक ही सिस्टम या रिमोट सिस्टम में एक मशीन खेल सकते हैं, चाहे वह कुछ भी हो ।
तो, आप उस सॉकेट के लिए सॉकेट प्रोग्राम विकसित कर सकते हैं जो मूल रूप से नेटवर्किंग चलाएगा, और फिर जेडीबीसी संबंधित प्रोग्राम एलिमेंट्स, और फिर यह वास्तव में बैकएंड प्रोग्राम है।
और फिर यह कार्यक्रम, हम दौर के अंत में उपयोगकर्ता से चयन करेंगे, सही विकल्प पर प्रकाश डाला जाएगा, और स्कोर को अपडेट किया जाएगा।
ये प्रोग्राम गतिविधियां हैं जिन्हें यह जाना चाहिए, खेल तब तक जारी रहेगा जब तक कि शायद 15 राउंड न कहें या जब तक कोई विकल्प नहीं होगा कि यदि आप छोड़ना चाहते हैं, तो उपयोगकर्ता से छोड़ दिया गया विकल्प पूछा जाना चाहिए, और फिर इसे छोड़ दें।
फिर अंत में, जब भी खेल खत्म होता है, तो उपयोगकर्ता द्वारा जोड़ी गई कुल स्कोर स्क्रीन पर प्रदर्शित किया जाएगा और इस तरह।
तो, यह दूसरे संस्करण के बारे में विचार है।
और फिर तीसरा संस्करण मूल रूप से है, आइए हम इंटरफ़ेस में सुधार करें और साथ ही साथ इंटरफ़ेस बदल जाएगा, सभी बैकएंड प्रोग्राम को भी बदलना होगा, यह सब कुछ जो आपको करना है।
यहाँ मैंने कुछ विचार दिए हैं, लेकिन आप इस से बेहतर कुछ सोच सकते हैं।
मैं इस विचार को थोड़ा सरल बनाना चाहता था ताकि आप इसे लागू कर सकें और कम से कम समय में इस परियोजना को संभाल सकें।
और यहां यह विचार है कि हम यहां देखने जा रहे हैं, विषय चयन को अतिरिक्त सुविधाओं के रूप में दिया जाना चाहिए जो पहले वाला संस्करण था, इसलिए यह विषय 1, विषय 2, सब कुछ यहां प्रश्नोत्तरी शुरू नहीं करता है।
और अगर यह शुरू होता है, तो यह बटन स्टॉक क्विज में बदल जाएगा- जैसे।
तो, इस बटन को टॉगल मोड की आवश्यकता होगी।
एक शुरुआत का मतलब है, यह शुरू हो जाएगा, और फिर सब कुछ हम इस तरह से शुरू करेंगे।
और जो भी विषय आपने चुना है, उस विषय को यहाँ हाइलाइट किया जाएगा, ताकि आप समझ सकें कि वह किस विषय पर उत्तर दे रहा है।
और इसलिए इस मामले में, केवल एक ही विषय है कि एक समय में एक उपयोगकर्ता का चयन किया जा सकता है।
इसलिए, प्रत्येक दौर में, उपयोगकर्ता इस विषय को बदल सकता है, और फिर तदनुसार प्रश्न का सामना किया जाएगा, प्रश्न यहां प्रदर्शित किया जाएगा, ये सभी वही चीजें हैं जो वहां हैं, इसलिए आप वहां।
और फिर यहाँ फिर से एक और सुविधा तो यह लेआउट का एक और सुधरा हुआ संस्करण है जिसके बारे में आप सोच सकते हैं, और यह एक और बेहतर संस्करण है, जहाँ हम कुछ और बटन जोड़ सकते हैं जैसा कि हम देखते हैं।
तो, एक प्रश्न हटाओ, दो प्रश्न हटाओ, और यह सब बात।
तो, एक प्रश्न का मतलब निकालें, यह मूल रूप से एक तिहाई स्कोर कम हो जाएगा।
और फिर 4 में से, यह मूल रूप से केवल 3 है, जिसमें से एक पाठ्यक्रम का सही होना चाहिए।
2 प्रश्न निकालें का मतलब है, 50-50 सही साधन, यह मूल रूप से दो प्रश्न हैं दो विकल्प हटा दिए जाएंगे।
और फिर केवल दो विकल्प जिनमें से एक वहाँ है, इसलिए मूल रूप से तब खिलाड़ी अधिक सटीक अनुमान लगा सकता है ताकि अधिक स्कोर हो सके, यह एक कौन बनेगा करोड़पति प्रश्नोत्तरी शैली के रूप में है।
और फिर यह इंटरफ़ेस है जिसे आप इसे विकसित कर सकते हैं।
इसलिए, यहां मूल रूप से कुछ और बटन जोड़े जा सकते हैं, और इन बटनों के लिए, हमें तदनुसार इंटरफ़ेस प्रोग्राम जोड़ना होगा।
तो, यह 7 वां कार्यक्रम है, और यह क्विज प्लेइंग गेम है, वास्तव में हमने चर्चा की है।
मुझे उम्मीद है, आपको ये प्रोजेक्ट दिलचस्प लग रहे होंगे।
और ये स्पष्ट रूप से छोटी परियोजनाएं हैं, क्योंकि जिस उद्देश्य से मैंने आपको पहले से प्रेरित किया है, उससे आप इस परियोजना को विकसित करने के लिए अपने सीखने के कौशल को लागू कर सकते हैं।
और अगर यह परियोजना भी है, तो आप अपने स्नातक परियोजना पाठ्यक्रम के रूप में भी कर सकते हैं, यदि आप एक स्नातक छात्र हैं।
और इस तरह, आप और अधिक सीख सकते हैं।
और फिर मैंने प्रारंभिक विचार दिया है, आवश्यक नहीं कि प्रारंभिक विचार यह है कि आप अपने स्वयं के इस विचार को सुधार सकते हैं, रचनात्मकता एक आवश्यक हिस्सा होना चाहिए जो सॉफ्टवेयर इंजीनियर के पास होना चाहिए।
इसलिए, मेरी आपसे यह अपेक्षा भी है, ताकि आप परियोजना में कुछ और नवीनता, अधिक रचनात्मकता जोड़ सकें।
तो, ये सिट प्रोजेक्ट हैं, हम कह सकते हैं कि यह एक से शुरू होता है, फिर इसे सुधारें।
और फिर देखें कि आधारित उत्पाद क्या हैं, आप विकसित कर सकते हैं।
आपके प्रयास के लिए धन्यवाद।
आपका बहुत बहुत धन्यवाद।
देवांश सामंत डिपार्टमेंट ऑफ़ कंप्यूटर साइंस एंड इंजीनियरिंग इंडियन इंस्टिट्यूट ऑफ़ टेक्नोलॉजी, खड़गपुर लेक्चर - 56 केस स्टडी - I तो, जावा में प्रोग्रामिंग इस कोर्स का अंतिम सप्ताह है, यह 12 वां सप्ताह है।
अब तक, हमने जावा प्रोग्रामिंग के बारे में बहुत कुछ सीखा है।
और यह हमारा अब व्यायाम करने का समय है, इसलिए अभ्यास मायने रखता है।
किसी भी प्रोग्रामिंग, भाषा सीखने में, आप अपने कौशल में सुधार कर सकते हैं यदि आप खुद को कुछ काम करने के लिए प्रेरित कर सकते हैं, और फिर अभ्यास और अभ्यास कर सकते हैं।
इसलिए, इन बातों पर विचार करते हुए, हमने कुछ परियोजनाओं की योजना बनाई है जिन्हें आप बंद कर सकते हैं, ताकि आप परियोजनाओं को निपटा सकें, कार्यान्वित करने का प्रयास कर सकें, और फिर ठीक है, फिर आप कई और चीजें सीख सकते हैं, जो मूल रूप से सीखना संभव नहीं है, केवल बस वीडियो कोर्स के माध्यम से या जो कुछ भी वहां है उसका उपयोग करना या उसमें भाग लेना।
इसलिए, एक परियोजना बहुत महत्वपूर्ण है।
तो, अब हम इस सप्ताह में चर्चा करेंगे, परियोजनाओं का एक समूह चर्चा की जाएगी, इन सभी परियोजनाओं को कैसे हल किया जाए।
और इन परियोजनाओं को हल करने के लिए, आपके पास अन्य कौशल क्या होना चाहिए, इन सभी चीजों पर एक-एक करके चर्चा की जाएगी।
तो, चलिए पहले प्रोजेक्ट्स के बारे में चर्चा करने जा रहे हैं।
यह एक डाटा एंट्री सिस्टम है।
तो, नाम से आप समझ सकते हैं कि, हमें एक सॉफ्टवेयर विकसित करना होगा जिसके द्वारा एक डेटा दर्ज किया जा सकता है।
अब, स्पष्ट रूप से डेटा प्रविष्टि एक निश्चित से संबंधित होनी चाहिए
आवेदन।
इसलिए, यहां हम छात्र के रिकॉर्ड के लिए डेटा प्रविष्टि के संबंध में आवेदन पर विचार करेंगे।
तो, मूल रूप से इस परियोजना के लिए, आपको एनकैप्सुलेशन, इनहेरिटेंस, और फिर एक्सेस स्पेसियर, पैकेज की अवधारणा, और थोड़ा सा जीयूआई प्रोग्रामिंग के रूप में छिपाने के बारे में बुनियादी अवधारणाओं की आवश्यकता होती है।
जैसा कि आप देख सकते हैं, हमें एक कार्यक्रम विकसित करना है, यह सिर्फ एक मिनी-सॉफ्टवेयर है जिसे हम कह सकते हैं।
यदि आप इन कार्यक्रमों को विकसित कर सकते हैं, तो बाद के चरण में किसी भी बड़े पैमाने पर कार्यक्रम भी विकसित किया जा सकता है, यह उसी एप्लिकेशन के समान है।
अब, डेटा प्रविष्टि अनुप्रयोग बहुत बड़ा है, यह वास्तव में हर जगह है।
और यह कार्यक्रम एक सरल है जिसे हमें योजना बनाना है, ताकि आप इसे कर सकें, अधिकतम समय जो आप इस परियोजना को हर महीने हल करने के लिए सोच सकते हैं।
इसलिए, एक महीने में, वास्तव में, कुछ छात्रों के लिए, वास्तव में केवल 1 सप्ताह लगेगा।
वैसे भी, इसलिए अधिकतम पर, आप केवल एक महीने में लागू करने के लिए समय बिता सकते हैं।
अब, हम परियोजनाओं के विचार के बारे में चर्चा करते हैं।
यहां विचार यह है कि आपको एक वर्ग घोषित करना होगा।
कक्षा का नाम, आप एक छात्र के रूप में दे सकते हैं।
ऐसा इसलिए है क्योंकि हम किसी छात्र के बारे में रिकॉर्ड या जानकारी दर्ज करने जा रहे हैं, इसलिए उसके लिए कक्षा की घोषणा होनी चाहिए।
अब, इस वर्ग को छात्रों की विभिन्न किस्मों को ध्यान में रखना चाहिए।
छात्र केवल वर्दी नहीं हो सकते हैं;
छात्रों की अलग श्रेणी हो सकती है।
जैसे कुछ छात्र केवल स्नातक पाठ्यक्रम का अध्ययन कर सकते हैं, कुछ छात्र स्नातकोत्तर पाठ्यक्रम, अर्थात् एम.टेक या पीएचडी हो सकते हैं, पीजी पाठ्यक्रम की तुलना में कुछ अधिक भी हो सकते हैं, जैसे कि पोस्ट-डॉक्टरेट साथी या वैज्ञानिक।
इसलिए, हमारे पास और स्पष्ट रूप से जैसा कि आप जानते हैं, इसलिए यूजी छात्रों के लिए डेटा प्रविष्टि एक शोध छात्र की तरह एक पीजी छात्र के लिए डेटा प्रविष्टि नहीं हो सकती है।
ऐसा इसलिए है क्योंकि कुछ ऐसी विधियाँ हो सकती हैं जिनकी आवश्यकता होती है जो अन्य श्रेणी की वस्तुओं के मामले में आवश्यक नहीं होती हैं।
फिर हमें कीबोर्ड से डेटा दर्ज करने के बारे में एक प्रक्रिया तय करनी होगी, इसलिए यह है कि हम पहले कीबोर्ड से कंसोल-आधारित डेटा प्रविष्टि के बारे में विचार करेंगे, कि उपयोगकर्ता कीबोर्ड में कैसे प्रवेश कर सकता है, यह एक संकेत देगा जो नाम के साथ प्रवेश करता है विद्यार्थी।
फिर कीबोर्ड से, आप डेटा देंगे, और फिर वापस लौटेंगे।
फिर फिर से यह हमारे रोल नंबर के लिए संकेत देगा, आपको इस प्रकार दर्ज करना होगा।
तो, यह कंसोल-आधारित परीक्षण प्रविष्टि है।
आमतौर पर, आप इस तरह की प्रविष्टि से परिचित होते हैं, जब आप सी प्रोग्रामिंग या ऐसा कुछ सीख रहे होते हैं।
वैसे भी, तो यह एक बहुत ही तुच्छ काम है।
और फिर अंत में, हमें कुछ अलग तरीके का उपयोग करके एक ही विचार करना होगा।
एक अलग तरीका है क्योंकि जब भी, आप कंसोल-आधारित परीक्षण प्रविष्टि का उपयोग करते हैं;
डेटा आमतौर पर आपकी मुख्य मेमोरी में संग्रहीत होता है और इसलिए जब तक आपका प्रोग्राम निष्पादन में है, डेटा उपलब्ध हो जाएगा।
हालाँकि, यदि आप प्रोग्राम छोड़ देते हैं या आपका सिस्टम बंद हो जाता है, तो आपका डेटा खो जाएगा।
दूसरी ओर, आपके द्वारा दर्ज किया गया डेटा, भले ही वह कंसोल-आधारित हो, आप उसे द्वितीयक संग्रहण में पंप कर सकते हैं, ताकि किसी फ़ाइल में डेटा संग्रहीत किया जा सके।
तो, यहां डेटा प्रविष्टि भी बहुत महत्वपूर्ण है कि आप डेटा कैसे दर्ज करते हैं, और यह डेटा अंततः कहां जाता है, इसलिए यह मूल रूप से एक फ़ाइल है।
और फिर अंत में, हम थोड़ा परिष्कृत डेटा इकाई के बारे में विचार करेंगे, यह कंसोल-आधारित नहीं है।
यह मूल रूप से, हम एक GUI विंडोज़ प्रोग्राम विकसित कर सकते हैं जो उपयोगकर्ता को डेटा प्रॉम्प्ट में प्रवेश करने की अनुमति देता है GUI में ही होगा।
और फिर GUI से दर्ज होते ही डेटा, यह सीधे फाइल में जाएगा।
वैसे भी, तो यह इस परियोजना के बारे में विचार है।
अब, हमारे पास अलग-अलग चरण हैं।
इसलिए, यह बेहतर है कि यदि परियोजना बड़े आकार की है, तो हमें इस परियोजना को स्पष्ट रूप से हल करना होगा।
मैं एक विचार दे रहा हूं कि कैसे चरणबद्ध तरीके से, इस परियोजना को लागू किया जा सकता है।
तो, परियोजना का पहला संस्करण जिसे हमने यहां पर योजनाबद्ध किया है जो कंसोल-आधारित डेटा प्रविष्टि है।
और इन चीजों के लिए, हमें कक्षा की घोषणा करनी होगी।
इसलिए, विरासत के आधार पर सभी कक्षा दो के छात्रों का एनकैप्सुलेशन भी।
और सभी वर्ग जो आप इस वर्ग की घोषणा के आधार पर बनाएंगे, उन्हें एक में संग्रहीत किया जाना चाहिए
पैकेज।
क्योंकि, जब भी बड़े वर्ग शामिल होते हैं;
बेहतर विचार यह है कि आपको निर्देशिका में सभी वर्गों को संग्रहीत नहीं करना चाहिए, इसके बजाय आप सभी वर्गों को एक अलग निर्देशिका में कई निर्देशिकाओं में बनाए रख सकते हैं।
यह मूल रूप से बाद के चरण में कार्यक्रम को प्रबंधित करने में मदद करेगा।
यह मूल रूप से बाद के संस्करण के लिए संशोधन या उन्नयन के लिए आवश्यक है, इसलिए यह पैकेज अवधारणा है जिसे आपको यहां से व्यायाम करना चाहिए।
तो, सभी वर्ग घोषणा जो आप देंगे, यह मूल रूप से एक पैकेज के रूप में है।
मैं आपको इस बारे में एक त्वरित जानकारी दे रहा हूं कि छात्रों का एक वर्ग कैसा दिखेगा।
तो सबसे पहले, आपको एक आधार वर्ग, आधार वर्ग का नाम तय करना होगा जिसे आप एक छात्र के रूप में दे सकते हैं।
और फिर छात्र आधार वर्ग में उन क्षेत्रों और विधियों को शामिल किया जा सकता है जिनका मैंने यहां उल्लेख किया है जैसा कि हम यहां देखते हैं।
तो, ये अलग-अलग तरीके और क्षेत्र हैं जो इस तक सीमित नहीं हैं, आप कुछ और भी सोच सकते हैं जो अधिक उपयुक्त हो सकता है।
मैंने आपके सिर्फ एक संकेत के लिए यहां दिया है।
अब, इसलिए यह आधार वर्ग है।
और फिर जैसा कि आपने बताया है, कक्षा अलग हो सकती है, तो सभी छात्र वास्तव में इस कक्षा के छात्र हैं।
और फिर एक श्रेणी होगी कि यूजी, इसलिए यूजी के पास फिर से अलग-अलग फ़ील्ड हैं जो वहां नहीं हैं या कुछ विधि हो सकती है, जिसे वहां पर अधिलेखित करने की आवश्यकता है या जिस विधि को आप यहां घोषित कर सकते हैं, आप इन विधियों को यहां परिभाषित करने के लिए पुन: उपयोग कर सकते हैं। ।
तो, यह विरासत की अवधारणा है जिसे आप अनुसरण कर सकते हैं एक एकल विरासत है जो जावा केवल प्रदान करता है, आप इस का उपयोग करते हैं।
और कुछ अन्य डेटा भी जिन्हें आप शामिल कर सकते हैं जो यहां नहीं है, इसलिए यूजी।
और यह परिणाम यूजी ही एक और वर्ग ठीक है।
तो, एक पाठ्यक्रम एक और वर्ग हो सकता है, क्योंकि एक पाठ्यक्रम में कुछ अन्य शामिल हो सकते हैं, जिसे विषय भी कहा जाता है।
इस पाठ्यक्रम के तहत पाठ्यक्रम 1, विषय 2, विषय 3, और प्रत्येक विषय के लिए फिर से, वे शायद 1, अंक 2, अंक 3 चिह्नित हैं।
तो, यह मूल रूप से एक समग्र विषय है।
अब, यह आपके ऊपर है कि आप किस विवरण स्तर तक जाना चाहते हैं।
तो, यह मूल रूप से एक नेस्टेड क्लास का एक उदाहरण है जो आप कर सकते हैं, यहां तक ​​कि क्लास भी।
उन सभी वर्गों को पैकेज में घोषित किया जा सकता है, और मैं इसे आयात और अन्य तरीकों से उपयोग कर सकता हूं।
तो, इस तरह से स्नातक वर्ग घोषित किया जा सकता है, जैसे मास्टर वर्ग घोषित किया जा सकता है, पीएच.डी. और वैज्ञानिक वर्ग घोषित किया जा सकता है।
और वे एक अलग वर्ग हैं क्योंकि इसके कुछ क्षेत्र या विधियां हैं जो यहां या वहां नहीं हैं, इसलिए यही है कि विभिन्न वर्ग रचनाओं को ध्यान में रखा जाना चाहिए।
तो, यह विभिन्न वर्ग अवधारणाओं के बारे में है, जिनका आपको पालन करना चाहिए, और फिर उन्हें पैकेज में संग्रहीत करना चाहिए जैसा कि हमने उल्लेख किया है कि छात्र पैकेज है।
और फिर हमारा अगला कदम जो आपको कक्षा और सब कुछ घोषित करने के बाद होना चाहिए, आपको ऑब्जेक्ट बनाना होगा।
छात्रों की संख्या n हो सकती है जो किसी विशेष श्रेणी से संबंधित है, आप वस्तुओं की सरणी बना सकते हैं।
और वस्तुओं के प्रत्येक सरणी के लिए, आप फ़ील्ड मान, कीबोर्ड से सदस्य तत्वों को पढ़ सकते हैं, ताकि इस बारे में क्या विचार हो।
और फिर एक बार जब आप इसे पढ़ लेते हैं, तो आप पढ़ रहे हैं या नहीं, आप सफल हैं या नहीं, तो आप बस एक विधि को प्रिंटकार्ड परिभाषित कर सकते हैं, ताकि ये सभी चीजें कंसोल के माध्यम से डेटा प्रविष्टि हो जाएं, फिर से आप एक अलग वर्ग के रूप में योजना बना सकते हैं।
और इन सभी वर्गों को एक और निर्देशिका में रखा जा सकता है, इस निर्देशिका का नाम एक प्रविष्टि के रूप में पैकेज है।
तो, यह इस पहले चरण का दूसरा भाग है, अर्थात् डेटा दर्ज करना।
और फिर यहां इसका अगला चरण डेटा संग्रहीत कर रहा है।
जैसा कि आपने देखा है कि आपने जो डेटा स्टोर किया है, वह ऑब्जेक्ट्स में ही स्टोर होता है।
और उन वस्तुओं को एक सरणी में संग्रहीत किया जाता है, और यह सरणी मूल रूप से प्राथमिक मेमोरी में होती है।
अब, इसलिए आपको सभी ऑब्जेक्ट्स को एक फाइल में स्टोर करना है, जिसका अर्थ है कि ऑब्जेक्ट्स के विभिन्न क्षेत्रों में मौजूद वैल्यूज को फाइल में पास किया जाना चाहिए।
तो, इस मामले में, आप IO स्ट्रीम को अधिक मूल रूप से हैंडल करने के लिए उपयोग कर सकते हैं, आप क्लास को हैंडल कर सकते हैं, और फिर उसका उपयोग कर सकते हैं और फिर आप ऐसा कर सकते हैं।
और फिर आप किसी अन्य पैकेज एप्लिकेशन में डेटा प्रविष्टि के लिए इस वर्ग को बचा सकते हैं।
और यह वास्तव में आपका मुख्य वर्ग होगा।
इस मामले में दर्ज किया गया डेटा मुख्य वर्ग है।
इसलिए, मुख्य कक्षा में, आप सभी अन्य वर्ग का उपयोग कर सकते हैं, जिन्हें आपने छात्रों की तरह विभिन्न पैकेजों में घोषित किया है, और उसके बाद प्रवेश पैकेज का डेटा दें।
तो, यह संस्करण 1 है।
और फिर यह संस्करण 3 है, कार्यक्रम के तीसरे चरण को हम कह सकते हैं, यहां आपको डेटा प्रविष्टि के लिए जीयूआई को परिभाषित करना होगा।
अब, यहाँ फिर से, डेटा दर्ज किया जाएगा
ग्राफिकल यूजर इंटरफेस जिसका मतलब है कुछ टेक्स्ट फील्ड, और फिर कुछ बटन होंगे।
उन सभी बटन को भी ठीक से हैंडल करने की आवश्यकता है और फिर कीबोर्ड हैंडलिंग इवेंट को भी लागू किया जाना चाहिए।
और फिर एक बार डेटा एक के बाद एक दर्ज किया जाता है, यह मूल रूप से फिर से फ़ाइल में जाएगा।
अब, मैं एक त्वरित खोज दे रहा हूं, डेटा प्रविष्टि कौशल कैसा दिखेगा, यह एक बहुत ही सरल है, आप इसे विकसित करने के लिए AWT पैकेज का उपयोग कर सकते हैं।
और इस मामले में, आपके पास यह एक मूल रूप से फ्रेम है, यह फ्रेम सामग्री स्तर है, ये स्तर हैं।
और ये एक टेक्स्ट फ़ील्ड हैं, और यह बटन है, और ये एक अन्य बटन की तरह हैं।
तो, ये कुछ टैब के अलावा मूल घटक हैं।
इसलिए, यदि आप यूजी छात्र के लिए डेटा दर्ज करना चाहते हैं यदि आप इसे क्लिक करते हैं, तो यह सब मूल रूप से डेटा के अनुसार रचना बदल जाएगा, जो यूजी के लिए प्रासंगिक हैं।
इसी तरह, यदि आप इसे टैब करते हैं, तो यह टेक्स्ट फ़ील्ड वास्तव में उस अलग फ़ील्ड के अनुसार बदल जाएगी जो इस डेटा के लिए प्रासंगिक है।
तो, इस तरह से आपके पास टैप की गई टेक्स्ट एंट्री सिस्टम हो सकती है, और यह सब जावा स्विंग का उपयोग करके भी किया जा सकता है, एडब्ल्यूटी भी।
यदि आप जावा स्विंग का उपयोग करते हैं, तो यह बहुत अच्छा है;
अन्यथा, आप AWT का भी उपयोग कर सकते हैं।
वैसे भी, तो यह डेटा प्रविष्टि के बारे में तरीका है जो किया जा सकता है।
और एक सरल कार्यक्रम जिसके बारे में आप सोच सकते हैं, और आप इसे एक परियोजना के रूप में ले सकते हैं।
तो, यह पहली परियोजना के बारे में है।
अब, हम इस बारे में विचार करें।
अब, विचार पर जाने से पहले, मैं अभी देखता हूं, मैंने अभी उल्लेख किया है कि कौशल सेट या प्रोग्रामिंग आत्मविश्वास क्या है कि आपके पास कोर प्रोग्रामिंग होना चाहिए, जिसका अर्थ है, सभी नियंत्रण संरचना भाषा संदर्भ और सब कुछ होना चाहिए।
बिट एनकैप्सुलेशन, इनहेरिटेंस भी यहां इस्तेमाल किया जा सकता है, पैकेज कॉन्सेप्ट है, पॉलीमॉर्फिज्म, स्कोप नियम, और फिर अंत में ग्राफिक्स भी यहां होना चाहिए ताकि आप ग्राफिक्स का इस्तेमाल कर सकें।
लेकिन, यहां वास्तव में केवल AWT के बारे में थोड़ा सा है, और इतना विवरण ग्राफिक्स नहीं है, यह वहां है।
अब, देखते हैं कि इस परियोजना का विचार क्या है।
अब, यह परियोजना मूल रूप से द्विआधारी पेड़ बनाने, फिर एल्गोरिदम को सॉर्ट करने और एल्गोरिदम की खोज करने के बारे में है।
तो, बाइनरी ट्री का संबंध है क्योंकि कई बाइनरी ट्री हैं, लेकिन हम इसे केवल कुछ ही तक सीमित कर सकते हैं जो आप कर सकते हैं।
भले ही आप केवल एक ही कर सकते हैं जो अच्छा है, वास्तव में सभी बाइनरी पेड़ों को हल करने के लिए आवश्यक नहीं है, लेकिन यह सलाह दी जाती है कि आपको वास्तव में सभी बाइनरी पेड़ों पर हाथ लगाने की कोशिश करनी चाहिए।
तो, यह मूल रूप से बहुत सारे प्रोग्रामिंग ग्रिप देगा, यह कैसे हो सकता है।
तो, यहाँ हमने बाइनरी ट्री, बाइनरी सर्च ट्री, AVL ट्री और हीप ट्री का उल्लेख किया है ।
एवीएल वृक्ष को ऊंचाई संतुलन वृक्ष भी कहा जाता है।
तो, डेटा संरचनाओं पर कोई भी अच्छी पुस्तक जो आप अनुसरण कर सकते हैं, और आपको वहां से जानकारी हो सकती है।
और इस परियोजना को लेने से पहले, आपके पास इन सभी अवधारणा पेड़ों के एल्गोरिदम के साथ एक अच्छी परिचितता होनी चाहिए, इस तरह की खोज के लिए एल्गोरिदम को सॉर्ट करना।
अब, इसलिए छँटाई एल्गोरिथ्म का संबंध है, मैंने कुछ लोकप्रिय छँटाई एल्गोरिदम का उल्लेख किया है जो मूल रूप से वास्तव में कोड करना आसान है।
तो, ढेर सॉर्ट, त्वरित सॉर्ट, मर्ज सॉर्ट, बबल सॉर्ट, चयन सॉर्ट, प्रविष्टि सॉर्ट वगैरह।
और फिर आपके द्वारा विकसित किए गए सभी सॉर्टिंग और खोज एल्गोरिदम, हम विज़ुअलाइज़ेशन के लिए जाएंगे।
यहां तक ​​कि बाइनरी ट्री कंस्ट्रक्शन भी, मैं विज़ुअलाइज़ेशन की अवधारणा पर बाद में आऊंगा, अर्थात एल्गोरिथ्म की प्रत्येक प्रक्रिया को विज़ुअलाइज़ किया जा सकता है, ताकि जो कोई भी इसके बारे में नहीं जानता है कि छंटाई कैसे होती है, वे दृश्य प्रगति देख सकते हैं ।
और फिर तकनीक के बारे में समझें जैसे।
तो, यह विचार के बारे में है।
और यहाँ एक बात पर आपको ध्यान देना चाहिए कि जावा पॉइंटर कांसेप्ट का समर्थन नहीं करता है।
और आप सोच सकते हैं कि बाइनरी ट्री और सब कुछ कैसे एक पॉइंटर के बिना, आप कार्यान्वित कर सकते हैं।
पूरी तरह से पॉइंटर की आवश्यकता नहीं है, क्योंकि आप उन तत्वों को बनाए रख सकते हैं जो पेड़ में इस्तेमाल होने के लिए आवश्यक हैं, उन्हें एक सरणी के रूप में संग्रहीत किया जा सकता है।
इसलिए, सरणी-आधारित ट्री कार्यान्वयन यहां काफी संभव है, और आपको ऐसा करना चाहिए।
और इस सरणी के लिए, आप डेटा का उपयोग कर सकते हैं जो कि java.utit.package पैकेज से अन्य डेटा संरचना, सरणी, कम से कम, वेक्टर इन सभी चीजों का उपयोग कर सकता है जो आप यहां उपयोग कर सकते हैं।
परिभाषित करने की आवश्यकता नहीं है या आपकी खुद की सरणी जो कि आदिम तरीके से है, सभी एपीआई आधारित कम से कम इस उद्देश्य के लिए उपयोग किया जा सकता है।
अब, पहले चरण में पहला संस्करण जो आपको करना चाहिए, वह मूल रूप से द्विआधारी पेड़ों का निर्माण और प्रक्रिया है।
यहां आपको एल्गोरिथ्म को लागू करना होगा, वे वहां हैं जो हैं
बाइनरी ट्री, हीप ट्री, बाइनरी सर्च ट्री, एवीएल ट्री और वह बाइनरी सर्च ट्री और किसी भी तरह की डेटा संरचनाओं की किसी भी पुस्तक की पुस्तक में उपलब्ध है।
और फिर जब भी आप घोषणा करते हैं कि आपको मूल रूप से प्रत्येक वर्ग के लिए है, तो आपको वास्तव में अलग वर्ग की घोषणा करनी चाहिए।
प्रत्येक पेड़ के लिए, आपको वास्तव में एक अलग वर्ग घोषित करना चाहिए।
और फिर इस वर्ग में अलग-अलग क्षेत्रों के साथ-साथ अलग-अलग पद्धति शामिल होनी चाहिए जैसा कि मैंने यहां बताया है, एक क्षेत्र डेटा हो सकता है।
और डेटा को पूर्णांकों की एक सरणी के रूप में संग्रहीत किया जा सकता है यदि आप एक पूर्णांक डेटा के लिए पेड़ का निर्माण करना चाहते हैं या यदि आप स्ट्रिंग के लिए डेटा बनाना चाहते हैं, तो इस तरह के स्ट्रिंग की एक सरणी कहें।
और फिर यहां उन तरीकों को बताया गया है जो आपको बिल्ड ट्री को लागू करने, डेटा सम्मिलित करने, डेटा को हटाने, खोज डेटा, ट्रैवर्स डेटा, डेटा को आकर्षित करने के लिए हैं।
ड्रा डेटा का अर्थ मूल रूप से विज़ुअलाइज़ेशन और अन्य के लिए है।
इसलिए, सभी वर्ग जो आप बनाएंगे, आप उन्हें एक पैकेज में बनाए रख सकते हैं।
यहां मैंने पैकेज का नाम दिया है, मैं जाऊंगा।
और आप ध्यान दे सकते हैं कि पैकेज का नाम जो भी हो, आपको देना चाहिए यह छोटे अक्षरों में होना चाहिए।
कोई पूंजी पत्र, आमतौर पर पैकेज नाम देने के लिए सलाह दी जाती है।
ऐसा इसलिए है क्योंकि कई ऑपरेटिंग सिस्टम में डायरेक्टरी का नाम केस सेंसिटिव नहीं है।
इसलिए, बड़े अक्षर, छोटे अक्षर, पैकेज के नाम को मिलाने की अनुमति नहीं है।
तो, आपको केवल छोटे अक्षर जैसे ए, और अधिमानतः तीन से चार अक्षरों को अधिकतम से अधिक नहीं देना चाहिए।
तो, यह वह पैकेज है जिसे आप विकसित कर सकते हैं।
यह पैकेज अहंकार, हम सभी संभावित पेड़ों के कार्यान्वयन को शामिल करेंगे, कार्यान्वयन में अलग-अलग तरीके और क्षेत्र शामिल हैं, और उन पदानुक्रमों का भी उल्लेख कर सकते हैं, जिनका अर्थ है, आप मूल पेड़ बना सकते हैं और फिर बाइनरी की तरह अलग-अलग पेड़ संरचना में विरासत में मिला सकते हैं पेड़।
एक बाइनरी ट्री में एक विशेष संपत्ति हो सकती है बाइनरी सर्च ट्री, हीप ट्री भी एक अन्य प्रकार की संपत्ति है।
तो, ट्री बाइनरी ट्री से एक वंशानुक्रम हो सकता है, एक विरासत हैं एक बाइनरी सर्च ट्री।
एक और विरासत एक ढेर पेड़ हो सकता है।
फिर एवीएल ट्री एक विशेष प्रकार का बाइनरी सर्च ट्री है।
तो, एवीएल पेड़ को बाइनरी सर्च ट्री जैसे उपवर्ग के रूप में माना जा सकता है।
तो, आप यह योजना बना सकते हैं कि पदानुक्रम का अर्थ है कि, एनकैप्सुलेशन या वंशानुक्रम वृक्ष को कैसे माना जा सकता है ताकि कोड की न्यूनतम संख्या के साथ या कोड पुन: उपयोग करने की विधि का उपयोग करके पुन: उपयोग करें या आप इसका उपयोग कर सकें।
तो, यह परियोजना के दूसरे भाग के पहले भाग के बारे में है।
परियोजना के हमारे दूसरे भाग में, जिन्होंने छंटाई और खोज एल्गोरिदम को लागू करने की योजना बनाई है।
सॉर्टिंग एल्गोरिदम, फिर से इसके लिए बहुत सारे फ़ील्ड की आवश्यकता होती है।
इसलिए, प्रत्येक छंटाई एल्गोरिथ्म के लिए, आप एक वर्ग की योजना बना सकते हैं।
और इस वर्ग में उपयुक्त क्षेत्र और विधियाँ शामिल होंगी।
और फिर से पेड़ की तरह भी, आप एक विरासत संरचना को बनाए रख सकते हैं, ताकि जिस अलग पाठ्यक्रम का उपयोग किया जा सके, उसे स्टोर किया जा सके और इसे सामान्य वर्ग में स्टोर किया जा सके।
अन्य उपवर्गों में इस तरह के अपने कोड और स्वयं के तरीके हो सकते हैं।
और फिर छँटाई खोज एल्गोरिथ्म भी इसका मतलब यह है कि यह कर सकते हैं पैकेज पैकेज का विस्तार कर सकते हैं वर्ग जो उन में वहाँ भी हैं, मैं भी पेड़ों का मतलब है क्योंकि कुछ पेड़ों को भी कुछ छँटाई एल्गोरिदम को लागू करने की आवश्यकता है।
उदाहरण के लिए, यदि आप ढेर को क्रमबद्ध करना चाहते हैं, तो यह मूल रूप से ढेर पेड़ की जरूरत है।
इस प्रकार, यह ढेर प्रकार ढेर वृक्ष का विस्तार करता है, और फिर वहां मौजूद सभी वर्गों का उपयोग किया जा सकता है।
इसलिए, यदि आप किसी अन्य पैकेज में या किसी अन्य पैकेज में भी कोई समस्या नहीं रख सकते हैं, तो आप ऐसा कर सकते हैं।
और तरीके, आप कुछ खुले, सम्मिलित, हटा सकते हैं, मतलब बचा सकते हैं, छँटाई के बाद डेटा को बचाया जा सकता है।
उद्घाटन का मतलब है, आप कच्चे डेटा इनपुट डेटा से खोल सकते हैं, और फिर हटा भी सकते हैं।
यदि आप इस डेटा को किसी आइटम को किसी क्रमबद्ध सॉर्ट से हटा सकते हैं या इसे सम्मिलित भी कर सकते हैं, लेकिन प्रविष्टि सॉर्ट की जानी चाहिए।
उन सभी तरीकों को भी, आप प्रत्येक प्रकार की तकनीकों के लिए लागू कर सकते हैं।
और यह भी एक अन्य विधि समय मूल रूप से कितना समय है कि छँटाई एल्गोरिथ्म को छँटाई कार्य या एक खोज कार्य को पूरा करने के लिए आवश्यक है।
तो, समय भी आप एक विशेष वर्ग के लिए एक विधि के रूप में उपयोग कर सकते हैं।
और इस श्रेणी के तहत सभी कार्यान्वयन को पैकेज में बदल दिया जा सकता है, इसलिए यह परियोजना का दूसरा चरण है।
और परियोजना का तीसरा चरण विज़ुअलाइज़ेशन और देशी एपीआई बनाना है।
इसलिए, इस प्रक्रिया में, हमारे पास अलग तरह से कुल दृश्य प्रभाव होगा।
उदाहरण के लिए, आप एक पेड़ का निर्माण कर रहे हैं।
जब आप एक एकल नोड सम्मिलित करते हैं, तो यह केवल एक नोड देगा।
जब आप एक और नोड जोड़ते हैं, तो यह उस पेड़ पर जाएगा, चाहे वह बाएं बच्चा हो या सही बच्चा।
तो, तदनुसार पेड़ का निर्माण किया जाएगा।
और फिर इमारत की प्रक्रिया को एक-एक करके कल्पना की जा सकती है क्योंकि चीजें चल रही हैं।
तो, यह दृश्य प्रक्रिया है।
और इन चीजों को करने के लिए इस प्रक्रिया को फिर से करना चाहिए, आपको ग्राफिक्स पैकेज की मदद लेनी चाहिए, जो कि AWT java.awt.packaged में केवल ग्राफिक्स वर्ग है, जिसे java.awt.package में परिभाषित किया गया है।
और विज़ुअलाइज़ेशन से संबंधित सभी कार्यान्वयन, आप किसी अन्य पैकेज में डाल सकते हैं या आप उसी पैकेज में भी डाल सकते हैं, क्योंकि यह छँटाई, खोज, पेड़ उत्पादन और फिर विज़ुअलाइज़ेशन और सब कुछ से संबंधित है।
अब, यदि आप इस तरह के एक पैकेज का निर्माण करते हैं, तो यह मूल रूप से इस बारे में एक विचार देता है कि कोई उपयोगकर्ता अपने स्वयं के पैकेज को कैसे विकसित कर सकता है, जिसे जावा एपीआई जैसे कि java.util या java.io की तरह ही व्यवहार किया जा सकता है।
तो, इन सभी पैकेजों का आप उपयोग कर सकते हैं, और फिर आयात भी कर सकते हैं।
और फिर आगे के विकास के लिए, किसी अन्य एप्लिकेशन में मान लीजिए, आपको सभी का उपयोग करने की आवश्यकता है
एल्गोरिदम को सॉर्ट करना और खोजना।
इसलिए, इस पैकेज को आयात करें और इसका उपयोग करें।
तो, इस तरह से कोड पुन: प्रयोज्य का अधिकतम स्तर पर आनंद लिया जा सकता है, और फिर आप इसका उपयोग कर सकते हैं।
दरअसल, सॉफ्टवेयर इंजीनियर या कोई सॉफ्टवेयर प्रैक्टिशनर, वे इस तरह की प्रक्रिया का पालन करते हैं।
वे कोड विकसित करते हैं, प्रत्येक संग्रहीत या आर्किटेक को कोड करते हैं।

और जब भी आप कोड लिखते हैं, और फिर सभी सिस्टम और सब कुछ पर्याप्त टिप्पणियां देते हैं, ताकि बाद के चरण में सभी टिप्पणियां यदि आपके लिए कोई अन्य उत्तराधिकारी हैं, तो उन्हें उस कार्यक्रम को विकसित करने की जिम्मेदारी दी जा सकती है जो वे इसका उपयोग कर सकते हैं, ताकि यह टिप्पणी बहुत आवश्यक है।
हर लाइन, हर स्टेटमेंट, हर क्लास में एक अच्छा कमेंट और एनोटेशन होना चाहिए, जिससे आपको इस बात का अंदाजा हो जाएगा कि कैसे दो अलग-अलग प्रोजेक्ट विकसित किए जा सकते हैं।
और मुझे आशा है कि यदि आप उन सभी परियोजनाओं को लागू करने के लिए खुद को शामिल कर सकते हैं, तो यह वास्तव में आपके कौशल में सुधार करेगा।
शुक्रिया और शुभकामनाएं।
कम्प्यूटर साइंस इंजीनियरिंग इंडियन इंस्टीट्यूट ऑफ टेक्नोलॉजी, खड़गपुर लेक्चर - 03 जावा टूल्स एंड रिसोर्सेज में जावा प्रो। देबासीस सामंत विभाग में प्रोग्रामिंग, इसलिए हमने पिछले दो व्याख्यानों में जावा के बारे में बहुत ही बुनियादी बातों के बारे में सीखा है।
अब, हम देखेंगे कि वे कौन से उपकरण और संसाधन हैं जो आपके पास स्वयं की सुरक्षा के लिए होने चाहिए ताकि आप अपना खुद का प्रोग्राम ब्रांड विकसित कर सकें, अपने स्वयं के कार्यक्रम और इन सभी चीजों का परीक्षण कर सकें।
इसलिए, आज के व्याख्यान में वे उपकरण और संसाधन शामिल हैं जो आप सोच सकते हैं।
तो, कि आप में उपयोग कर सकते हैं और फिर आप अपने प्रोग्रामिंग वातावरण तैयार कर सकते हैं।
तो, जावा प्रोग्रामिंग टूल्स पहले मैं इसके बारे में चर्चा करना चाहूंगा।
अब, एक बहुत ही दिलचस्प बात यह है कि सब कुछ मुफ्त है;
इसका मतलब है, जावा उपकरण जो स्वतंत्र रूप से उपलब्ध हैं, आप इसे नेट से डाउनलोड कर सकते हैं और फिर आप इसका उपयोग कर सकते हैं।
तो, जिस चीज की आवश्यकता है, वह यह है कि आपके पास अपनी मशीन का एक लैपटॉप होना चाहिए, चाहे वह खिड़कियां हों यह Macintosh है या यह Solaris है बिल्कुल यह कोई मुद्दा नहीं है जो आपके पास है।
और फिर आप विभिन्न लिंक से प्रोग्राम डाउनलोड कर सकते हैं।
इसलिए, मैं आपको अलग-अलग लिंक बताऊंगा जो उपलब्ध है, और फिर हम इसका उपयोग कर सकते हैं।
तो, मूल रूप से जेडीके;
एक बार जब मैंने आपको बताया कि JDK को जावा डेवलपमेंट किट कहा जाता है।
यह मूल भवन है
जिसे ब्लॉक कहा जाता है, या बुनियादी निर्माण उपकरण मूल रूप से हम इसे लोड कर सकते हैं।
और एक बार लोड करने के बाद आप इसे इंस्टॉल कर सकते हैं।
तो, JDK को जावा स्रोत से सीधे लोड किया जा सकता है, JavaSoft आपको बस Google में आपको इंडेक्स JDK देता है।
और फिर आप बहुत सारे लिंक पा सकते हैं और सभी मुफ्त लिंक हैं जिसका मतलब है कि वे स्वतंत्र रूप से डाउनलोड करने योग्य हैं।
और इसलिए, अब तक JDK का संबंध है, कई संस्करण हैं जिन्हें SDK संस्करण और JDK संस्करण कहा जाता है।
मुझे आपको एसडीके डाउनलोड करने का सुझाव नहीं देना चाहिए, एसडीके उन्नत प्रोग्रामर के लिए है इसे सुपर डेवलपमेंट किट कहा जाता है, जो अनावश्यक रूप से आपके सिस्टम को धीमा बनाने के लिए कई विशेषताएं हैं, इसका उपयोग न करना बेहतर है।
और इसलिए, अब तक JDK का संबंध है जो 1996 में पहली बार पेश किया गया था, उसके बाद बहुत सारे संस्करण समय तक उपलब्ध हैं।
नवीनतम संस्करण जो आपके पास 11 हो सकते हैं, लेकिन मूल प्रोग्रामर के शुरुआती के लिए आपको JDK संस्करण 8 का उपयोग करना चाहिए, JDK संस्करण आठ सबसे बहुमुखी सबसे परिपक्व है और फिर इसका उपयोग करना आसान है।
इसलिए, मुझे आपको अपनी मशीन में JDK संस्करण 8 डाउनलोड करने का सुझाव देना चाहिए और फिर अपनी मशीन में वही स्थापित करना चाहिए।
तो, यह आपके सभी काम करने के लिए जावा सॉफ्टवेयर को पूरा करेगा।
अब, अगला देखते हैं कि आपके JDK टूल में क्या चीजें हैं।
जेडीके मूल रूप से एक बंडल है;
इसका मतलब है, इसमें कई कार्यक्रम शामिल हैं।
अब, यहां मैंने उन कार्यक्रमों को सूचीबद्ध किया है जो वहां जेडीके में हैं, मैं कह सकता हूं कि जेडीके या एसडीके हैं दोनों चीजें समान हैं, वास्तव में सात कार्यक्रम हैं।
मैंने पहले से ही एक कार्यक्रम के बारे में चर्चा की है;
इसका मतलब है, डॉट जावा फ़ाइल को डॉट क्लास फ़ाइल में कैसे ट्रांसलेट किया जाए, इसे जेवैक कहा जाता है।
तो, javac है यह मूल रूप से जावा संकलक है, तो जावा एक और कमांड जिसे हमने प्रोग्राम को चलाने के लिए उपयोग किया है इसे जावा दुभाषिया कहा जाता है।
तो, ये दो प्रोग्राम हैं जो बहुत बार उपयोग किए जाते हैं जो कि JDK में बंडल में होते हैं।
कुछ बड़े प्रोग्राम सॉफ़्टवेयर डेवलपमेंट के लिए इसके अलावा जहाँ हमें एक डॉक्यूमेंटेशन करना होता है;
इसका मतलब है कि बड़े सॉफ्टवेयर के लिए अलग-अलग प्रलेखन की आवश्यकता होती है और इसके लिए एक उपकरण उपलब्ध है जिसे जावदोक कहा जाता है जिसे जावदोक का उपयोग करके आप अपने स्वयं के कार्यक्रम में बहुत ही शांत और आरामदायक प्रलेखन कर सकते हैं ताकि आपके द्वारा लिखा गया कार्यक्रम किसी अन्य प्रोग्रामर द्वारा समझ सकें, जो इन सभी चीजों के लिए अपने कार्यक्रम का विस्तार करना चाहता है।
तो, एक टीम के काम में यदि आप एक प्रोग्राम विकसित करना चाहते हैं जावा डॉक्टर निश्चित रूप से उपयुक्त है और आपको इसे जानना चाहिए।
तब एप्लेटव्यूअर एक और कार्यक्रम है और एप्लेटव्यूसर मूल रूप से जावा एप्लेट को चलाने के लिए है।
जावा एप्लेट के बारे में हम चर्चा करेंगे कि यह एक ब्राउज़र प्रोग्राम की तरह है।
तो, यह मूल रूप से HTML फ़ाइल को चलाता है जिसमें कुछ जावा कोड होता है।
तो, एप्लेटव्यूअर मूल रूप से जावा एपलेट को एक विशेष प्रकार का जावा प्रोग्राम चलाने वाला है, जो मूल रूप से विंडो प्रोग्रामिंग के लिए उपयुक्त है, या एक ग्राफिकल यूजर इंटरफेस प्रोग्राम डेवलपमेंट है।
फिर जावा डीबगर।
इसलिए, यदि आपके पास अपने कार्यक्रम में कक्षाओं का बहुत बड़ा सेट है, तो कभी-कभी यह वांछित आउटपुट नहीं दे रहा है।
फिर आपको डिबग करना पड़ सकता है;
इसका मतलब है, जहां यह है वहां त्रुटि को ढूंढें।
इसलिए, इस डिबगिंग के लिए JDK आपको एक बहुत ही कुशल और फिर आसान टूल सेट प्रदान करता है जिसे JDK कहा जाता है यह जावा प्रोग्राम में त्रुटियों को ठीक करने के लिए जावा डिबगर को विकसित करने के लिए है।
और फिर जावा डिस्सेम्बलर इसे जावप कहा जाता है जो मूल रूप से विघटित होता है, यदि आप प्रोग्राम बनाना चाहते हैं यदि यह बहुत ही जटिल और कई घटकों में बड़ा प्रोग्राम है।
तो, javap मूल रूप से आपको अपने प्रोग्राम को छोटे प्रोग्राम सेट में बदलने की अनुमति देगा और फिर यह एक उपकरण भी है जिसका उपयोग आप कर सकते हैं और फिर कर सकते हैं।
और फिर एक JDK में शामिल एक और सुविधाएं javah है।
और यह मूल रूप से जावा और अन्य प्रोग्रामिंग के बीच एक इंटरफ़ेस बनाने में हमारी मदद करता है विशेष रूप से सी रूटीन या सी ++ रूटीन, यहां मूल रूप से जावा का उपयोग प्रोग्राम के कुछ हिस्से को माना जाता है जिसे आप सी में विकसित करना चाहते हैं और फिर एक और प्रोग्राम हिस्सा जिसे आप जावा में विकसित करना चाहते हैं। ।
और फिर दोनों चीजों को एक साथ जोड़ने की जरूरत है।
ताकि, वे एक साथ काम कर सकें, इस मामले में आप javah का उपयोग कर सकते हैं एक ऐसी सुविधा है जो वहां JDK में बंडल है।
इस [एफएल] प्रोग्रामिंग को सीखने के दौरान आपको कुछ और संसाधन चाहिए, जिन्हें आपको सीखना चाहिए और साथ ही इस कोर्स में भाग लेना चाहिए और एक बहुत ही महत्वपूर्ण लिंक है इसे बहुत लोकप्रिय कहा जाता है इसे javatpoint एक ट्यूटोरियल बिंदु कहा जाता है।
इसलिए, उदाहरणों और दृष्टांतों की तुलना में इसका बहुत बड़ा समूह है और फिर केवल यह याद आ रहा है कि वे सिद्धांत या किसी अवधारणा के बारे में चर्चा नहीं करते हैं।
इसलिए, उदाहरणों और दृष्टांतों की तुलना में इसका बहुत बड़ा समूह है और फिर केवल यह याद आ रहा है कि वे सिद्धांत या किसी अवधारणा के बारे में चर्चा नहीं करते हैं।
तो, यह पाठ्यक्रम के शुरुआती लोगों के लिए इतना उपयुक्त नहीं है, लेकिन आप इस स्रोत से कुछ प्रोग्रामिंग पर कम से कम कुछ हाथ रख सकते हैं।
तो, यह एक javatpoint और जावा एक और कुछ मेरा मतलब है कि प्रलेखन आप जावा वेबसाइट से ही डाउनलोड कर सकते हैं।
तो, कई दस्तावेज बहुत विशाल दस्तावेज हैं बेशक, कभी-कभी यदि आप इस कार्यक्रम को एक छोटे से साधन में कह सकते हैं कि शायद 3 महीने या 2 महीने में, तो उन सभी चीजों को सीखना वास्तव में उपयुक्त नहीं है।
और यह प्रलेखन निश्चित रूप से अच्छा है और उन्नत प्रोग्रामर के लिए बेहतर है।
इसलिए, यदि आप एक उन्नत प्रोग्रामर नहीं हैं, तो इस कार्यक्रम को फिलहाल उपयोग नहीं किया जाना चाहिए।
बाद में जब भी आप कुछ बुनियादी चीजें सीखते हैं, तो आप इसे तब उपयोग कर सकते हैं जब एक और अधिक उन्नत कदम के रूप में।
और कुछ और संसाधन भी उपलब्ध हैं, जिन्हें आप परामर्श कर सकते हैं, वह फिर से सूर्य जावा वेबसाइट से ही है यह एक बहुत ही प्रामाणिक दस्तावेज है वास्तव में दस्तावेज में कोई त्रुटि नहीं है।
तो, एक त्रुटि मुक्त दस्तावेज़ीकरण है और फिर बहुत ही पेशेवर रूप से दस्तावेज़ीकरण बनाए रखना है, यह जावा डॉट सन डॉट कॉम से है जो सूर्य मूल वेबसाइटों से है।
और एक अन्य सूरज डेवलपर नेटवर्क भी कई अन्य संसाधनों के लिए उपलब्ध है।
यह सन माइक्रोसिस्टम्स की आधिकारिक वेबसाइट से भी है, जहां कई पैकेजों के बारे में दस्तावेज हैं।
वास्तव में जावा में JDK में कई अन्य पैकेज भी शामिल हैं, उन पैकेजों को एपीआई कहा जाता है।
अब इस पैकेज के बारे में यह पैकेज मूल रूप से एक पुस्तकालय है।
इसलिए, यदि आप इस पुस्तकालयों के बारे में जानना चाहते हैं और पुस्तकालयों में कौन-कौन सी कक्षाएँ हैं और क्या कार्य विधियाँ या संचालन हैं जो सभी वर्ग हम आपके लिए करेंगे, तो एपीआई दस्तावेज।
उन एपीआई प्रलेखन भी आप इसे जावा डॉट सन डॉट कॉम वेबसाइट से प्राप्त कर सकते हैं।
तो, ये बहुत महत्वपूर्ण दो लिंक हैं जो आपके पास हो सकते हैं।
अब, मैं एपीआई के बारे में बात कर रहा था और एक पूर्ण रूप अनुप्रयोग प्रोग्रामिंग इंटरफ़ेस है।
अब, जावा इस एपीआई के कारण बहुत अच्छा है, जावा एपीआई मूल रूप से एक बहुत बड़ा एक बड़ा संसाधन है।
और वास्तव में, मेरा मतलब है कि नौ पैकेज और प्रत्येक पैकेज में बड़ी संख्या में कक्षाएं और उनकी परिभाषाएं होती हैं और फिर उनका उपयोग होता है।
तो, यह सभी कक्षाएं आप अपने कार्यक्रम में उपयोग कर सकते हैं;
इसका मतलब है, मूल रूप से प्रोग्रामर समर्थन करता है।
तो, वहाँ नौ पैकेज हैं और फिर सभी पैकेजों को मूल रूप से अलग-अलग कार्य के लिए वर्गीकृत किया जाता है।
अब उदाहरण के लिए, एक पैकेट पैकेज है जिसे एप्लेट कहा जाता है।
तो, इस पैकेज को आमतौर पर java.applet कहा जाता है।
तो, यह पैकेज मूल रूप से एप्लेट्स में एप्लेट मैनुअल प्रोग्रामिंग लिखने के लिए एप्लेट लिखने के लिए उपयुक्त है।
तो, एप्लेट्स जैसा कि मैंने आपको पहले ही बताया था कि एप्लेट ग्राफिकल यूजर इंटरफेस डिजाइन करने के लिए है, ग्राफिकल यूजर इंटरफेस का मतलब है बटन, फिर चेकबॉक्स कॉल विंडो, फिर टेक्स्ट फील्ड एरिया ये सारी चीजें।
तो, यह मूल रूप से एप्लेट पैकेज है जो आपको ग्राफिकल यूजर इंटरफेस बनाने में बहुत आसानी से मदद करेगा, बिना इस बारे में जानकारी के कि वे यह कैसे कर रहे हैं यह एक जादू की तरह है अगर आप जानते हैं कि ठीक है।
यह एक वर्ग है जिसे आपको अपना बटन बनाने के लिए उपयोग करना चाहिए और फिर इसका उपयोग करना चाहिए और फिर इसे इस तरह चलाना चाहिए।
अब, तो जावा एप्लेट एक सही एप्लेट प्रोग्रामिंग के लिए है और एप्लेट प्रोग्रामिंग के संबंध में एप्लेट प्रोग्रामिंग एक बहुत ही अतीत की अवधारणा है, और हम जल्द ही सीखेंगे।
और फिर एक और पैकेज है पैकेज का नाम जावा डॉट कहा जाता है
AWT इसे जावा अमूर्त विंडोिंग टूलकिट कहा जाता है।
तो, अमूर्त विंडोिंग टूलकिट मूल रूप से एक और विस्तार है या जीयूआई कार्यक्रमों को विकसित करने के लिए मूल रूप से समर्थन है।
फिर इनपुट आउटपुट हैंडलिंग के बारे में एक और पैकेज, आप इनपुट के अलग-अलग तरीकों को याद कर सकते हैं, इनपुट पर विचार किया जा सकता है, माउस से इनपुट, माइक्रोफ़ोन से इनपुट, दस्तावेज़ से इनपुट, हस्तलिखित से इनपुट, इशारे जो कुछ भी हो, ऐसा इनपुट से नेटवर्क से छवि इनपुट, तो, इनपुट के कई संस्करणों से कैसे निपटें।
तो, एक पैकेज है .io पैकेज java.io जो मूल रूप से आपको कई स्रोतों से इनपुट लेने में मदद करता है और फिर अपने प्रोग्राम में इसका उपयोग करता है और फिर आवश्यकता के अनुसार उत्पादन करता है।
तो, java.io मूल रूप से उपयुक्त है। java.lang एक और पैकेज है जो मूल रूप से अक्सर इस्तेमाल किया जाने वाला पैकेज है;
इसका मतलब है, एक प्रोग्राम जिसे हमेशा एक पैकेज की आवश्यकता होती है जो कि java.lang पैकेज है, आप java.lang पैकेज के बिना कोई भी प्रोग्राम नहीं लिख सकते हैं।
चूंकि यह पैकेज बहुत महत्वपूर्ण और आवश्यक है और सभी कार्यक्रम में इसकी आवश्यकता होती है।
तो, यह स्पष्ट रूप से आयात करने की आवश्यकता नहीं है कि इसका मतलब यह स्वचालित रूप से आपके कार्यक्रम में शामिल होगा, भले ही आप इनपुट न करें।
हालांकि, अन्य पैकेज यदि आप इसका उपयोग करना चाहते हैं, तो उपयोग करने से पहले उन्हें आपके कार्यक्रम में आयात किया जाना चाहिए।
मैं आपको बताऊंगा कि अपने प्रोग्राम या किसी विशेष वर्ग के पैकेज को कैसे आयात करें जो आपके प्रोग्राम में किसी विशेष पैकेज से संबंधित है।
तो, यह अवधारणा;
इसका मतलब है कि, एक विशेष सुविधा यह है कि जिसे आपके प्रोग्राम में आयात किया जा सकता है, जबकि java.lang एक डिफ़ॉल्ट पैकेज है जिसे स्वचालित रूप से आयात किया जा सकता है, और यह मूल रूप से आपको मूल प्रोग्रामिंग सुविधाएं देता है जो आपके पास हो सकता है यदि आपके पास यह java.lang है पैकेज।
इसलिए, नौ पैकेजों में से हमने 5 पर चर्चा की है;
कुछ और महत्वपूर्ण पैकेज जावा डॉट नेट जैसे कुछ और पैकेज हैं, नेट मूल रूप से नेटवर्क प्रोग्रामिंग के लिए उपयुक्त पैकेज है।
जावा प्रोग्रामिंग में नेटवर्किंग एक बहुत ही महत्वपूर्ण विशेषता है।
तो, हमारे पास हमारे नेटवर्क प्रोटोकॉल नेटवर्क प्रोग्रामिंग, सॉकेट प्रोग्रामिंग को इस तरह से विकसित करने के लिए जावा डॉट नेट पैकेज हो सकता है और java.util;
इसका उपयोग मूल रूप से एक उन्नत एक प्रोग्रामिंग है जो मूल रूप से आपको कई देता है जिसे अंतर्निहित डेटा संरचना कहा जाता है।
जैसा कि आप जानते हैं कि डेटा संरचना प्रोग्रामिंग के लिए एक बहुत महत्वपूर्ण अवधारणा है;
इसका मतलब है, आपको डेटा को एक कुशल तरीके से संग्रहीत करना होगा, आप डेटा को एक कुशल तरीके से कैसे संग्रहीत कर सकते हैं, इसके बारे में डेटा संरचना बताती है।
ढेर, कतार, लिंक्ड सूची और वेक्टर जैसी कई डेटा संरचना इन सभी चीजों को आसानी से पैकेज java.util में परिभाषित किया गया है। एक महत्वपूर्ण शब्दकोश डेटा संरचना को शब्दकोश कहा जाता है;
इसका मतलब है, आप किसी भी भाषा के लिए किसी भी भाषा के लिए एक शब्दकोष बना सकते हैं या चिकित्सा शब्दावली या जो कुछ भी है उसके लिए शब्दकोश बना सकते हैं।
तो, शब्दकोश डेटा संरचना पहले से ही मौजूद है, डेटा संरचना का अर्थ है कि संरचना को कैसे परिभाषित किया जाए और फिर उस पैकेज में पहले से ही परिभाषित संचालन क्या हैं।
तो, आप बस इसके बारे में जानते हैं, कि क्या सुविधाएं उपलब्ध हैं और फिर आप अपने प्रोग्राम में प्लग इन कर सकते हैं और फिर उसका उपयोग कर सकते हैं।
उसके बाद जावा में जो एक उन्नत पैकेज हैं, उन्हें बाद में शामिल किया गया है, पहले के संस्करण में यह जावा संस्करण 5 नहीं था, बाद में इस पैकेज का उपयोग किया जाता है, इसे AWT की तरह स्विंग, स्विंग कहा जाता है।
लेकिन यह जावा प्रोग्रामिंग में अधिक दिलचस्प और अधिक प्यारी चीजें हैं, जावा स्विंग मूल रूप से GUI विकास का समर्थन करने के लिए AWT अमूर्त विंडोिंग टूलकिट का एक और विस्तार है।
और जावा डेटाबेस कनेक्टिविटी के लिए एक पैकेज है जिसे java.SQL कहा जाता है। तो, इस पैकेज का उपयोग करते हुए, आप अपने एप्लिकेशन से दूरस्थ सर्वर डेटाबेस से कनेक्ट कर पाएंगे।
तो, ये विभिन्न पैकेज हैं, जो जावा वातावरण में उपलब्ध हैं।
और यदि आप एक बार JDK को उन सभी प्रोग्राम्स के साथ इंस्टॉल कर लेते हैं, जिनकी हमने पहले ही चर्चा की है जैसे कि javac, javap और javaap, javah इन सभी चीजों के अलावा यह सब API भी अपने आप इंस्टॉल हो जाएगा।
तो, JDK में मूल रूप से सब कुछ शामिल है।
अब, हमने उस मुफ्त सॉफ्टवेयर के बारे में बताया जो कि उपलब्ध है, यह सभी सॉफ्टवेयर मुफ्त हैं;
हालाँकि, जैसा कि जावा बहुत लोकप्रिय है और फिर कई सॉफ्टवेयर डेवलपर कई सॉफ्टवेयर इंजीनियरिंग फर्म हैं, वे प्रोग्राम को बड़े पैमाने पर विकसित करते हैं, प्रोग्राम को समर्थन देने के लिए बड़े पैमाने पर और परिष्कृत प्रोग्रामिंग वातावरण सभी पहले से ही बाजार में उपलब्ध है।
हालांकि, यह मुफ्त महंगा नहीं है।
कुछ सॉफ्टवेयर विकास पर्यावरण हैं इसे आईडीई कहा जाता है पूर्ण रूप एकीकृत विकास पर्यावरण है।
इसलिए, उदाहरण के लिए बहुत सारे आईडीई उपलब्ध हैं, सन माइक्रोसिस्टम से ही एक आईडीई उपलब्ध है, लेकिन यह मुफ़्त नहीं है, केवल वाणिज्यिक उद्देश्य के लिए जिसे सन की जावा कार्यशाला कहा जाता है।
यह बहुत अच्छा एक वातावरण है जो आपको अपने कार्यक्रम को बहुत आसानी से और उपयोगकर्ता के अनुकूल तरीके से विकसित करने में मदद कर सकता है।
मोजो एक अच्छा मेरा मतलब है कि अल्पविराम लोकप्रिय एक सॉफ्टवेयर विकास वातावरण है, यह पेनम्ब्रा सॉफ्टवेयर से है जो मूल रूप से जावा एप्लेट बनाने के लिए उपयुक्त कंपनी है।
इसी तरह, जुंबा Aimtech और IBM से है, यह जावा एप्लेट प्रोग्रामिंग के लिए भी उपयुक्त एक वातावरण है।
और मैंने जो सबसे अच्छा देखा है उसे सिमेंटिक कैफे कहा जाता है, यह एक बहुत अच्छी तरह से ज्ञात बहुत लोकप्रिय और बहुत ही परिष्कृत एक प्रोग्रामिंग वातावरण है जिसे सिमेंटिक कैफे कहा जाता है।
इसलिए, यदि आप खर्च कर सकते हैं तो आप एक अर्थिक कैफे खरीद सकते हैं और फिर अपनी मशीन में इंस्टॉल कर सकते हैं, इस सॉफ़्टवेयर में आपका JDK एपीआई प्रोग्राम और अन्य प्रोग्राम शामिल नहीं हैं।
तो, यह आपको बहुत डिबगिंग, परीक्षण करने में मदद करेगा, सब कुछ एक साथ रखना एक बहुत अच्छा प्रोग्रामिंग और पर्यावरण शब्दार्थ कैफे है, लेकिन यह व्यावसायिक रूप से मुक्त नहीं है लागत वास्तव में बहुत अधिक है व्यक्तिगत रूप से स्तर यह वहन करना बहुत मुश्किल है।
तो, ये वे उपकरण हैं जो मुझे जावा प्रोग्रामिंग वातावरण के लिए तीसरे पक्ष के उपकरण कहने चाहिए।
और सॉफ्टवेयर ब्राउज़ करने के लिए कुछ उपकरण भी उपलब्ध हैं;
इसका मतलब है, जैसा कि आप जानते हैं कि जावा इंटरनेट प्रोग्रामिंग और इंटरनेट के लिए उपयुक्त है
प्रोग्रामिंग का अर्थ है बहुत सारे वेबपेज प्रोग्रामिंग जेए जेएसपी जावा स्क्रिप्ट या जावा ब्राउज़र संबंधी प्रोग्रामिंग।
तो, बहुत सारे ब्राउज़र भी आवश्यक हैं, पहले जब जावा शुरू में इंटरनेट एक्सप्लोरर जैसे सभी ब्राउज़रों को पेश किया गया था, तब ये सभी चीजें समर्थन कर रही हैं।
अब-एक-दिन यह सभी ब्राउज़र जावा ब्राउज़िंग का समर्थन करना बंद कर देते हैं, इसलिए कुछ सुरक्षा मुद्दे हैं।
इसलिए, सभी ब्राउज़र इसे वास्तव में सीधे ब्राउज़ करने के लिए आपके जावा प्रोग्राम का समर्थन नहीं कर सकते हैं, लेकिन दूसरे तरीके से इसे ब्राउज किया जा सकता है और इसे निष्पादित किया जा सकता है।
कई सुरक्षा कारण हैं कि क्यों अलग-अलग ब्राउज़र ने जावा प्रोग्राम को दूरस्थ रूप से चलाना बंद कर दिया है।
और शुरू में गर्म जावा वास्तव में बहुत शुरुआत के रूप में पेश किया गया था जब जावा केवल ब्राउज़िंग उद्देश्य के लिए पेश किया गया था, लेकिन गर्म जावा अभी भी उपलब्ध है और आप इसका उपयोग कर सकते हैं, लेकिन गर्म जावा मोज़िला, सफारी या इंटरनेट एक्सप्लोरर की तरह लोकप्रिय नहीं है लोकप्रिय नेटस्केप नेविगेटर भी एक ब्राउज़र के रूप में उपलब्ध है यह विंडोज़ एनटी पर्यावरण या कुछ अन्य यूनिक्स पर्यावरण नेट स्कोर नेविगेटर उपलब्ध है।
यह भी एक पूर्ण चरण में जावा का समर्थन करता है।
तो, ये वे ब्राउज़र हैं जिनके बारे में आप सोच सकते हैं, लेकिन जब आप जावा प्रोग्रामिंग सीखते हैं तो आप आमतौर पर एप्लेट व्यूअर का उपयोग जावा ब्राउजिंग के रूप में करते हैं।
तो, एप्लेट दर्शक सीखने और अभ्यास करने के लिए ठीक है, लेकिन जब भी आपको कार्यक्रम को तैनात करना है, तो आकृति और अलग-अलग तकनीक की विभिन्न अवधारणा का पालन करना होगा।
उस पर बाद में चर्चा की जाएगी, लेकिन यहां पर हम किसी भी अन्य ब्राउज़र के बारे में चर्चा नहीं करेंगे, जब भी हमें जावा एप्लेट या जावा प्रोग्राम चलाना होगा, हम एप्लेट व्यूअर को एप्लेट ब्राउजर के रूप में फॉलो करेंगे।
उपलब्ध कुछ और महत्वपूर्ण संसाधन हैं मुझे यकीन नहीं है कि यह मुफ्त संस्करण में उपलब्ध है या नहीं।
जाहिर है, नि: शुल्क सॉफ्टवेयर उपलब्ध है जो नेट बीन को सक्षम करने के लिए पूर्ण कार्यक्षमता में नहीं है।
नेट बीन बहुत बड़े सॉफ्टवेयर के निर्माण के लिए बहुत प्रसिद्ध है यह सिर्फ एक आईडीई एकीकृत विकासशील वातावरण है।
यह उपलब्ध है तो नि: शुल्क है;
जाहिर है, सभी सुविधाएं उपलब्ध नहीं हो सकती हैं, लेकिन यह कम से कम कुछ आवश्यक विशेषताएं हैं जो आपके पास हो सकती हैं, यह एक आईडीई है।
तो, कम से कम कुछ आईडीई स्वतंत्र रूप से अगर यह उपलब्ध है, तो यह शुद्ध बीन है जिसे आप स्थापित कर सकते हैं और फिर इस नेट बीन्स का उपयोग करके अपने जावा प्रोग्राम को चला सकते हैं।
और एक संपादक को मुझे इसका उल्लेख करना चाहिए जो बहुत अच्छा एक संपादक है और बहुत परिष्कृत और बहुमुखी संपादक है जिसे नोटपैड ++ कहा जाता है।
क्योंकि आपको प्रोग्राम को चलाना है, आपको प्रोग्राम को सेव करना है और प्रोग्राम को टाइप करने के लिए उन सभी चीजों को जितनी जल्दी हो सके।
तो, कुशलता से आप यह कर सकते हैं।
तो, नोटपैड ++ अत्यधिक अनुशंसित है।
तो, आप इसे डाउनलोड कर सकते हैं नोटपैड + + फिर से एक मुफ्त सॉफ्टवेयर है।
तो, आप स्वतंत्र रूप से डाउनलोड कर सकते हैं और अपनी मशीन में स्थापित कर सकते हैं और फिर एक डिफ़ॉल्ट संपादक के रूप में उपयोग कर सकते हैं।
आप संपादक को डिफ़ॉल्ट के रूप में बना सकते हैं।
अब तो, हम जावा भाषा जावा उपकरण और जावा संसाधनों के बारे में जान चुके हैं, जिन्हें आपको पकड़ना चाहिए, इससे पहले कि आप अपने आप को जावा प्रोग्रामिंग वातावरण में गर्म कर लें और जावा प्रोग्रामर बन जाएं।
इस तरह की बातें होती हैं।
तो, कई लगातार और फिर आम चीजें हैं।
तो, इस स्लाइड में कई सामान्य चीजें शामिल हैं जो आपके जावा प्रोग्रामिंग जावा प्रोग्रामिंग में हैं, या जब आप जावा प्रोग्राम लिखते हैं तो आपको इसका उपयोग करना होगा।
जाहिर है, पहली बार प्रोग्रामर के लिए उन सभी चीजों को समझना थोड़ा मुश्किल लगता है, लेकिन एक बार जब आप इसका अभ्यास करते हैं और फिर इसे शामिल करते हैं।
तो, आपको धीरे-धीरे यह सब शब्द की आदत हो जाएगी।
तो, ये सबसेट हैं और मैं सिर्फ इस सबसेट चर्चा को छोड़ना चाहता हूं, क्योंकि यह धीरे-धीरे सीखी जाएगी, लेकिन लगातार हम इसे सीखेंगे, ठीक है।
तो, ये मूल रूप से मानक डेटा प्रकार हैं, यदि आप सी प्रोग्रामिंग जानते हैं तो आप निश्चित रूप से जानते हैं कि डेटा प्रकार क्या हैं, उन्हें बिल्टेन की तरह डेटा प्रकार या आदिम डेटा प्रकार में निर्मित कहा जाता है।
बूलियन एक डेटा प्रकार है जिसके द्वारा हम एक चर घोषित कर सकते हैं, जो स्टोर करने के लिए केवल 1 बिट रिकॉर्ड करता है।
और फिर बाइट:
बाइट एक नया डेटा प्रकार है जो जावा में सी ++ में भी है और यह वहां भी है, और जावा में सी प्रोग्रामिंग में भी चार्ट है और शॉर्ट है।
इसके अलावा कुछ और डेटा प्रकार हैं जैसे int, long, float, double अगर आप C प्रोग्रामिंग जानते हैं तो आप उसे देख सकते हैं।
ये कुछ डेटा प्रकार हैं जो जावा में सी में भी हैं और वास्तव में यदि आप सी प्रोग्रामिंग जानते हैं तो सी ++ प्रोग्रामिंग सीखना बहुत आसान है।
और अगर आप C ++ प्रोग्रामिंग जानते हैं, तो जावा प्रोग्राम सीखना भी बहुत आसान है।
वैसे भी, लेकिन अगर आप C ++ प्रोग्रामिंग को पूरी तरह से नहीं जानते हैं तो यह कोई समस्या नहीं है, लेकिन कई चीजें बहुत आम हैं।
तो, सिंटैक्स कमांड्स और इन सभी चीजों के लिए, सी प्रोग्रामिंग में वहाँ जावा प्रोग्रामिंग में भी हैं।
तो, यह जावा प्रोग्रामिंग वातावरण का सामना करने के लिए सी प्रोग्रामर के लिए एक अतिरिक्त लाभ है।
अब तक, डेटा प्रकार इन सभी डेटा प्रकारों से चिंतित है, जिन पर हमने चर्चा की है कि वे डेटा प्रकार में निर्मित हैं, या बस उन्हें आदिम कहा जाता है।
क्योंकि वे कंपाइलर द्वारा पहले से विकसित डेटा टाइप हैं, कंपाइलर स्वचालित रूप से समझ सकते हैं कि आपको इस सभी डेटा प्रकार के बारे में कुछ भी परेशान करने की आवश्यकता नहीं है।
बिल्ट इन डेटा टाइप जो है
सीखने के लिए और अधिक दिलचस्प है और आपको इसे और अधिक कुशलता से सीखना चाहिए, ताकि आपके पास जावा प्रोग्रामिंग में एक विशेषज्ञ हो, एक संदर्भ डेटा प्रकार कहलाता है।
संदर्भ डेटा प्रकार मूल रूप से आपके स्वयं के डेटा प्रकार को हमारे अपने प्रकार के डेटा को परिभाषित करता है।
जैसा कि मैंने आपको बताया कि ऑब्जेक्ट भी एक प्रकार का डेटा है।
तो, संदर्भ प्रकार इसे कहा जाता है, या सार डेटा प्रकार, या ग्राहक परिभाषित डेटा प्रकार कहा जाता है।
इसलिए, संदर्भ डेटा प्रकार के बारे में हम इस पाठ्यक्रम में विवरणों पर चर्चा करेंगे, हम इस बारे में सीखते हैं कि संदर्भ डेटा प्रकार क्या हैं, और इसे कैसे विकसित किया जा सकता है, इसका उपयोग कैसे किया जा सकता है कि इसे अभी कैसे संशोधित किया जा सकता है।
तो, अब तक जावा चरित्र शीट;
इसका मतलब है, यदि आप एक प्रोग्राम लिखना चाहते हैं, तो आपको किस चरित्र का उपयोग करना चाहिए और किस चरित्र का उपयोग नहीं करना चाहिए।
अब, यदि आप कीबोर्ड को देखते हैं कि क्वर्टी कीबोर्ड वहां मौजूद है, तो बहुत सारे अक्षर हैं, लेकिन सभी कुंजियों को आपको इस प्रोग्राम को टाइप करने के लिए प्रेस नहीं करना चाहिए।
वहाँ निश्चित सेट अपरकेस अक्षर A से Z होते हैं, वे लोअरकेस अक्षर होते हैं जो किसी भी z से आप अपने प्रोग्राम लेखन में उपयोग कर सकते हैं, कोई भी अंक 0 से 9 आप उपयोग कर सकते हैं और इसके अलावा A से Z और संख्याओं तक, आप उपयोग कर सकते हैं कुछ विशेष वर्ण सेट जो इस तालिका में वहां सूचीबद्ध हैं।
तो, ये वर्ण हैं जिन्हें आप उपयोग कर सकते हैं, इस वर्ण के अलावा।
यदि आप किसी अन्य वर्ण का उपयोग करते हैं, तो आपका संकलन गलत होगा कि कार्यक्रम का अनुपालन करते समय कोई त्रुटि होगी।
अब, मैं परिभाषित कर सकता हूं;
इसका मतलब है, चर या वर्ग या विधियों का नामकरण, यह कुछ नियम का पालन करना चाहिए।
वही नियम जो C प्रोग्राम में भी C भाषा में लागू होता है, जावा में भी लागू होता है।
इसका मतलब है, प्रोग्रामर को प्रोग्राम प्रोग्राम एलीमेंट्स जैसे वेरिएबल, कंटीन्यू, क्लास मेथड वगैरह दिया जाना चाहिए।
नामों में अक्षरों के अंक और अंडरस्कोर हो सकते हैं जिनके बीच में कोई स्थान नहीं है।
यह बहुत महत्वपूर्ण है और फिर रिक्त और अल्पविराम की अनुमति नहीं है, जबकि आप एक चर या पहचानकर्ता या किसी भी प्रकार का नामकरण कर रहे हैं।
पहला वर्ण एक वर्णमाला या अंडरस्कोर होना चाहिए।
यदि आप एक वेरिएबल नाम या क्लास शुरू करते हैं, तो नंबर के साथ यह कभी-कभी एक त्रुटि देता है, मेरा मतलब है कि यह आसानी से कुछ कंपाइलर में एक त्रुटि देता है जो निश्चित रूप से उन्नत सुविधाएँ है जो यह नहीं दे सकता है, लेकिन आमतौर पर इसका पालन करना उचित नहीं है, और फिर मैं एक लिखता हूं चर का नाम किसी भी सीमा का हो सकता है कोई सीमा नहीं है।
लेकिन फिर से, एक चर या प्रकार के लिए बहुत बड़ा नाम देना अनावश्यक नहीं है।
इसलिए, आपको बहुत छोटा नाम देना चाहिए, लेकिन सार्थक नाम।
और मैं और एक और बात जो आपको ध्यान में रखनी चाहिए वह यह है कि जावा प्रोग्रामिंग भाषा संवेदनशील है।
इसका मतलब यह है कि यदि आप एक चर नाम को छोटे x के रूप में घोषित करते हैं और फिर दूसरे चर नाम को पूंजी X के रूप में घोषित करते हैं, तो वे मूल रूप से दो भिन्न चर नाम हैं।
स्क्रीन पर नीचे।
फिर यदि आप कुछ और प्रिंट करना चाहते हैं, तो आपको प्लस लिखना होगा, फिर अन्य चीजें क्या हैं।
तो, यदि आप योग के लिए C का मान है तो वाक्य रचना इस तरह है।
इसलिए, जब भी हम इस कार्यक्रम पर चर्चा करेंगे, यह सब बातें हम वहां करेंगे।
अब, मैं जल्दी से चर्चा में आऊंगा कि सरणी जावा में एक बहुत महत्वपूर्ण संरचना है।
और सरणी मूल रूप से केवल एक परिवर्तनीय मूल्य या तत्वों के बजाय है, हमें कई तत्वों को किसी स्थान या चंक या मेमोरी में संग्रहीत करना है, फिर इसे सरणी कहा जाता है जो मूल रूप से परिमित सेट है, तत्वों के परिमित सेट का एक संग्रह है इसी प्रकार का;
इसका मतलब है, पूर्णांक या पूर्णांक, चरित्र या चरित्र, फ्लोट या फ्लोट।
अब, हम जल्दी से इस बारे में चर्चा करेंगे कि जावा में ऐरे को कैसे घोषित किया जा सकता है।
और फिर एक बार आप एक ऐरे को घोषित करते हैं।
फिर सरणी के लिए मेमोरी आवंटित करना भी आपकी जिम्मेदारी है।
तो, आप किसी सरणी के लिए मेमोरी कैसे आवंटित कर सकते हैं और फिर आप कैसे सरणी में मान लोड कर सकते हैं।
तो, वे चीजें हैं जिनके बारे में आप जल्दी से जान सकते हैं।
इसलिए, यदि आप किसी ऐरे को x घोषित करते हैं, तो सिंटैक्स यह वर्ग x कोष्ठक के भीतर int x है।
और फिर समाप्ति का प्रतीक अर्धविराम है जिसे आपको इसे पूरा करना होगा।
तो, यह भी वैकल्पिक int वर्ग ब्रैकेट x है उसी तरह से लोग इसका उपयोग कर सकते हैं;
इसका मतलब है, x पूर्णांक का एक सरणी है।
फिर आप एक पूर्णांक सरणी की घोषणा करते हैं, फिर आपको मेमोरी आवंटित करनी होती है, आवंटन के लिए एक ऑपरेटर होता है जिसे नया ऑपरेटर कहा जाता है जिसे मेमोरी आवंटन ऑपरेटर कहा जाता है।
तो, आपको नए का उपयोग करना होगा और सिंटैक्स जैसा है।
इसलिए, यदि आप नए हैं और फिर टाइप करते हैं;
इसका मतलब है कि आप किस प्रकार का डेटा स्टोर करना चाहते हैं और फिर यह आकार है और फिर यह मूल रूप से वह स्थान है जहां इसे संग्रहीत किया जाता है।
मूल रूप से x एक सरणी है, यह मूल रूप से 100 पूर्णांकों को सही रखने के लिए मेमोरी आवंटित करता है।
तो, यह एक तरीका है कि पूर्णांक को 100 आकार के एक सरणी में संग्रहीत किया जा सकता है।
तो, इस तरह से आप एक अरै बना सकते हैं।
और एक बार जब आप एक सरणी बना सकते हैं, तो सरणी को लूप के लिए उपयोग किया जा सकता है, जबकि इस तरह लूप।
और यहाँ भी वैकल्पिक तरीका है सरणी घोषित किया जा सकता है स्मृति को आवंटित किया जा सकता है और फिर उसी समय मूल्य संग्रहीत किया जा सकता है।
तो, यह एक सरल वाक्यविन्यास है जिसे आप उदाहरण के लिए अनुसरण कर सकते हैं, यहां एक्स की एक सरणी घोषित की जाएगी जो स्टोर करेगी;
इसका मतलब है, सरणी का आकार चार पूर्णांक है।
और फिर जो तत्व संग्रहित किया जाएगा, उसमें 12, 13, 9 और 15 हैं, जिनमें से 12 एक पहला तत्व है और एक और बात जो मुझे आपको ध्यान देनी चाहिए कि जैसे कि ऐरे इंडेक्स 0 से शुरू होता है।
तो, इसका मतलब है कि पहली सरणी स्थान 0 x 0 है और फिर x 1 x 2 और x 3 है।
तो, कुल सूचकांक इस मामले में 0 से 3 तक है जिसका अर्थ है चार तत्व।
और फिर ट्रैवर्सल और अन्य लोगों को जावा में इतनी सरणी दी जा सकती है जिस तरह से मैंने आपको पहले ही यहां बताया है, यहां एक सरल कुछ कदम आगे है।
तो, कि आप इसका अनुसरण कर सकते हैं, और फिर मैं उस सरणी के बारे में चर्चा करूंगा, जिस पर हमने चर्चा की है, एक आयामी सरणी है जावा आपको एक आयामी सरणी बनाने में मदद कर सकता है।
यहां मैं इस बारे में चर्चा करने जा रहा हूं कि जावा में दो आयामी सरणी कैसे घोषित की जा सकती हैं।
उदाहरण के लिए, सरणी का नाम समान है myArray यह आपकी सरणी है जिसे आप विकसित करना चाहते हैं जिसे आप बनाए रखना चाहते हैं और यह एक दो आयामी है।
तो, दो आयामी के लिए आपको दो वर्ग ब्रैकेट का उपयोग करना होगा।
तो, यह 2 डी की एक सरणी घोषित करता है और फिर यह मूल रूप से मेमोरी आवंटित करता है।
उदाहरण के लिए, सरणी का नाम समान है myArray यह आपकी सरणी है जिसे आप विकसित करना चाहते हैं जिसे आप बनाए रखना चाहते हैं और यह एक दो आयामी है।
तो, इसका मतलब है कि यह 3 पंक्ति 3 पंक्तियों और 4 कॉलम की एक सरणी घोषित करेगा, 3 क्रॉस 4 सरणी का नाम myArray है।
वैकल्पिक रूप से यह एक तरह से वाक्य रचना भी है जिसका उपयोग एक बिंदु पर मेमोरी को घोषित करने, परिभाषित करने और फिर आवंटित करने के लिए किया जा सकता है।
तो, यह तरीका है कि दो आयामी सरणी को इसी तरह 2 डी सरणी घोषित किया जा सकता है 3 डी सरणी का भी उपयोग किया जा सकता है।
अब, फिर से 2 डी सरणी आरंभीकरण लूप के लिए उपयोग करके किया जा सकता है।
जिस तरह से पहले आपको दो लूप करने होंगे यहाँ आपको इसका इस्तेमाल करना होगा।
अन्यथा यदि यह एक छोटा सा सरणी है, तो आप इस प्रकार के सिंटैक्स का उपयोग एकवचन एक आयामी सरणी के लिए कर सकते हैं, हमने इसे उसी तरह से उपयोग किया है।
यदि आप इसे इस तरह करते हैं तो आप जावा देखेंगे;
जावा सिस्टम इसे पहली पंक्ति में स्वचालित रूप से संग्रहीत करेगा और फिर दूसरी पंक्ति में इसे इस तरह से करेगा, यदि सरणी इस तरह है।
अन्यथा आप इसे ब्रैकेट्स के भीतर 1, 2, 3 जैसे 4, 5, 6 इस एक के भीतर और अधिक संरचना बना सकते हैं।
यदि 1 2 3 और एक रिक्त है तो वह तत्व शून्य हो जाएगा और अन्य तत्व इस तरह संग्रहीत किया जाएगा।
तो, यह अधिक कॉम्पैक्ट एक तरीका है, कि सरणी 2 डी को इनिशियलाइज़ किया जा सकता है, लेकिन यह केवल छोटे सरणियों के लिए अर्थ है, लेकिन बड़े सरणियों के लिए अच्छा नहीं है, बड़े सरणी हमें तत्वों को इनिशियलाइज़ करने के लिए लूप संरचना का उपयोग करना होगा।
और फिर चर आकार के साथ 2 डी सरणी भी हम यहां उदाहरण के लिए घोषित कर सकते हैं, इस पंक्ति में केवल 2 कॉलम इस पंक्ति में 3 4 कॉलम 3 पंक्ति में।
तो, यह एक चर आकार की सरणी भी घोषित की जा सकती है और यहां चर आकार सरणी घोषणा के लिए एक त्वरित वाक्यविन्यास है, मूल रूप से यह अवधारणा है।
तो, हम इस तरह 2 डी सरणी की घोषणा कर सकते हैं।
यहाँ पंक्ति आकार घोषित किया गया है क्योंकि यहाँ पंक्तियों की संख्या परिभाषित की गई है, लेकिन स्तंभ आकार यहाँ घोषित नहीं किया गया है, कि यहाँ इस एक का उपयोग करके निर्णय लिया जा सकता है।
इसलिए, प्रत्येक पंक्ति के लिए एक बार यह एक का उपयोग करने के बाद घोषित किया जाता है और फिर प्रत्येक कॉलम के लिए 1 को रोल करके घोषित कर सकते हैं, क्योंकि मैं प्रत्येक पंक्ति के लिए पंक्ति आकार से 0 से i के बराबर है।
हमें इसे चलाना है और फिर ये मूल रूप से सरणी का नाम है, फिर यह वह आकार है जिसे आप उदाहरण के लिए करना चाहते हैं, यहाँ 2 3 4 आप इसका उल्लेख कर सकते हैं और फिर स्तंभ आकार।
तो, इस तरह से आप किसी भी वैरिएबल साइज़ के एरे को बना सकते हैं।
अब, इसी तरह 3 डी सरणी को भी बनाए रखना संभव है जावा में भी 3 डी सरणी थोड़ा जटिल है, हमारे पास 3 डी सरणी के बारे में प्रदर्शन है, ताकि हम यहां समझ सकें।
तो, एक 3 डी सरणी आमतौर पर बस की तरह दिखते हैं।
तो, अगर यह एक 2 डी सरणी है, तो 2 डी सरणी का एक संग्रह है मूल रूप से 3 डी सरणी;
इसका मतलब है, इस पृष्ठ के लिए हम कह सकते हैं और पेज का एक संग्रह है।
इसलिए, एक पृष्ठ के प्रत्येक तत्वों को पंक्तियों और स्तंभों की संख्या तक पहुँचा जा सकता है।
तो, ij और फिर प्रत्येक पृष्ठ को k द्वारा निरूपित किया जाएगा।
तो, k k मूल रूप से यह k है, जो k 0 1 के बराबर है और यह k के बराबर है n से यदि पृष्ठों की संख्या n है।
और इसी तरह प्रत्येक पृष्ठ के लिए सिर्फ दो आयामी अवधारणा का उपयोग करके आप इस तक पहुँच सकते हैं।
तो, यहाँ एक उदाहरण है, इस उदाहरण को आप धीरे-धीरे अपने स्वयं के स्थान के साथ पालन कर सकते हैं, आप समझ सकते हैं कि यह उदाहरण मूल रूप से 3 डी सरणी कैसे घोषित किया जा सकता है और इसकी मेमोरी आवंटित की जा सकती है।
और अंत में, इसमें मौजूद विभिन्न तत्वों को लोड किया जा सकता है।
तो, यह पूरा कार्यक्रम आप इसे अपने समय के साथ धीरे-धीरे जांच सकते हैं।
और फिर आप इसे चलाने की कोशिश भी कर सकते हैं तब आप समझ सकते हैं कि यह कैसा है।
और यहां आप 2 डी सरणी के लिए कह सकते हैं हमें 3 डी सरणी के लिए 2 छोरों की आवश्यकता होगी जो हमें वास्तव में चाहिए, 3 छोरों के लिए।
उदाहरण के लिए, इस स्थिति में हम पंक्ति भिन्नता के लिए i के लिए एक लूप के लिए 3 का उपयोग करते हैं, प्रत्येक पंक्ति के लिए स्तंभ भिन्नता के लिए j के लिए एक और लूप है जिसमें प्रत्येक स्तंभ की भिन्नता है।
और फिर प्रत्येक के लिए एक स्तंभ पृष्ठ भिन्नता है।
तो, यह एक उदाहरण है, ताकि आप समझ सकें और आप इसका अभ्यास कर सकें।
इसलिए, हमने बुनियादी कुछ चीजों के बारे में सीखा है विशेष रूप से जावा उपकरण और संसाधन और फिर मूल जावा भाषा सबसेट।
और सबसेट में केवल हम जावा सरणियों के बारे में निश्चित विचार रखते हैं।
कि क्या जावा पुनरावर्ती कार्यक्रम लिखने का समर्थन करता है, शायद आप पुनरावर्ती कार्यक्रम जानते हैं और यदि आप सी प्रोग्रामिंग जानते हैं।
पुनरावर्ती कार्यक्रम लिखने के लिए सी प्रोग्रामिंग बहुत अच्छी है और पुनरावर्ती कार्यक्रम मूल रूप से बहुत जटिल और कठिन प्रोग्रामिंग संरचना लिखने का एक आसान तरीका है।
अब जावा वास्तव में, पुनरावर्ती कार्यक्रम का समर्थन करता है, तो यह सीखना दिलचस्प है कि हम जावा में पुनरावर्ती कार्यक्रम कैसे लिख सकते हैं।
और फिर जावा और सब कुछ में इनपुट आउटपुट की अन्य विशेषताएं हैं।
इसलिए, अगले व्याख्यान में हम जावा में इस सभी उन्नत सुविधाओं के बारे में चर्चा करेंगे, लेकिन इससे पहले मैं एप्लेट प्रोग्रामिंग के बारे में चर्चा करूंगा।
तो, एप्लेट प्रोग्रामिंग का एक त्वरित अवलोकन एक बार यह हमारे लिए जाना जाता है।
तब हम जावा प्रोग्रामिंग स्वादों के बारे में एक मूल विचार रख सकते हैं।
आपका बहुत बहुत धन्यवाद।
कम्प्यूटर प्रोफ़ेसर और इंजीनियरिंग इंडियन इंस्टिट्यूट ऑफ़ टेक्नोलॉजी, खड़गपुर लेक्चर - 31 I - O स्ट्रीम - II के जावा प्रो। देबासीस सामंत विभाग में प्रोग्रामिंग हमने उस I-O स्ट्रीम क्लासेस और java.io पैकेज के बारे में सीखा है।
अब देखते हैं कि इन पैकेजों में विभिन्न वर्गों का उपयोग जावा प्रोग्राम में इनपुट आउटपुट तंत्र को संसाधित करने के लिए कैसे किया जा सकता है।
इसलिए, मूल रूप से इस मॉड्यूल में कार्यक्रम में IO स्ट्रीम कक्षाओं के आवेदन की अवधारणा शामिल है।
अब, पहले हमें एक बहुत ही सरल के साथ शुरू करते हैं जिसे आप पहले से ही जानते हैं।
तो, मान लीजिए कि कुछ की गणना करने के लिए कैलकुलेटर प्रोग्राम, जो इनपुट से कुछ मूल्य पढ़ेगा, कह सकता है कि मानक इनपुट हो सकता है।
इसलिए, जिस कार्यक्रम को हम पहले से ही इस तरह के कार्यक्रम से परिचित हैं, जैसा कि हम देखते हैं।
हमने क्लासेस इनपुट इंटरेस्टकुलर का नाम दिया है जैसा कि हम यहाँ देखते हैं कि यह क्लास का नाम है और यह विधि है और इस विधि में क्योंकि इस कार्यक्रम का वास्तव में उद्देश्य एक कीबोर्ड से कुछ पढ़ना है।
अब कीबोर्ड की पहचान सिस्टम डॉट इन द्वारा की जाती है।
तो, यहाँ मूल रूप से आप System.in देख रहे हैं, इसलिए यह एक सिस्टम डॉट इन है।
अब पहले आप यह देखें कि हम आपके प्रोग्राम के लिंक को इस मानक इनपुट अर्थात् इस मामले में कीबोर्ड से कैसे जोड़ सकते हैं।
अब इस काम को करने के लिए, हमें कक्षा DataInputStream की एक वस्तु बनानी होगी।
इसलिए, हम ऑब्जेक्ट बनाते हैं और ऑब्जेक्ट के नाम के साथ रहने देते हैं और यह क्लास DataInputStream की ऑब्जेक्ट बनाने के लिए सिंटैक्स है जैसा कि आप DataInputStream = new DataInputStream (System.in) को देखते हैं।
तो, यह मूल रूप से आपके प्रोग्राम से कीबोर्ड पर एक कनेक्शन बनाता है।
कीबोर्ड यहाँ एक इनपुट स्ट्रीम स्रोत है।
अब एक बार जब आप इस ऑब्जेक्ट को बनाते हैं, तो हम इससे डेटा पढ़ सकते हैं।
अब इसे यहाँ पढ़ने के लिए हम देखते हैं, मैं डॉट रीडलाइन में उपयोग करता हूँ।
तो, in.readLine readLine एक विधि है, जो डेटा इनपुटस्ट्रीम क्लासेस के लिए java.io पैकेज में परिभाषित की जाती है।
यह मूल रूप से इकाई की संख्या जो भी पढ़ें।
उदाहरण के लिए, यदि हम 2, 4, 5 टाइप करते हैं।
इसलिए, पठन रेखा मूल रूप से 3, 4, 5 को एक साथ पढ़ती है यदि मैं 2, 4, 2 4 5.6 7 लिखता हूं।
तो, यह पूरी बात के रूप में पढ़ा जाएगा।
यदि हम कुछ स्ट्रिंग में प्रवेश करते हैं, तो यह पूरे स्ट्रिंग को पूरे एक साथ पढ़ेगा;
इसका मतलब है, रीडलाइन के बारे में विचार।
अब ऑब्जेक्ट के लिए, हम रीडलाइन को विधि कहते हैं, जो मूल रूप से पूरी चीज़ को पढ़ती है जो वर्तमान में बफर में उपलब्ध है और इसे पढ़ें।
और फिर यहां मूल रूप से हम देखते हैं कि हम यहां उदाहरण के लिए पढ़ सकते हैं, यह मूल रूप से मूल राशि को पढ़ रहा है ताकि यहां ब्याज की गणना की जा सके जिसके लिए हमें कीबोर्ड से इनपुट की आवश्यकता है और यह एक मूल राशि में संग्रहीत किया जाएगा, ब्याज की दर , वर्षों की संख्या।
तो, तीन रीडिंग यहां शामिल हैं और पहले पढ़ने में जैसा कि हम देखते हैं, हम प्रिंसिपल राशि के लिए पढ़ सकते हैं और फिर दूसरी रीडिंग में, हम ब्याज की दर के लिए पढ़ सकते हैं और हम यहां वर्षों की संख्या के लिए पढ़ सकते हैं।
अब पढ़ने के बाद, हम देख सकते हैं कि हम बाइट के रूप में इन सभी चीजों को पढ़ते हैं।
तो, यह बाइट इस बफर टेम्परिंग के रूप में यहां स्टोर है और यह मूल रूप से यह बाइट स्टोर है क्योंकि मुझे वास्तव में एक स्ट्रिंग के रूप में माना जाता है और फिर यह विधि आपको दिखाई देती है यह ध्यान रखना महत्वपूर्ण है कि यह विधि मूल रूप से रूपांतरित करती है। स्ट्रिंग क्योंकि आप एक स्ट्रिंग के रूप में रेट करते हैं और इस स्ट्रिंग को इच्छा संख्या में परिवर्तित करने की आवश्यकता होती है।
तो, यह मूल रूप से फ्लोट है।
तो, इस विधि को मूल रूप से DataInputStream द्वारा डेटा से एक स्ट्रिंग पढ़ा जाता है और एक फ्लोट मान में परिवर्तित होता है।
तो, यह विधि का एक मूल्य है जो कि क्लास फ़्लोट के लिए जावा डॉट लैंग पैकेज में परिभाषित होता है जो स्ट्रीम को डबल या फ्लोट मान में बदल देगा।
इसी तरह यह भी है जैसा कि हम देखते हैं, यह धारा और पढ़ने से बदल जाता है और फ्लोट मूल्य में बदल जाता है।
इसी तरह, यहाँ यह मूल रूप से पूर्णांक के रूप में वर्षों की संख्या को पढ़ रहा है और हम देखते हैं कि हम इस पद्धति को कहते हैं जो पूर्णांक में बदलने के लिए जावा डॉट लैंग पैकेज में परिभाषित है।
तो, Integer dot parseInt (tempString) पसंद है।
हम पहले से ही हमारे कई चर्चा समस्या कार्यक्रम में परिचित हैं, हम इस तरह की अवधारणा का उपयोग यहां करते हैं।
तो, यह मूल रूप से एक विचार दिखाता है कि कीबोर्ड से कुछ तक पहुंचने के लिए विशेष रूप से इस विशेष उदाहरण में DataInputStream वर्ग का उपयोग कैसे किया जाता है।
अब तो, यह सिर्फ एक उदाहरण है और एक और महत्वपूर्ण उदाहरण है जो फाइलों से निपट रहा है।
तो, हम फ़ाइल से कुछ डेटा कैसे पढ़ सकते हैं?
हम फ़ाइल में कैसे लिख सकते हैं?
फ़ाइल को पढ़ने के विभिन्न तरीके क्या हैं।
उदाहरण के लिए, बाइट स्ट्रीम कक्षाओं का उपयोग करके या किसी फ़ाइल को विशेष वर्ग वगैरह का उपयोग करके कैसे हैंडल किया जा सकता है।
इसलिए, हमारी अगली कुछ स्लाइड में इस तरह की परिभाषा और तंत्र शामिल हैं, बजाय चर्चा के।
तो, यह फ़ाइल सही संभाल रही है।
इसलिए, जैसा कि मैंने पहले ही उल्लेख किया है कि एक java पैकेज को java.io पैकेज प्रदान करता है जिसमें कक्षा घोषणा की संख्या और उसकी कक्षा में विधियाँ शामिल हैं और एक महत्वपूर्ण विधि इतने सारे वर्गों में से एक महत्वपूर्ण वर्ग फ़ाइल वर्ग कहलाता है।
तो, इसे मूल रूप से फाइल IO स्ट्रीम अधिक सटीक कहा जाता है।
तो, 4 प्रमुख प्रभाव वर्ग हैं जो फाइल करने के लिए हैं IO स्ट्रीम हैं।
उदाहरण के लिए, वर्ग फ़ाइल इसलिए, यह एक सामान्य फ़ाइल है और फिर फ़ाइल FileInputStream, यह इस बारे में है कि हम किसी फ़ाइल से कैसे पढ़ सकते हैं और फिर FileOutputStream - हम कैसे लिख सकते हैं
एक फ़ाइल में कुछ और फिर एक और है कि randomAccessFile।
तो, सभी फ़ाइल, FileInputStream, FileOutputStream उनके अनुक्रमिक का अर्थ है कि एक एक करके पढ़ना जहां रैंडम असफल के रूप में एक पढ़ने के लिए और किसी भी यादृच्छिक स्थिति से अनुमति देता है।
इसलिए, ये चार अलग-अलग वर्ग हैं, बल्कि हम फ़ाइल से संबंधित इनपुट आउटपुट स्ट्रीम से निपटने के लिए चार अलग-अलग तंत्र कह सकते हैं।
अब, देखते हैं कि हम क्या कर सकते हैं।
अब तो, फ़ाइल के लिए सबसे पहला काम यह है कि हम किसी फ़ाइल ऑब्जेक्ट को कैसे खोल सकते हैं;
इसका मतलब है, फ़ाइल मूल रूप से एक वस्तु उन्मुख अवधारणा में है सब कुछ एक वस्तु है।
तो, फ़ाइल एक ऑब्जेक्ट है। हम एक फ़ाइल ऑब्जेक्ट कैसे बना सकते हैं?
अब यह मूल रूप से है जैसा कि मैंने आपको बताया कि फाइल नामक एक वर्ग है।
तो, यह मूल रूप से यह घोषणा है;
अगर आप घोषणा करते हैं, तो myFile फ़ाइल का एक ऑब्जेक्ट है और फिर यह इसलिए कि इस स्टेटमेंट नई फ़ाइल का उपयोग करके मेरी फाइल ओपन हो सकती है।
यहां मूल रूप से आपकी मेमोरी या आपके सिस्टम में मौजूद हर फाइल में मूल रूप से एक विशिष्ट नाम होता है।
तो, आपको फ़ाइलनाम पास करना होगा।
तो, अगर आप मूल रूप से निर्माता हैं।
इसलिए, यदि हमने एक फ़ाइलनाम पास किया है और फिर हम एक फ़ाइल ऑब्जेक्ट बना सकते हैं।
इसलिए, इस फ़ाइल ऑब्जेक्ट को बनाने का अर्थ है कि आपके प्रोग्राम से, आप उस फ़ाइलनाम फ़ाइल से एक कनेक्शन कनेक्ट करते हैं।
तो, यह एक तरीका है और ये पहला निर्माणकर्ता है जिसे आप इसका उपयोग कर सकते हैं।
एक और कंस्ट्रक्टर फाइल है जिसमें आप pathName और फिर fileName का भी उल्लेख कर सकते हैं।
कंस्ट्रक्टर और यह कंस्ट्रक्टर वह है, जो यह मानता है कि आपकी फाइल उसी डायरेक्टरी की है, जहां से आपका वर्किंग वर्किंग डाइरेक्टरी से है और फाइल उसी वर्किंग डायरेक्टरी में स्टोर है, जबकि अगर हम किसी फाइल को एक्सेस करना चाहते हैं, जो है वर्तमान में आपकी कार्यशील निर्देशिका में नहीं है कि आप पथनाम और फ़ाइल नाम निर्दिष्ट कर सकते हैं।
तो, ये दूसरे निर्माणकर्ता हैं और यह भी समान है;
तीसरा यह बहुत ही समान रूप से यहाँ एक ही काम करने वाले निर्देशिका में, लेकिन अलग निर्देशिका में।
तो, आप यह निर्दिष्ट कर सकते हैं कि आपकी कार्यशील निर्देशिका के अंतर्गत कौन सी निर्देशिका है और फ़ाइल नाम क्या है।
तो, ये तीन निर्माणकर्ता हैं जिनके द्वारा हम एक फ़ाइल ऑब्जेक्ट बना सकते हैं।
किसी भी तरह से वास्तव में एक मुख्य बात यह है कि फ़ाइल नाम विशिष्ट रूप से उल्लिखित होना चाहिए, यदि सही फ़ाइलनाम का उल्लेख नहीं है, लेकिन आप इसे खोलने का प्रयास करते हैं तो यह एक त्रुटि लिखेगा।
तो, त्रुटि मूल रूप से उस तरह से संभाल रही है।
तो, यह कोशिश पकड़ ब्लॉक हो सकता है।
तो, यह अपवाद की जाँच कर सकता है अगर यह होता है और फिर यह होता है।
तो, कभी-कभी वह फ़ाइल विद्यमान होती है, लेकिन फ़ाइल क्षतिग्रस्त होती है या वह फ़ाइल विद्यमान होती है, लेकिन आपको पढ़ने या लिखने की कोई अनुमति नहीं होती है।
तो, उस मामले में भी यह एक अपवाद फेंक देगा और फिर कार्यक्रम को मजबूत बनाने के लिए अपवाद के अनुसार संभाल किया जा सकता है।
तो, यह वह अलग तरीका है जिससे फ़ाइल ऑब्जेक्ट बनाए जा सकते हैं और एक बार फ़ाइल ऑब्जेक्ट बन जाने पर, हम इस फ़ाइल ऑब्जेक्ट के माध्यम से अलग-अलग जानकारी रख पाएंगे।
उदाहरण के लिए, कई तरीके हैं जो इस फ़ाइल वर्ग से संबंधित हैं getName- इसमें मूल रूप से उस फ़ाइल का पूरा नाम लिखा होता है जिसे आपने वर्तमान में कनेक्ट किया है, गेटपैथ - यह कहेगा कि मार्ग क्या है, गेटअब्सल्यूटेपैथ - यह मूल रूप से है किसी भी निर्देशिका से यह मिल जाएगा और फिर पथ वहाँ हो जाएगा, getParent- इस फ़ाइल के ऊपर निर्देशिका क्या है जहां यह मौजूद है और फिर क्या renameTo- यदि फ़ाइल को किसी अन्य नाम में फिर से लिखना चाहते हैं, तो इस फ़ाइल का उपयोग करना संभव है वस्तु।
इसलिए, वे वे हैं जो कई उपयोगिता विधियां हैं जिन्हें हम फ़ाइल से संबंधित उपलब्ध कह सकते हैं।
और कई अन्य चीजें भी हैं आप एक फ़ाइल का परीक्षण कर सकते हैं जो ठीक है।
कुछ विधियाँ हैं जैसे कि फ़ाइल मौजूद है या नहीं, आप केवल मौजूद विधि कैनराइट का उपयोग करके ऐसा कर सकते हैं;
इसका मतलब यह है कि, क्या फ़ाइल लिखने योग्य है, चाहे यह अनुमति हो कि क्या यह फ़ाइल है या यह कुछ है तो अन्य रूप में कहें, एक निर्देशिका है या एक निरपेक्ष है;
इसका मतलब है कि, यह एक मानक फ़ाइल है या नहीं।
तो, वे चीजें हैं जो आप इस फ़ाइल ऑब्जेक्ट का उपयोग करके कर सकते हैं।
अब तो, इस फ़ाइल की जानकारी के बारे में कुछ और बातें भी हम पिछले lastModified हो सकता है;
इसका मतलब है, यह आपको तारीख और समय बताएगा जब फ़ाइल सही हो गई है मेरा मतलब है कि पिछली बार का उपयोग करें और इसमें विधि की लंबाई भी होगी।
तो, यह फ़ाइल की लंबाई लिखा जाएगा।
यदि आप ऐसी फ़ाइल को हटाना चाहते हैं, जिसे आप डिलीट विधि का उपयोग करके भी कर सकते हैं और कुछ निर्देशिका तक हैं;
इसका मतलब है, एक फ़ाइल का उपयोग करके हम एक निर्देशिका बना सकते हैं और फिर निर्देशिका में फ़ाइल को वहां प्रतिस्थापित किया जा सकता है और निर्देशिकाओं को एक से अधिक निर्देशिकाओं को भी बनाया जा सकता है और एक विशेष निर्देशिका में संग्रहित फ़ाइलों की सूची भी विधि का उपयोग करके एक्सेस की जा सकती है। सूची विधि यह वहाँ है
तो, फ़ाइल से संबंधित कई उपयोग विधियां हैं जो मूल रूप से प्रोग्राम को फाइलों को अपने तरीके से संभालने के लिए अलग-अलग तरीकों से संभालती हैं जो वे चाहते हैं।
अब, हमारे पास एक सरल उदाहरण है कि हमने विभिन्न तरीकों के बारे में सीखा है जो फ़ाइल में हैं और एक फ़ाइल की जाँच की स्थिति से संबंधित कुछ तरीके;
क्या फ़ाइल मौजूद है, फ़ाइल उपलब्ध है, फ़ाइल का नाम क्या है, रास्ता क्या है और जैसे सब कुछ है।
तो, यह उदाहरण आपको फ़ाइल की स्थिति के बारे में विचार को समझने में मदद करेगा।
अब, हम इस कार्यक्रम के बारे में एक त्वरित नज़र रखते हैं क्योंकि हम देखते हैं कि यह वह वर्ग है जो हमें दिया गया है और हम इन java.io.ile को आयात करते हैं क्योंकि हम चाहते हैं कि जो विधियाँ हैं, वे वहाँ हों।
अब जैसा कि आप यहाँ देख रहे हैं तो यह मुख्य तरीका है और;
जाहिर है, कार्यक्रम को अपवाद बनाने के लिए कैच ब्लॉक को फेंकना और आज़माना यहाँ शामिल होना चाहिए;
बल्कि अधिक विश्वसनीय अपवाद को संभालें।
इसलिए, यहां हम पहले देखते हैं कि हम क्या करते हैं, हम एक ऑब्जेक्ट कॉल फ़ाइल बनाते हैं।
यह क्लास फ़ाइल के प्रकार के ऑब्जेक्ट का नाम है।
तो, यह वह वस्तु है जिसे हम करना चाहते हैं।
अब इस कार्यक्रम में हम मानते हैं कि उपयोगकर्ता शून्य या अधिक फ़ाइलों का नाम भेजेगा जिसके लिए आप उन फाइलों के बारे में जानकारी रखना चाहते हैं।
अब यहाँ अगर उपयोगकर्ता कोई फ़ाइल नाम नहीं देता है जब भी वह प्रोग्राम चलाता है, तो मूल रूप से 0 के बराबर लंबाई होती है।
उस स्थिति में यह कहेगा कि जावा फाइलटेस्ट, यह प्रोग्राम का नाम है और फाइल का नाम आपको कम से कम एक या एक से अधिक फाइल नाम देना चाहिए।
अब, मान लें कि यदि आप उपयोगकर्ता कम से कम एक या एक से अधिक फ़ाइल नाम देते हैं, तो यह मूल रूप से इस लूप में प्रवेश करेगा।
फिर प्रत्येक फ़ाइल के लिए प्रत्येक इनपुट को आम लाइन i = 0 में;
i <args dot length, यह मूल रूप से newFile (args dot) चेक करने के लिए फाइल कहने की विधि बनाता है
लंबाई);
इसका मतलब है, यह प्रोग्राम से फाइल में एक कनेक्शन बनाता है जो मूल रूप से इनपुट में है।
अब तो, इस फ़ाइल के लिए बस इस विधि getPaths और getInfo मिलेंगे ये दो विधियां हैं जो मूल रूप से इस पद्धति के तहत हैं हम इस दो विधि को यहां परिभाषित करते हैं।
अब तो, देखते हैं कि getPaths विधि क्या है और getInfo उपयोगकर्ता परिभाषित विधि है।
अब यहाँ पर इस बारे में विचार है कि गेटपाथ विधि है।
जैसा कि हम देखते हैं, getPath विधि जो इस वर्ग के तहत परिभाषित है।
ये फाइलटेस्ट क्लास हम इस विधि के तहत कह सकते हैं, यह गेटपाथ है।
अब अगर आपको getPath method f dot getName दिखाई देती है।
तो, यह मूल रूप से इस फ़ंक्शन को एक फाइलटॉच की तरह यहाँ पास करेगा और फिर f.getName, getName एक बिल्ट इन मेथड है जो क्लास फाइल में डिफाइन कर रहा है।
इसी तरह, getPath विधि फ़ाइल ऑब्जेक्ट के बारे में लिखा जाएगा, पथ और getParent ने इस एक की फ़ाइल निर्देशिकाओं के माता-पिता को लिखा और फिर इसे लिखा जाएगा।
तो, यह फ़ाइल ऑब्जेक्ट पथ नाम के बारे में प्राप्त करने के बाद प्रिंट करेगा और यह सब कुछ लिखा जाएगा, यह इनपुट स्क्रीन पर प्रदर्शित होगा और इसी तरह getInfo भी उपयोगकर्ता एक विधि को परिभाषित करता है और इसमें मूल रूप से f dot canRead होता है;
इसका मतलब है, पठनीय या लिखने योग्य रीड राइट अनुमति यह वहाँ है या क्या तारीख या समय है कि इसे संशोधित किया गया है, इस तरह की फ़ाइल की लंबाई क्या है।
तो, ये अलग तरीके हैं जो फ़ाइल ऑब्जेक्ट का उपयोग करके फ़ाइल की स्थिति को सीखा जा सकता है और विभिन्न विधियाँ इस क्लास फ़ाइल के अंतर्गत आती हैं।
अब तो, हम फ़ाइल ऑब्जेक्ट को कैसे खोलें, इसके बारे में सीखते हैं।
अब हमें इस बारे में विचार करना चाहिए कि फ़ाइल में पहले से मौजूद कुछ सामग्री को इस फ़ाइल से प्रोग्राम में कैसे पढ़ा जा सकता है।
तो, यह मूल रूप से एक फ़ाइल पढ़ रहा है।
अब हमारे पास इस अवधारणाओं को चित्रित करने के लिए छोटा कार्यक्रम है।
अब हम यहां इस कार्यक्रम की जांच करते हैं।
हम एक वर्ग को परिभाषित करते हैं, यह मूल रूप से यह जांचने के लिए कि हम किसी फ़ाइल को कैसे पढ़ सकते हैं।
यहां प्रोग्राम का नाम फ़ाइल इनपुट InputStreamTest है।
अब, इस कार्यक्रम में जैसा कि आप देखते हैं, यह मुख्य विधि की घोषणा है और यहाँ फिर से आप देखते हैं कि हम FileInputSteam बनाते हैं।
तो, FileInputSteam फिन जैसा कि आप जानते हैं कि FileInputSteam मूल रूप से बाइट स्ट्रीम कक्षाओं से संबंधित है।
तो, यह एक बाइट फॉर्म के रूप में पढ़ा जाएगा।
अब यहां वह विधि जो पहले से ही फाइल इनपुट स्ट्रीम कक्षाओं में परिभाषित है, उपलब्ध कॉल करती है।
इसलिए, यह मूल रूप से अगर हम इस ऑब्जेक्ट को FileInputSteam ऑब्जेक्ट के लिए उपलब्ध विधि कहते हैं, तो यह लिखा जाएगा कि फ़ाइल में कुल बाइट्स क्या है।
तो, यह मूल रूप से बाइट्स की संख्या लिखी है और यह कुल बाइट्स मुद्रित करेगा यह एक है।
अब, यहाँ माना जाता है कि हम फ़ाइल के पहले एक चौथाई भाग को कैसे पढ़ सकते हैं।
तो, यह मूल रूप से इसके लिए लूप के लिए उपयोग कर रहा है (i = 0);
i <आकार / 4;
यह फिन पढ़ेगा। फिन मूल रूप से फाइल इनपुटस्टेम क्लास में पढ़ने की विधि पढ़ता है और फिर वह बाइट पढ़ता है और फिर यह मूल रूप से इस बाइट को अक्षरों में बदल देता है।
इसलिए, मूल रूप से बाइट को ASCII मान पढ़ा जा सकता है और फिर उस चरित्र में परिवर्तित किया जा सकता है जो चरित्र स्क्रीन पर प्रदर्शित होगा।
इसलिए, फ़ाइल में जो भी होगा, वह वहां होगा और फिर बाइट की पहली-चौथी स्थिति को पढ़ा जाएगा और यह स्क्रीन पर प्रदर्शित होगा।
उसी प्रोग्राम को पार्ट रीडिंग के द्वारा पढ़ने के लिए बढ़ाया जा सकता है।
यहां कार्यक्रम का अगला भाग मूल रूप से आपको बताया गया है कि फ़ाइल के दूसरे भाग को कैसे पढ़ा जा सकता है। ;
इसका मतलब है कि, यह कैपसलाइज्ड नहीं है, फिर यह किसी फाइल में चूक है और अगर यह नहीं है।
इसलिए, यदि कुल बाइट्स को वास्तव में पढ़ा जाता है, तो यह मूल रूप से इस हिस्से को यहां बुलाएगा।
तो, हम सिर्फ स्ट्रिंग (बी, 0, 0, बी डॉट लंबाई) मूल रूप से स्ट्रिंग को परिवर्तित कर रहे हैं और फिर हम उस बाइट में स्टोर करते हैं जो हमने लिखा है और इस स्ट्रिंग में स्टोर करें।
तो, मूल रूप से इस बारे में विचार है कि हम बाइट्स को एक स्ट्रिंग में कैसे बदल सकते हैं जो मूल रूप से अधिक सुविधाजनक है।
तो, अगर बाइट स्ट्रीम स्ट्रिंग में गुप्त है और फिर हम स्ट्रिंग को संसाधित कर सकते हैं।
अब, यहां हम देख सकते हैं कि एक बार पूरे बाइट सरणी को अंतिम उदाहरण में स्ट्रिंग में परिवर्तित कर दिया गया है, हम भंडारण कर रहे हैं कि एक विशेष बाइट को चरित्र में परिवर्तित किया जा सकता है, लेकिन यहां संपूर्ण बाइट स्ट्रीम को स्ट्रिंग में बदला जा सकता है और फिर यह स्ट्रिंग स्क्रीन पर मुद्रित किया जा सकता है।
तो, यह कथन है और इसी तरह हम फिर भी इसे उपलब्ध कर सकते हैं, यह मूल रूप से फ़ाइल के पहले एक-चौथाई हिस्से को पढ़ने के बाद है, फिर फ़ाइल के अगले हिस्से के एक-चौथाई हिस्से के बाद शेष फाइल को।
अब यह मूल रूप से कहता है कि यह फ़ाइल उपलब्ध है और यहां आप देख सकते हैं कि फिर से विधियां हैं मूल रूप से बाइट की बाइट संख्या को छोड़ दें जो वहां है।
तो, मूल रूप से 4 से आकार रखें।
तो, इस तरह से हम फ़ाइल के तीन-चौथाई भाग को इनपुट स्ट्रीम में कवर कर सकते हैं और फिर पढ़ने के लिए शेष फ़ाइल मूल रूप से एक उपलब्ध है।
तो, यह एक है।
इसलिए, यह मूल रूप से दिखाता है कि, हम कैसे अनुक्रमिक रूप से प्रक्रिया कर सकते हैं हम कवर कर सकते हैं हम एक इनपुट फ़ाइल को पार कर सकते हैं।
अब तो यह है कि हम कैसे पढ़ सकते हैं।
यहाँ हम बाइट इनपुट स्ट्रीम क्लासेस को बाइट के रूप में एक मैकेनिज्म रीडिंग का उपयोग करते हैं।
अब बस विपरीत के बारे में चर्चा करेंगे
एक फ़ाइल में एक प्रक्रिया कॉल लेखन;
कैसे एक बाइट को एक फ़ाइल या एक चरित्र में लिखा जा सकता है या एक स्ट्रिंग को एक फ़ाइल में लिखा जा सकता है।
अब बाइट को फाइल में लिखने की अवधारणा को समझने के लिए यहां एक छोटा कार्यक्रम है।
अब यहाँ एक विधि वर्ग है जिस पर हमने यहाँ चर्चा की है, बाइट्स।
मूल रूप से फ़ाइल में बाइट्स लिखना और यह प्रोग्राम जो आप देखते हैं, यह मूल रूप से वर्ण स्ट्रिंग है जो मूल रूप से दिखाती है कि यह मूल रूप से बाइट्स के डी args मान के आर्ग्स मान हैं।
तो, यह मूल रूप से बाइट्स की धारा है जिसे हम पहली बार शहरों को कॉल करने वाले सरणी में स्टोर करते हैं।
तो, यह मूल रूप से एक बाइट के रूप में सभी जानकारी को संग्रहीत करता है यह वहां है और फिर हम इसे एक फ़ाइल में लिखना चाहते हैं, इस चीज़ों के लिए यहां हम देखते हैं कि हम फ़ाइलऑउटपुटस्ट्रीम की ऑब्जेक्ट कॉल आउट फ़ाइल बनाते हैं।
इसलिए, यदि आप कुछ फ़ाइल पढ़ना चाहते हैं, तो हम FileInputStream का उपयोग करते हैं।
दूसरी ओर, यदि हम किसी फाइल में कुछ लिखना चाहते हैं, तो हमें क्लास FileOutputStream की एक ऑब्जेक्ट बनानी चाहिए और यह आउटपुट फाइल मूल रूप से वह ऑब्जेक्ट है, जो हम आपके प्रोग्राम को उस फाइल से कनेक्ट करते हैं, जहां आप कुछ लिखना चाहते हैं।
अब तो, यह मूल रूप से हम इस कोड को प्रोग्राम को मजबूत बनाने के लिए कोशिश करते हैं।
यदि अपवाद में ऐसा होता है, तो इसे यहाँ पकड़ा जा सकता है और यहाँ आप देखते हैं कि हमने पहली बार बनाया था कि हम केवल आउटऑउट FileOutputStream की फ़ाइल की एक वस्तु घोषित करें।
अब, एक ऑब्जेक्ट बनाएं, इस चीज़ को करने के लिए हम पहले एक फ़ाइल नाम पास करते हैं जहाँ आप इसे स्टोर करना चाहते हैं, शहर डॉट txt।
यदि यह पहले से मौजूद है, तो ठीक है, मैं इस चर्चा पर बाद में आऊंगा।
इसलिए, यदि शहर डॉट txt फ़ाइल का नाम है, जहां वह इसे बनाएगा तो यह आपके प्रोग्राम से उस फ़ाइल में कनेक्शन स्थापित करेगा और यह कनेक्शन मूल रूप से ऑब्जेक्ट्स मूल रूप से यहां स्थापित है।
अब, यहाँ फ़ाइल लिखने की विधि है।
यदि हम इस सरणी को पास करते हैं, तो यह वास्तव में बाइट्स का सरणी है यदि वहाँ पास होने पर बाइट्स का पूरा सरणी इस फ़ाइलों में बढ़ जाएगा।
अब यहाँ फिर से एक महत्वपूर्ण बात यह है कि, यदि पहले से ही एक फ़ाइल मौजूद है, जिसका नाम city.txt है और यदि हम इसे लिखते हैं, तो पिछली सामग्री लिखित हो जाएगी;
इसका मतलब है, यह केवल तब मिट जाएगा नई सामग्री जिसे आप लिखना चाहते हैं उसे वहां संग्रहीत किया जाएगा।
अब इसलिए, यह उदाहरण आपको समझाता है कि डेटा का एक बड़ा सिकुड़ा फ़ाइल में कैसे संग्रहित किया जा सकता है और फिर अंत में, आउट फ़ाइल डॉट क्लोज़;
इसका मतलब है, आपको फ़ाइल को बंद करना होगा यह हमेशा अनुकूलित होता है कि एक फ़ाइल खोलने के बाद आपको एक फ़ाइल बंद करनी चाहिए।
तो, यहाँ मूल रूप से एक फ़ाइल खोलना है और यहाँ आपके ऑपरेशन के बाद समापन फ़ाइल है।
इसलिए, यह प्रोग्राम अच्छी तरह से समझाता है कि हम किसी फाइल में कुछ कैसे लिख सकते हैं।
अब ऐसा है, इसलिए हमने पढ़ना सीख लिया है;
एक फाइल से पढ़ना और अलग-अलग विधि डेटा इनपुट स्ट्रीम और डेटा आउटपुट स्ट्रीम कक्षाओं का उपयोग करके फ़ाइल में लिखना।
तो, कई अन्य चीजें हैं जिस तरह से एक फ़ाइल भी पढ़ी जा सकती है।
अब मैं अन्य तंत्र पर चर्चा कर रहा हूं कि फाइल को कैसे पढ़ा जा सकता है।
अब तो, पिछले उदाहरण में हम एक FileInputStream और FileOutputStream के बारे में चर्चा कर चुके हैं।
ताकि, हम फाइल को पढ़ सकें या हम इसे यहां फाइल से लिख सकें।
तो, यहां फिर से एक और उदाहरण है जो बताता है कि किसी फ़ाइल से बाइट के रूप में पढ़ना कैसे संभव है।
तो, फिर से एक ही बात FileInputStream, यह वह वर्ग है जिसके लिए किसी ऑब्जेक्ट को बनाया जाना है और फिर फिर से हम केवल एक कनेक्शन बनाते हैं और फिर रीड मेथड को मूल रूप से पढ़ते हैं।
अब यहाँ पर यह रीड मेथड एक बार में एक बाइट पढ़ता है।
तो, यह पढ़ने की विधि है और यहां मूल रूप से यह मूल रूप से फ़ाइल का एक अंत है;
इसका मतलब है, यह तब तक जारी रहेगा जब तक फ़ाइल का अंत नहीं होता है।
अब आप एक बाइट स्टोर को अस्थायी b में यहाँ पढ़ते हैं और फिर इस b को कैरेक्टर में बदला जा सकता है और फिर इसे प्रिंट किया जा सकता है, इसका मतलब यह है कि यह एक फाइल को पढ़ेगा और तब स्टैण्डर्ड इनपुट डिवाइस पर कंटेंट के बावजूद एक सिस्टम होगा .out.print।
और अंत में, एक बार जब पूरी फाइल को एक-एक करके एक-एक बाइट को पढ़ा जाता है, तो यह बंद हो जाएगा यह बहुत ही सरल तरीका है, यह फ़ाइल आउटपुट स्ट्रीम कक्षाओं के समान है जिसे हमने वहां या जैसे माना है।
तो, यह विचार है कि वास्तव में एक समय में क्रमिक रूप से एक बाइट और फिर इंटर फाइल विविध हो सकती है या पढ़ी जा सकती है।
अब, हमें ठीक है।
इसलिए, हम बाइट स्ट्रीम कक्षाओं का उपयोग करते हुए अब तक चर्चा कर चुके हैं।
अब फिर से वही काम करने के बारे में चर्चा करना आवश्यक है, लेकिन कैरेक्टरस्ट्रीम क्लास का उपयोग करना।
तो, यहां एक सरल कार्यक्रम है जिसमें यह शामिल है कि किसी फ़ाइल को कैसे पढ़ा जा सकता है और या उसे अक्षरों के रूप में लिखा जा सकता है, यह पिछले एक विधि के समान है, चाहे वह बाइट हो या चरित्र सभी।
अब यहाँ आप देख सकते हैं कि यह हमारे द्वारा घोषित विधि वर्ग है और यहाँ विधि में हम देख सकते हैं कि हमने नई फ़ाइल में क्या किया है, यह इनपुट फ़ाइल का नाम है जहाँ से आप पढ़ना चाहते हैं और ये आउटपुट का नाम हैं वह फ़ाइल जहाँ आप लिखना चाहते हैं।
तो, इनपुट फ़ाइल के लिए ये दो ऑब्जेक्ट इनफाइल और आउटफाइल्स हैं और फिर आउटपुट फाइल बनाई जाती है और फिर यहाँ हम फाइलराइडर का उपयोग करते हैं मूल रूप से एक फाइल पढ़ने के लिए एक फ़ाइल और फाइलराइटर पढ़ने के लिए मेरा मतलब है।
तो, दो अन्य वस्तुओं का निर्माण होता है।
वे एक फ़ाइल और आउटपुट पढ़ने के लिए जिम्मेदार होंगे और यह मूल रूप से कनेक्शन स्थापित होने के बाद होगा।
अब यहाँ यह मूल रूप से अब ऑब्जेक्ट यहाँ घोषित किया गया है और अब ऑब्जेक्ट बनाया गया है;
इसका मतलब है कि, अब इनपुट फ़ाइल देने वाले इस FileReader कंस्ट्रक्टर का उपयोग करके इसे कनेक्ट किया गया है;
इसका मतलब है, यह वस्तुओं।
तो, InFile इनपुट डेटा एक इनपुट फ़ाइल ऑब्जेक्ट्स आउटपुट डेटा आउटपुट फ़ाइल ऑब्जेक्ट्स है और इसके लिए ins पद्धति और बाहरी विधि का उपयोग करके हम प्रोग्राम से दो ऑब्जेक्ट्स इनपुट डेटा आउटपुट डेटा के बीच संबंध बनाते हैं और अब यह पूर्णांक वर्ण है a
अस्थायी चर और यहाँ हम इन्स को पढ़ सकते हैं;
इसका मतलब है कि इनपुट ऑब्जेक्ट से रीड मेथड एक बार में एक कैरेक्टर को पढ़ेगा और यह मूल रूप से फाइल के अंत तक पढ़ा जाता है।
तो, यह मूल रूप से फ़ाइल का अंत है और फिर यह एक फ़ाइल से एक चरित्र को पढ़ता है और बाहरी रूप से लिखता है कि हम आउटपुट फ़ाइल को उसी आउटपुट में लिखते हैं जिसका नाम यहाँ आउटपुट डॉट डेट है।
तो, यह मूल रूप से एक इनपुट फ़ाइल कॉल input.dat से एक चरित्र को पढ़ता है और फिर एक ही चरित्र इनपुट और आउटपुट फ़ाइल कॉल आउटपुट डॉट डेट लिखता है।
फिर फिर एक बार पूरी फाइल को पढ़ने और लिखने के बाद यह खत्म हो जाता है, फिर यह मूल रूप से दो वस्तुओं के लिए करीबी विधि का उपयोग करके यहां दो वस्तुओं को बंद कर देता है।
तो, इस तरह से आप देख सकते हैं कि पढ़ना और लिखना कैसा है और यहाँ हम उन सभी अपवादों को देख सकते हैं जिन्हें संभालना तंत्र है।
मामले में मान लें कि हम फाइल नहीं खोल पा रहे हैं या फाइल नहीं लिख पा रहे हैं या फाइल दूषित है या जो फाइल की अनुमति नहीं है, उसके कई कारण हैं और तब और फिर आउटपुट डॉट फाइल के रूप में यह वहां है क्योंकि यह एक ओवरराइड है हमेशा ओवरराइड में।
इसलिए, यदि वह सम्‍मिलित नहीं है, जो एक आकर्षक नहीं है;
इसका मतलब यह है कि इसमें जो चीजें हैं, वे इसमें शामिल होंगी, ऐसा नहीं है, लेकिन यह अलग तरीके से भी किया जा सकता है।
अब, यहां मूल रूप से हम देखते हैं कि यदि फ़ाइल पहले से मौजूद है, तो यह शुरुआत से ही लिखना शुरू कर देगा।
तो, पिछली सामग्री मिटा दी जाएगी।
तो, यह तरीका है कि चरित्र स्ट्रीम क्लास का उपयोग करके किसी फ़ाइल की प्रतिलिपि कैसे संभव है।
फिर से उसी का उपयोग करते हुए, लेकिन बाइट स्ट्रीम कक्षाओं का उपयोग करके भी कि नकल कैसे संभव हो सकती है।
मैं आपको इसके लिए केवल तंत्र बताऊंगा।
यहाँ फिर से हम दो स्ट्रीम बना सकते हैं FileInputStream और FileOutputStream इनपुट स्ट्रीमिंग के लिए और आउटपुट स्ट्रीमिंग के लिए फ़ाइल और आउट फ़ाइल में दो ऑब्जेक्ट।
और यहाँ जैसा कि हम चरित्र के बजाय बाइट स्ट्रीम क्लास का उपयोग करना चाहते हैं, हम सिर्फ एक अस्थायी परिवर्तनशील बाइट की घोषणा करते हैं।
तो, जहां बाइट्स का मतलब है, जहां बफर बाइट अस्थायी पढ़ा जाएगा और वहां स्टोर होगा।
अब, अगला यह है कि हमें फाइल को कनेक्ट करना है।
तो, यहाँ इस कनेक्ट के लिए हम इस इनपुट फ़ाइल नाम और इसी तरह आउटपुट फ़ाइल नाम का उपयोग करते हुए डेटा में चर्चा में फ़ाइल नए में एक ऑब्जेक्ट बनाते हैं और फिर डेटा डायट डेट।
अब इस तरह, हम प्रोग्राम से इनपुट स्रोत और फिर आउटपुट स्टोर स्रोत से एक कनेक्शन बना सकते हैं और फिर यह मूल रूप से फ़ाइल के पूर्ण होने तक पढ़ना शुरू कर देगा।
तो, यह मूल रूप से फाइल में पढ़ा जाने वाला बाईट रीड बाइट है, जो फाइल राइट बाईट रीड लिखता है।
तो, वही पढ़ेगा और लिखेगा और यह मूल रूप से है जबकि फ़ाइल का अंत है।
अवधारणा कमोबेश हर मामले में एक ही तरीका है जिस तरह से हम वास्तव में पढ़ सकते हैं और फिर वहां कॉपी कर सकते हैं।
यहाँ इस उदाहरण में जैसा कि हम एक बाइट के रूप में देखते हैं और फिर अंत में, विधि यहाँ ठीक होगी।
अब तो, हम पढ़ना, कॉपी लिखना और फिर डेटा को फाइल में स्टोर करना सीखते हैं।
अब यहाँ फिर से प्रोग्राम से देखते हैं कि कैसे डेटा को एक-एक करके एक-एक करके इंटरेक्टिव तरीके से स्टोर किया जा सकता है।
इसलिए, यह उदाहरण मूल रूप से आपको समझाता है कि डेटा को किसी फ़ाइल में कैसे पोस्ट किया जा सकता है।
तो, यहाँ मूल रूप से लिखा गया है आदिम पढ़ें यह फ़ाइल से पढ़ेगा और इसे एक और फ़ाइल लिखेगा, लेकिन उदाहरण के लिए उत्पन्न प्रोग्राम से कुछ डेटा संग्रहीत करना।
तो, पहले हम एक फ़ाइल प्रकार ऑब्जेक्ट बनाते हैं जो उस फ़ाइल का नाम है जहां आप इसे संग्रहीत करना चाहते हैं, यह मूल रूप से फ़ाइल का नाम है और फिर हम फ़ाइल ऑब्जेक्ट को आदिम बनाते हैं।
तो, फ़ाइल ऑब्जेक्ट बन जाने के बाद यह फ़ाइल ऑब्जेक्ट है, फिर यह मूल रूप से FileOutputStream है;
इसका मतलब है, कनेक्शन।
तो, इस आदिम के लिए FileOutputStream वर्ग कनेक्शन इस फ़ाइल का मतलब है।
तो, fos और DataOutputStream आधारभूत है डेटा के लिए एक और स्ट्रीम है, जो कि प्राइम आउट डेटा के लिए है;
इसका मतलब है कि, यदि आप देखते हैं कि यह FileOutputStream के लिए फ़ाइल और फॉस है और DataOutputStream के लिए डॉस।
इसलिए, डेटा आउटपुट के माध्यम से, हमें फ़ाइल आउटपुट से कनेक्ट करना होगा और फिर यह मूल रूप से कुछ डेटा को यहां संग्रहीत करने के लिए फ़ाइल से कनेक्ट होता है।
अब यहाँ फिर से आप DataOutputStream WriteInt के लिए देखते हैं, वहाँ विधि int लिखें;
इसका मतलब है, यह जानता है कि इस डेटा इनपुट DataOutputStream में एक पूर्णांक कैसे लिखना है।
इसी तरह DataOutputStream कक्षाओं में वहां WriteDouble विधि है, जो मूल रूप से ऑब्जेक्ट और फ्लिन में भी कैसे और फिर वर्णों के लिए एक फ्लोटिंग पॉइंट नंबर लिखने में मदद करता है।
इसलिए, यहां हम चार अलग-अलग प्रकार के डेटा देख सकते हैं, जिन्हें DataOutputStream में स्टोर किया जा सकता है और फिर इसे मूल रूप से स्टोर किया जा सकता है।
एक बार DataOutputStream तैयार हो जाए, तो वही डेटा इस FileOutputStream में पोस्ट किया जा सकता है।
अब यह विधि और बाकी हिस्सा है जैसा कि हम ठीक देखते हैं।
तो, हम सिर्फ लिखते हैं हम सिर्फ इस सभी चीजों में लिखते हैं मूल रूप से इनमें से मूल्य हैं, इस फ़ाइल आउटपुट स्ट्रीम के लिए और आखिरकार, हमें इसे बंद करना होगा।
अब फिर से हमने जो वस्तु बनाई है, उसे पढ़ा जा सकता है;
यहाँ हम FileInputStream और DataInputStream देख सकते हैं वही दूसरे संस्करण से भी पढ़ा जा सकता है।
तो, यहाँ मूल रूप से हम इसे यहाँ लिखते हैं और यहाँ DataInputStream और FileInputStream तंत्र का उपयोग करके समान सामग्री पढ़ेंगे।
इसलिए, दोनों ही चीजें वहां मौजूद हैं।
तो, यह उदाहरण आपको बताएगा कि हम प्रोग्राम से डेटा कैसे स्टोर कर सकते हैं।
ये प्रोग्राम से कुछ फ़ाइल ऑब्जेक्ट में डेटा और फिर वही डेटा है जो उनका है कि हम इसे यहां कैसे पढ़ सकते हैं, लेकिन जब आप पढ़ रहे हैं तो आपको यह उल्लेख करना होगा कि आप किस प्रकार का डेटा पढ़ना चाहते हैं।
यदि आप जानते हैं कि यह संरचना यदि आप इसे पढ़ते हैं, तो यह वही मिलेगा जो;
यदि आप उस क्रम में नहीं पढ़ते हैं।
तो, पहले यह ReadDouble और यह एक तो कुछ त्रुटि आप मुठभेड़।
इसलिए, हमें इस बारे में सावधान रहना होगा कि जिस तरह से डेटा संग्रहीत किया जाता है उसी तरह से यह हो सकता है।
तो, इस तरह से किसी भी वस्तु के उनके मानों को सरणी में संग्रहीत किया जा सकता है।
अब, यहाँ मैं मूल रूप से i के बराबर है 0 कुल 20 यादृच्छिक संख्या बनाई जाएगी और फिर उन्हें यादृच्छिक फ़ंक्शन का उपयोग करके उत्पन्न किया जाएगा जो कि जावा डॉट लाइन में है और फिर उस स्ट्रीम में लिखें।
तो, इस तरह से यह मूल रूप से फ़ाइल में लिखते हैं।
एक बार फाइल राइटिंग खत्म हो जाने पर हम फाइल में फाइल में कुछ लिख सकते हैं।
जैसा कि यहाँ एक फ़ाइल इनपुट स्ट्रीम है intFile फिर से ये वे मान हैं जो वहाँ हैं और readInt सभी;
इसका मतलब यह है कि हमारे पास जो भी फाइल है, वह लिखा है कि हम पढ़ सकते हैं हम इस रूप में पढ़ सकते हैं और फिर अंत में, यह करीब है।
तो, यह मूल रूप से यह विचार है जो आपको बताता है कि आपके प्रोग्राम में उत्पन्न होने वाला एक यादृच्छिक डेटा एक मेमोरी ओके में फ़ाइल में कैसे पोस्ट किया जा सकता है।
अब, अगली दो फ़ाइलों को मर्ज कर रहा है।
यह मूल रूप से फाइल बफर इनपुट स्ट्रीम तंत्र है और यह प्रोग्राम बहुत सरल है यहां आप देख सकते हैं कि हम पहले दो फाइलइंस्ट्रीमस्ट्रीम फाइल एक और फाइल दो बनाते हैं और एक अनुक्रम स्ट्रीम सीक्वेंसइन्पुटस्ट्रीम फाइल बफर है।
यह मूल रूप से दो फाइलों को लेता है और फिर एक फाइल में परिवर्तित करता है जैसे।
तो, यहाँ फ़ाइल 1 के बारे में विचार है पहली वस्तु, फ़ाइल 2 दूसरी वस्तु है जिसे हमने बनाया है।
ये फ़ाइल मान का नाम हैं और फिर फ़ाइल 3 मूल रूप से दो फ़ाइल का संयोजन या विलय है।
तो, हम एक ऑब्जेक्ट SequenceInputStream फ़ाइल 1 फ़ाइल 2 बना सकते हैं।
तो, यह मूल रूप से दो फाइल टेक्स्ट 1 डेटा, टेक्स्ट 2 डेटा को एक फाइल में समेटता है और फाइल को स्टोर किया जा सकता है।
अब भंडारण के लिए, बफर में बफ़रड इनपुटड्रीम के बारे में विचार है और यह फ़ाइल 3 है और फिर हम इसे बना सकते हैं और फिर उसी चीज़ को संग्रहीत किया जा सकता है और फिर यहाँ मूल रूप से वह सामग्री है जिसे पढ़ा जा सकता है और फिर उसे प्रदर्शित किया जा सकता है। ।
तो, इस तरह से, यह SequenceInputStream वर्ग का एक उदाहरण है जो मूल रूप से दो फ़ाइलों को एक में समाहित करता है और फिर उसी फ़ाइल को प्रदर्शित किया जा सकता है या उसे ठीक किया जा सकता है या संसाधित किया जा सकता है।
तो, ये अलग तरीके हैं जिससे फाइल को हैंडल किया जा सकता है जैसा कि हमने यहां चर्चा की है और हमारे अगले मॉड्यूल में, हम फाइल को संभालने के लिए यादृच्छिक अभिगम तंत्र के बारे में चर्चा करेंगे।
इसलिए आपका धन्यवाद;
ध्यान देने के लिए धन्यवाद।
कंप्यूटर विज्ञान इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर व्याख्यान में जावा प्रो। देबासीस सामंत विभाग में प्रोग्रामिंग - 14 प्रदर्शन - VI आइए हम उन विषयों पर एक त्वरित प्रदर्शन करें जो हमने पिछले मॉड्यूल में सीखे हैं।
हमारा अंतिम मॉड्यूल जावा में विरासत पर आधारित था।
इसलिए, आज हम उस विषय पर एक त्वरित डेमो करने जा रहे हैं जो हमने पिछली कक्षा में सीखा है।
इसलिए, आज के डेमो में हम वंशानुक्रम की मूल अवधारणा को कवर करने जा रहे हैं, अर्थात् सरल वंशानुक्रम और फिर हम बहु-स्तरीय विरासत के बारे में चर्चा करेंगे, हमने उस सुपर कीवर्ड के बारे में चर्चा की है, जिसका उपयोग अंतरिक्ष के टकराव से बचने के लिए किया गया था, सुपर सुपरक्लास कंस्ट्रक्टर को आमंत्रित करने के लिए सुपर कीवर्ड का उपयोग और फिर सुपर कीवर्ड का उपयोग करके हम सुपरक्लास के कुछ चर का संदर्भ ले सकते हैं।
और फिर किसी भी विरासत में ओवरराइडिंग एक महत्वपूर्ण अवधारणा है, इसलिए विधि ओवरराइडिंग पर चर्चा की जाएगी।
दो और कीवर्ड हैं;
सार और फिर, अंतिम कीवर्ड जो वंशानुक्रम के रास्ते पर आता है।
इसलिए, हम इस पर चर्चा करेंगे।
तो, ये विषय हैं जो हम इस प्रदर्शन व्याख्यान में चर्चा करने जा रहे हैं।
अब हम पर पहला प्रदर्शन करते हैं
साधारण विरासत।
तो, एक वर्ग को दूसरी कक्षा से किस तरह की आवश्यकता हो सकती है, हम यह देख सकते हैं कि हमारे पास इसका डेमो है।
अब, हम इस कार्यक्रम को यहाँ देखते हैं, इस कार्यक्रम में हम एक वर्ग को देखते हैं, जिसे कक्षा ए घोषित किया गया है।
यह इस मामले में सुपरक्लास है, इस वर्ग में 2 सदस्य i और j हैं और इसकी 2 एक विधि है, जिसे इस वर्ग में i j i और j के मान को दर्शाने वाला शो i j j है।
अब, अगली कक्षा में क्लास B, जो मूल रूप से क्लास ए को विरासत में मिला है, क्लास बी ए का विस्तार करता है और हम देख सकते हैं कि कक्षा बी में हम टाइप चर के k नामक एक चर की घोषणा करते हैं और फिर वर्ग बी के अपने तरीके होते हैं।
तो, इस वर्ग में चर k को प्रिंट करने के साथ-साथ इसकी एक और विधि योग है, यह ij के मान को प्रिंट करेगा, जो कि सुपरक्लास और k के मूल्य से विरासत में मिला है, जो कि अपने स्वयं के चर में है।
तो, ये हैं विरासत में मिली कक्षा बी और जैसा कि आप जानते हैं कि कक्षा बी इसलिए, विरासत के आधार पर आईजे और विधि दोनों की पहुंच है।
तो, मुझे लगता है कि जो कक्षा में एक डिफ़ॉल्ट एक्सेस स्पेसियर के रूप में घोषित किए जाते हैं, उसी फ़ाइल में वे आसानी से विरासत के साथ-साथ डिफ़ॉल्ट एक्सेस विनिर्देश द्वारा सुलभ हैं।
अब हम उस मुख्य वर्ग को मुख्य वर्ग बनाते हैं जिसका नाम हम प्रदर्शन_6 1 के रूप में रखते हैं और इस वर्ग में, हम टाइप ए और क्लास बी के 2 ऑब्जेक्ट बनाते हैं, जिसका नाम सुपर ओब और सब ओब है।
तो, 2 अलग-अलग वर्गों के 2 ऑब्जेक्ट बनाए जाते हैं और अगले बयान में हम सुपरक्लास ऑब्जेक्ट्स में i और j के मूल्यों को इनिशियलाइज़ करते हैं और फिर प्रिंट भी करते हैं, इसलिए मैं इसे ij या सुपरक्लास ऑब्जेक्ट की विधि कहता हूं।
और अगले बयान में हम देखते हैं कि हम इनिशियलाइज़ करते हैं, सबक्लास ऑब्जेक्ट ij और k को 7 8 9 के रूप में और फिर हम शो आईजे, शो आईजे के मानों को प्रदर्शित करते हैं क्योंकि यह विरासत के माध्यम से ओब इब के लिए सुलभ है और फिर हम कॉल भी करते हैं। इस तरह से उप-वर्ग ऑब्जेक्ट्स के शो k विधि ओब को दिखाता है और फिर हम इसे प्रिंट करते हैं।
अब, हमारे पास एक क्विक डेमो है।
तो, आप देख सकते हैं कि यह सभी वैध पहुंच है, हम इस चीज़ का उपयोग कर सकते हैं और यह परिणाम देगा कि हमने आरंभ किया है और अंत में, यह तदनुसार मूल्य भी प्रदर्शित करेगा।
तो, हम इस प्रोग्राम को javac का उपयोग करते हुए चलाते हैं और फिर निष्पादन करते हैं, इसलिए ठीक है।
तो, यह काम करेगा क्योंकि कार्यक्रम में कोई त्रुटि नहीं है और यह तदनुसार मुद्रित होगा।
तो, यह वह मूल्य है जो यह वर्ग हमारे लिए ठीक छापेगा।
तो, यह पहला उदाहरण है जिसमें दिखाया गया है कि जावा में साधारण वंशानुक्रम कैसे किया जा सकता है।
अब, हमारा अगला प्रदर्शन सुपरक्लास में वहाँ के निर्माणकर्ताओं द्वारा उपवर्ग वस्तु के आरंभ पर आधारित है।
इसलिए, यह प्रदर्शन बताएगा कि हमें यह दिखाएगा कि हम किस प्रकार एक उपवर्ग ऑब्जेक्ट का उपयोग कर सकते हैं जो कि सुपरक्लास में परिभाषित है।
अब हमारे पास वह प्रोग्राम है जहां हम देख सकते हैं कि बॉक्स एक सुपरक्लास क्लास है जिसमें 3 डेटा चौड़ाई की ऊँचाई और गहराई है जो उन्हें दोगुनी घोषित की गई है।
और, बॉक्स कंस्ट्रक्टर है यह एक सुपरक्लास कंस्ट्रक्टर डिफॉल्ट कंस्ट्रक्टर है और इस डिफॉल्ट कंस्ट्रक्टर के अलावा एक और कंस्ट्रक्टर है जो क्लास ऑब्जेक्ट्स में अलग-अलग वैल्यूज़ को इनिशियलाइज़ कर रहा है और साथ ही इसमें एक मेथड वॉल्यूम है जो वैल्यूज़ का सिंपल गुणा है वस्तुओं का।
आप सफल संकलन और निष्पादन।
यह दोनों वस्तुओं की मात्रा को मेरे बॉक्स 1 और मेरे बॉक्स 2 को प्रिंट करेगा जिसे हमने हाँ बनाया है।
इसलिए, हम देख सकते हैं कि 2 ऑब्जेक्ट सफलतापूर्वक बनाए गए हैं एक वस्तु यह है कि एक उप-वर्ग ऑब्जेक्ट दूसरा सुपरक्लास ऑब्जेक्ट है।
अब, हमने इस उदाहरण में दिखाया है कि कैसे
उपवर्ग ऑब्जेक्ट को इनिशियलाइज़ किया जा सकता है।
अब हम एक और दृष्टांत देने जा रहे हैं, जहां सुपरक्लास कंस्ट्रक्टर की मदद से एक उपवर्ग ऑब्जेक्ट को इनिशियलाइज़ किया जा सकता है।
तो, यह इस दिशा में एक कार्यक्रम है यह पहले की तरह सरल है क्योंकि सुपरक्लास पहले जैसा ही है जहाँ भी हम उप सुपरक्लास सबक्लास ऑब्जेक्ट को फिर से परिभाषित करते हैं, चलो नीचे चलते हैं।
तो, यहाँ आप देख सकते हैं कि हमारे पास सिर्फ 2 कंस्ट्रक्टर हैं, एक उप-ऑब्जेक्ट में डिफ़ॉल्ट कंस्ट्रक्टर है और बॉक्स वेट को डिफ़ॉल्ट रूप से सबक्लास करता है और दूसरा चौड़ाई कुछ मान है।
अब डिफॉल्ट कंस्ट्रक्टर के मामले में हम देखते हैं कि हम इस एक के भीतर सुपर कहते हैं, इसे मूल रूप से सुपरक्लास में सुपरक्लास कंस्ट्रक्टर कहा जाता है।
तो, यह इसे एक कॉल करेगा, इसलिए यह सदस्यों को 0 0 0 मानों के साथ आरंभ करेगा।
अब, फिर से सुपर डब्ल्यू एच यहाँ मूल रूप से यह सुपरक्लास कंस्ट्रक्टर है, जिसके पास 3 तर्क हैं जिनकी आवश्यकता है और फिर हम इस सुपरक्लास कंस्ट्रक्टर को बॉक्स वेट कंस्ट्रक्टर का उपयोग करके इसे इनिशियलाइज़ करने के लिए कहते हैं।
अब, हमारे पास एक ही डेमो है, यह वही चीज है जो हम 2 ऑब्जेक्ट्स बनाते हैं, सुपरक्लास ऑब्जेक्ट के लिए मेरा बॉक्स विरासत में मिली क्लास ऑब्जेक्ट्स के लिए मेरा बॉक्स 2 है और फिर यह पहले जैसा ही प्रोग्राम है, केवल वही चीज जो हमारे पास है सुपरक्लास कंस्ट्रक्टर की मदद से आरंभ किया गया।
अब, इस डेमो में, सुपरक्लास कंस्ट्रक्टर मूल रूप से, निश्चित तर्क के साथ सुपर है।
सुपरक्लास कंस्ट्रक्टर के साथ जो तर्क फिट होगा वह सबक्लास कंस्ट्रक्टर के रूप में यहां इस्तेमाल किया जाएगा।
तो, हमारे पास एक और डेमो है।
यह मूल रूप से सुपर कीवर्ड का सुपर उपयोग है कि मूल रूप से हम सुपरक्लास चर की मदद से एक उपवर्ग ऑब्जेक्ट को कैसे संदर्भित कर सकते हैं।
अब हमारे पास 6.3 का डेमो है।
अब, इस मामले में, हम देखेंगे कि सुपरक्लास वैरिएबल इस तरह सबक्लास वेरिएबल के संदर्भ में कैसे हो सकता है।
हम इसे बेहतर तरीके से समझा सकते हैं कि यह सबक्लास डेफिनेशन क्लास बॉक्स है, यह पहले जैसा है क्योंकि इसमें 2 कंस्ट्रक्टर हैं, यदि क्लास की परिभाषा पहले से ही समान है तो हमने यहां चर्चा की है।
अब, हम सुपरक्लास ऑब्जेक्ट पर आते हैं।
यह भी एक ही है, यह मूल रूप से वजन और फिर इस मामले में यहां एकमात्र निर्माता है।
अब, हम यहाँ मुख्य वर्ग विधि देखते हैं।
इसे बहुत सावधानी से जांचने की आवश्यकता है।
यहां हम उपवर्ग बॉक्स के वजन की एक वस्तु को परिभाषित करते हैं, अर्थात् वजन बॉक्स इसके लिए पैरामीटर पारित करने वाली वस्तु है।
अब इसके अलावा हम यहाँ भी क्लास सुपरक्लास बॉक्स का एक और ऑब्जेक्ट प्लेन बॉक्स यहाँ घोषित करते हैं और वॉल्यूम इस एक का वॉल्यूम होल्ड करने का वॉल्यूम है।
अब, अगर हम वेट बॉक्स के लिए वॉल्यूम विधि कहते हैं।
तो, यह वॉल्यूम विधि को कॉल करेगा जिसमें उपवर्ग में परिभाषित किया गया है और तदनुसार वॉल्यूम की गणना अब की जाएगी।
तो, यह अब मुद्रित किया जाएगा, वह सब है।
अब हम अगले वाले पर आते हैं।
अब यहाँ हम देख सकते हैं कि सादा बॉक्स वज़न बॉक्स के बराबर है।
तो, यह संभव है, यहां मूल रूप से हम सुपरक्लास की मदद से एक उपवर्ग का उल्लेख कर रहे हैं।
सादे बॉक्स एक सुपरक्लास ऑब्जेक्ट है और बॉक्स का वजन एक उपवर्ग ऑब्जेक्ट है।
इस तरह का असाइनमेंट काफी वैध है;
इसका मतलब है कि, हम सुपरक्लास ऑब्जेक्ट नाम की सहायता से एक उपवर्ग ऑब्जेक्ट नाम का संदर्भ दे सकते हैं और अगला विवरण भी काफी वैध मात्रा में वहां के सादे बॉक्स के लिए प्राप्त किया जाएगा।
अब, फिर से आप देख सकते हैं कि किस विधि को यहां कहा जाएगा |
यह मूल रूप से वेट बॉक्स विधि का आयतन है जिसे यहाँ कहा जाएगा।
अब इस प्रोग्राम को 6.3 पर चलाते हैं।
इसलिए, हम उस वॉल्यूम को देख सकते हैं जिसे हम यहां प्रिंट कर सकते हैं, उपवर्ग ऑब्जेक्ट का वॉल्यूम है, लेकिन यह सुपरक्लास ऑब्जेक्ट ओके का एक संदर्भ है।
तो, यह 1 डेमो है।
हमारे पास एक और डेमो है, यह डेमो मूल रूप से नाम नेमस्पेस टकराव से बचने के लिए सुपर की उपयोगिता का उपयोग करके समझाने की योजना है।
तो, मूल रूप से, हम नाम का उपयोग कर छुपा नाम को दूर कर सकते हैं
सुपर निर्माण।
हमें ५.५ डेमो हाँ, तो यह एक सरल प्रोग्राम है जिसे हम जांच सकते हैं।
अब, यहाँ हम प्रोग्राम क्लास A को देखते हैं, यहाँ एक वर्ग को पूर्णांक के रूप में घोषित किया गया है और वर्ग B को A से विरासत में मिला वर्ग है और यह भी देखें कि i पूर्णांक स्वयं घोषित है।
अब यहाँ जब भी वंशानुक्रम के माध्यम से, सुपरक्लास में मौजूद वैरिएबल i दोनों को उपवर्ग तक पहुँचा जा सकता है, तो यह एक समस्या बन जाती है इसे टकराव कहा जाता है, टकराने का अर्थ है कि मैं दोनों ठीक है।
अब, निश्चित रूप से, वंशानुक्रम के अनुसार, यह मूल रूप से ओवरराइट करता है जिसका अर्थ है कि इस I को देखने के अनुसार गुंजाइश है, जो कि कक्षा बी में घोषित किया गया है, मूल रूप से इस उपवर्ग वस्तुओं का नहीं है।
तो, यह i, जिसे वास्तव में कक्षा B में घोषित किया गया है, i को वह ऊँचाई देता है जो पहले से ही A में है;
हालाँकि, हम दोनों वेरिएबल को संदर्भित कर सकते हैं और सुपर कीवर्ड का उपयोग करके यह संदर्भ संभव है।
अब हमें कंस्ट्रक्टर को देखते हैं जिसे हमने उपवर्ग ऑब्जेक्ट बी के लिए परिभाषित किया है वह तर्क के रूप में ए और बी पास करने जैसा है।
अब यदि मैं सुपर का उल्लेख करता हूं। यह चर I का उल्लेख करता है, जो कि सुपरक्लास ऑब्जेक्ट में है और इसी तरह I, अगर हम किसी भी चीज का उल्लेख नहीं करते हैं, तो यह मूल रूप से चर i का उल्लेख उसी कक्षा में ही करता है जो यहां बी में है। तो, इस तरह से हम कुछ सुपरक्लास वेरिएबल के साथ-साथ इस तरह से सबक्लास वेरिएबल का उल्लेख कर सकते हैं।
तो, सुपर का उपयोग टकराव को हल करने के लिए किया जा सकता है जो इस मामले में होता है।
इसलिए, बाकी कार्यक्रम बहुत सरल है।
तो, यह विधि हम उन सभी मानों को प्रिंट करेंगे जो उपवर्ग में हैं और साथ ही सुपरक्लास टू प्रिंट स्टेटमेंट का उपयोग किया जाता है और ये मुख्य () विधि है, एक सब-ऑब्जेक्ट सबक्लास ऑब्जेक्ट बनाया जाता है और फिर हम कॉल करते हैं तो विधि, यह 2 मूल्यों वहाँ ठीक मुद्रित करेगा।
इसलिए, उदाहरण के लिए, 1 और 2 को यहां चित्रित किया जाएगा, 1 आंख पर जाएगा, सुपरक्लास मान और फिर 2 मूल्य पर उपवर्ग ओके पर जाएगा।
आइए हम इस कार्यक्रम को जल्दी से चलाएं ताकि हम ठीक से देख सकें कि यह चल रहा है या नहीं और फिर हमारे पास समझ हो सकती है तो सुपरक्लास का उपयोग नाम टकराव को हल करने के लिए किया जा सकता है।
तो हम देख सकते हैं कि ठीक है, इसलिए यह मूल रूप से सफल है, जहां तक ​​निष्पादन का संबंध है।
तो, यह काम करता है।
अब, हमारा अगला प्रदर्शन मूल रूप से यह देखने के लिए कि कोट कतरनी कैसे संभव है, यह गतिशील बाध्यकारी अवधारणा का एक बहुत अच्छा उदाहरण है।
दरअसल, यह एक रनटाइम पॉलीमॉर्फिज्म कॉन्सेप्ट है, यह है कि वे रनटाइम के दौरान यह सुलझाएंगे कि कौन सा तरीका मूल रूप से यहां कहा जाता है।
अब यहाँ हम पहले देख सकते हैं कि हम एक वर्ग को घोषित करते हैं कि कक्षा का नाम एक बिल्ली है और इसमें एक विधि बोली जाती है और फिर यह मूल रूप से इस बयान को यहाँ छापती है।
अब, एक अन्य वर्ग जो मूल रूप से उस वर्ग बिल्ली से विरासत में मिला है वह सुपरक्लास बिल्ली का एक उपवर्ग पालतू बिल्ली है।
इसमें बोलने की विधि भी है और इस विधि में यह कथन है।
अब यहाँ आप देख सकते हैं कि 2 विधियाँ परिभाषित हैं, लेकिन यह एक तरीका है ओवरराइडिंग।
इस प्रकार
पालतू जानवरों की देखभाल में विधि बोलो तब, फिर उपवर्ग विधि बिल्ली में जो विधि है।
अब हम एक और एक वर्ग को भी बिल्ली का विस्तार घोषित करते हैं यह मूल रूप से बहु-स्तरीय मल्टी मल्टीपल है यह हम कह सकते हैं कि 2 विरासत, 2 कई एकल इरादे हम यहां कह सकते हैं क्योंकि हम एक और श्रेणी के बिल्ली से एक और वर्ग जादू बिल्ली प्राप्त करते हैं और हम परिभाषित कर सकते हैं एक चर एक बूलियन प्रकार कोई नहीं है।
अब, शून्य बोलता है अगर कोई नहीं, अगर यह सच है तो इसे सुपर स्पीक कहेंगे।
सुपर स्पीक का मतलब है कि इस मामले में, यह कैट क्लास को बोलने के लिए बुलाएगा जो कि डिक्लेयर मेथड में है, जिस पर चर्चा करने का अर्थ है कि यह म्याऊ स्पिन करेगा और यदि यह गलत है तो यह इस सरल संदेश को बुलाएगा।
अब देखते हैं कि हम गतिशील रूप से इसे कैसे बांध सकते हैं।
हमारा यह कार्यक्रम है, यह थोड़ा मुश्किल है।
आप देख सकते हैं कि ये कथन यहाँ कैसे हैं।
तो, प्रदर्शन_66 मूल रूप से इस मामले में रनटाइम पॉलीमॉर्फिज़्म के बारे में विचार दे रहा है, लेकिन हम इसे सुपर कॉन्सेप्ट का उपयोग करके यहां हल करेंगे।
तो, यहाँ हम एक उपवर्ग पालतू बिल्ली की वस्तु बनाते हैं c १।
तो, यह बहुत आसान है।
इसके अलावा, आप एक और ऑब्जेक्ट c 2 बनाते हैं, मैजिककैट और इसलिए C2 कोई भी नहीं जिसका हम सही उल्लेख करते हैं;
इसका मतलब है, अगर यह कोई नहीं है, तो यह इस सी 2 के लिए सुपरक्लास विधि को स्पिन करेगा।
अब, फिर से सी 2 बोलते हैं।
तो, यह यहाँ विधि को बुलाएगा।
अब c 1 बोलते हैं अगर हम कहते हैं कि यह एक और उपवर्ग वस्तुओं को बुलाएगा जो कि B से मिला है।
अब हम c 2 noOne को मिथ्या मान सकते हैं।
तो, यह अब गलत है और अगर हम फिर से सी 2 बोलते हैं, तो यह एक और तरीका कहेगा।
तो, यह तदनुसार यह म्याऊ म्याऊ मुद्रित करेगा और फिर हैलो बिल्ली।
अब हम रन प्रोग्राम देखते हैं, हम देखेंगे कि यह कैसे ठीक रहेगा।
अब, आप यह देख सकते हैं कि यह मूल रूप से अलग-अलग राज्यों के अनुसार प्रिंट होता है, यह उस अवधारणा के आधार पर है।
तो, यह एक उदाहरण है यहां मूल रूप से हम देख सकते हैं कि कैसे 2 या अधिक वर्गों को एक सुपरक्लास से विरासत में मिला जा सकता है।
यह उदाहरण इस तथ्य को भी दर्शाता है।
अब हमारे पास बहु-स्तरीय विरासत का एक और उदाहरण है।
बहुस्तरीय विरासत का मतलब है कि अगर हम उपवर्ग से एक वर्ग उपवर्ग से प्राप्त कर सकते हैं तो हम दूसरे उपवर्ग को प्राप्त कर सकते हैं।
इसलिए, यह एक बहु-स्तरीय विरासत का उदाहरण है, अब, यहां हम क्लास बॉक्स को देखते हैं जो पहले से ही वैसा ही है जैसा कि हम पहले के प्रदर्शन में चर्चा कर चुके हैं और साथ ही हमने क्लास बॉक्स से प्राप्त बॉक्स वेट का एक और उपवर्ग इस्तेमाल किया था।
इसलिए, यह कमोबेश वैसा ही है जैसा कि हम पहले ही चर्चा कर चुके हैं, अब, यहाँ 2 स्तर की सरल विरासत है।
अब, अगले स्तर में हमें एक और विरासत मिलती है, इसलिए हम एक और वर्ग शिपमेंट को परिभाषित करते हैं यह मूल रूप से वर्ग बॉक्स वजन का उपवर्ग है;
इसका मतलब है कि, बॉक्स भार वर्ग बॉक्स से एक व्युत्पन्न वर्ग है और शिपमेंट बॉक्स भार से एक और व्युत्पन्न वर्ग है।
तो, यह शिपमेंट बहु-स्तरीय विरासत का एक उदाहरण है।
और फिर से उसी अवधारणा के लिए, यह यहां भी लागू होता है, बहु-स्तरीय विरासत को इसके सुपरक्लास कंस्ट्रक्टर को कॉल करके आरंभ किया जा सकता है, इस मामले में, बॉक्स वेट कंस्ट्रक्टर।
तो, सुपर व्ह डीएम को मूल रूप से कंस्ट्रक्टर कहा जाता है जिसे बॉक्स के वजन के रूप में परिभाषित किया गया है, यह इस तरह से है और यह आरंभीकरण है।
अब हम वस्तुओं के निर्माण में आते हैं।
एक वर्ग को एक अमूर्त वर्ग के रूप में परिभाषित किया गया है, जिन सभी वर्गों के बारे में हमने पहले सुपरक्लास पर चर्चा की है, वे हैं वे पहुंच विनिर्देश के साथ हैं इसलिए चूक, वे एक डिफ़ॉल्ट हैं, यहां कोई अन्य पहुंच निर्दिष्ट नहीं है जो इसका उपयोग किया जाता है;
अन्यथा, हम इसके अनुप्रयोग के आधार पर कुछ अन्य एक्सेस स्पेसियर का उपयोग कर सकते हैं।
अब यहाँ हम अमूर्त नामक एक कीवर्ड का उपयोग करते हैं।
यदि हम एक वर्ग से पहले एक अमूर्त खोजशब्द निर्दिष्ट करते हैं तो उस वर्ग को अमूर्त वर्ग कहा जाता है।
तो, इस मामले में, आधार वर्ग को एक सार के रूप में घोषित किया जाता है और एक विधि को भी यदि एक विधि द्वारा निर्दिष्ट किया जाता है जिसे सार कहा जाता है तो विधि को सार कहा जाता है।
तो, इस मामले में, एक वर्ग एक सार है और इस वर्ग में, एक विधि घोषित की जाती है जो कि सार भी है।
यहां तक ​​कि हम बिना किसी अमूर्त के भी एक विधि की घोषणा कर सकते हैं, जिसे एक गैर-अमूर्त विधि भी कहा जाता है, लेकिन इस मामले में, आइए हम विधि को एक सार वर्ग बनाते हैं।
तो, इस सार वर्ग का अर्थ क्या है?
जैसा कि हम पहले से ही इस बारे में जान चुके हैं कि अगर हम एक वर्ग को एक सार वर्ग घोषित करते हैं तो इसका मतलब यह है कि इसके लिए कोई वस्तु नहीं बनाई जा सकती है, लेकिन इस वर्ग का उपयोग किसी अन्य वर्ग को विरासत में देने के लिए किया जा सकता है;
इसका मतलब है कि सुपरक्लास के लिए एक अमूर्त वर्ग का उपयोग किया जा सकता है, लेकिन इस तरह के वर्ग अमूर्त वर्ग के लिए कोई वस्तु नहीं बनाई जा सकती है।
अब, हमारे पास एक उदाहरण है, हम देख सकते हैं कि वर्ग व्युत्पन्न सुपरक्लास बेस का एक उपवर्ग है, इसलिए यह काफी है और यदि कोई सार पद्धति है, तो उपवर्ग में विधि को ठीक से घोषित और परिभाषित किया जाना चाहिए।
तो, विधि यदि आप सार देखते हैं, जब भी आप सार घोषित करते हैं, तो किसी भी कोड का उल्लेख करने की आवश्यकता नहीं है, इसलिए कोई कोड नहीं है, इसलिए यह रिक्त है।
अब यहां आप उपवर्ग घोषणा में देखते हैं कि हमने पूरी तरह से विधि को मजेदार घोषित किया है और इसमें मूल रूप से सिस्टम पिन स्टेटमेंट शामिल है, यह मूल रूप से यह पिन करेगा।
अब, हम यहाँ मुख्य विधि पर आते हैं, अब ६ ६ so को प्रदर्शित करते हैं, तो यहाँ हम देख सकते हैं, इसलिए यहाँ हम देख सकते हैं, यदि हम आधार b, नया b, जैसे कथन को अनसुना करते हैं, तो कथन को अनसुना करें और फिर प्रयास करें इसे चलाएं और हम देखेंगे कि परिणाम क्या है।
तो, यह एक त्रुटि देगा, क्योंकि यहां आधार वर्ग एक सार वर्ग है और हमें ऑब्जेक्ट बनाने का विशेषाधिकार नहीं है।
जैसा कि हम संकलन बेस बी के दौरान स्थिति को देख सकते हैं, नव व्युत्पन्न यह मूल रूप से कह रहा है कि चर बी पहले से ही एक तरह से एक विधि में परिभाषित किया गया है।
इसलिए, मूल रूप से, सार वर्ग को तत्काल नहीं किया जा सकता है आप देख सकते हैं कि एक सार वर्ग को त्वरित नहीं किया जा सकता है क्योंकि यह इस तरह है।
तो, कृपया हमें टिप्पणी दें कि यह फिर से अगले एक बेस बी है, नव व्युत्पन्न यह काफी हाँ है।
इसलिए, अब, हम देख सकते हैं कि आधार प्रकार का संदर्भ इस तरह के उत्थान के माध्यम से हो सकता है।
तो अब,
हम टाइप व्युत्पन्न वर्ग की एक वस्तु बनाते हैं, लेकिन एक बेस क्लास ऑब्जेक्ट के माध्यम से इसे संदर्भित करते हैं यह काफी संभव है और फिर हम b.fun को वहां कहते हैं।
तो, यह मज़ा मूल रूप से मज़ेदार तरीका है, जो उपवर्ग विधि की घोषणा कर रहा है।
तो, यह कार्यक्रम अगर इसे चलाया जाता है, तो यह आउटपुट देगा, इसलिए यह सही तरीके से काम कर रहा है।
तो, यह एक अवधारणा है कि यह वहां है, अब तक अमूर्त वर्ग का संबंध है।
अब यहाँ फिर से कि क्या अमूर्त वर्ग हमने समझा है कि कोई वस्तु नहीं बनाई जा सकती है।
अब, चाहे सार वर्ग हो, कोई भी निर्माता हो सकता है या नहीं।
इसलिए, हमारा अगला उदाहरण इस बात को दर्शाता है कि हाँ एक अमूर्त वर्ग का अपना निर्माता हो सकता है।
इसका मतलब है कि एब्सट्रैक्टर का उपयोग सदस्य तत्वों को इनिशियलाइज़ करने के लिए किया जा सकता है अगर यह वहाँ है अगर यह ऑब्जेक्ट क्रिएशन इवेंट नहीं है।
दरअसल, यह कंस्ट्रक्टर इस वर्ग के उपवर्ग के ऑब्जेक्ट को इनिशियलाइज़ करने के लिए उपयोगी होगा क्योंकि एक अमूर्त वर्ग के लिए उपवर्ग बनाया जा सकता है।
अब, यहां एक उदाहरण है जहां आप देख सकते हैं कि कैसे एक अमूर्त वर्ग का अपना निर्माणकर्ता हो सकता है और एक ही निर्माणकर्ता उपवर्ग वस्तुओं को शुरू करने के लिए कैसे उपयोगी हो सकता है।
तो, यहाँ हम देख सकते हैं कि आधार एक अमूर्त वर्ग निर्माता है यहाँ यह मूल रूप से एक ही कथन को छापता है और अगला मूल रूप से एक अमूर्त विधि है जिसका अर्थ है यहाँ की मस्ती।
और देखें व्युत्पन्न वर्ग यहाँ वर्ग के आधार का एक उपवर्ग है और व्युत्पन्न अपने स्वयं के एक निर्माता है यह व्युत्पन्न है और शून्य मज़ा एक विधि है जो मूल रूप से आधार वर्ग में होने वाले अमूर्त पद्धति का कार्यान्वयन है।
तो, यहाँ व्युत्पन्न है, हालाँकि इस निर्माता को नहीं कहा जाता है;
इसका मतलब है, सुपरक्लास कंस्ट्रक्टर को यहां नहीं बुलाया जाता है।
मैं आपको बताऊंगा कि इसे वैसे भी यहां कैसे बुलाया जा सकता है।
अब हमारे पास इसके बारे में डेमो है;
इसका मतलब यह है कि कंस्ट्रक्टर यह है कि हम इसे ठीक कह सकते हैं।
हम इस कार्यक्रम को थोड़ा बदल सकते हैं कि क्या बेस क्लास कंस्ट्रक्टर को इस पद्धति में व्युत्पन्न वर्ग में बुलाया जा सकता है।
तो, आप कर सकते हैं कि हाँ यह कार्यक्रम ठीक चल रहा है हाँ, तो यह चल रहा है।
तो, क्या हम यहाँ आधार, सरल आधार लिख सकते हैं।
आइए हम कोशिश करते हैं कि इस पद्धति में आधार कॉल चिंता को बुलाया जा सकता है या नहीं।
इस स्थिति में, सुपर यहां काम नहीं करता है, वैसे भी, सुपरक्लास कंस्ट्रक्टर का उपयोग यहां नहीं किया जा सकता है, लेकिन हम व्युत्पन्न वर्ग निर्माणकर्ता बेस क्लास कंस्ट्रक्टर सही सिस्टम में उपयोग कर सकते हैं। हाँ, आप अभी टिप्पणी कर सकते हैं यह ठीक है।
फिर इस व्युत्पन्न वर्ग विधि के भीतर निर्माणकर्ता यहीं पर जाता है, फिर 2 कथन पर जाता है एक सही है कि सुपर हाँ, सुपर लिखने के भीतर हां नहीं 0 का निर्माण करते हैं, ठीक है, हाँ वे ठीक हैं।
अब, हम इस निर्माता को व्युत्पन्न वर्ग निर्माता के माध्यम से कहते हैं।
देखते हैं कि यह हमारे लिए काम करता है या नहीं।
तो, इस मामले में, यह काम करता है कि एक निर्माणकर्ता को उपवर्ग निर्माता के माध्यम से बुलाया जा सकता है केवल अब हमें इस कार्यक्रम को चलाने दें।
यह सुपरक्लास कंस्ट्रक्टर को बेस क्लास कंस्ट्रक्टर ओके कहेगा।
तो, यह मूल रूप से हमने समझा है कि एक निर्माणकर्ता को एक अमूर्त वर्ग में घोषित किया जा सकता है और उसी रचनाकार का उपयोग व्युत्पन्न वर्ग की वस्तुओं में किया जा सकता है।
तो, यह एक उदाहरण है।
अब, हमारे पास एक और उदाहरण है, जैसा कि पिछले उदाहरण में हमने चर्चा की है कि एक अमूर्त वर्ग एक अमूर्त पद्धति के साथ है, लेकिन एक अमूर्त वर्ग में गैर-सार हो सकता है, जिसका अर्थ है बिना किसी के।
तो, वह विधि भी मौजूद हो सकती है, लेकिन इस विधि को उपवर्ग ऑब्जेक्ट के माध्यम से एक्सेस किया जा सकता है।
तो, यह एक उदाहरण है जिसे हम एक डेमो देने जा रहे हैं, यहां क्लास बेस एक सार कीवर्ड के रूप में परिभाषित अमूर्त वर्ग है और फिर इसमें वह विधि मज़ा है जो मूल रूप से गैर-सार पद्धति है।
अब, हम कह सकते हैं कि हम बेस क्लास से विरासत में मिली एक उपवर्ग वस्तु बना सकते हैं और फिर मज़ेदार तरीका यहाँ है क्योंकि यह मूल रूप से यहाँ ओवरराइड विधि है क्योंकि हमने मज़ेदार विधि को ओवरराइड किया है क्योंकि यह इस तरह से ठीक है।
अब हम यहां मुख्य वर्ग पर आते हैं प्रदर्शन_6 1 0 मुख्य वर्ग, हम मूल रूप से नए व्युत्पन्न व्युत्पन्न वर्ग के लिए एक वस्तु बनाते हैं।
तो, इस मामले में, आप समझ सकते हैं। यदि हम मज़ेदार विधि को ठीक कहेंगे।
तो, चलिए इस कार्यक्रम को हम समझ सकते हैं कि यह हमारे लिए कैसे काम करता है।
तो, यह व्युत्पन्न है यहाँ कहा जाता है ठीक है।
तो, व्युत्पन्न निर्माता को कहा जाता है और व्युत्पन्न फोन कहा जाता है, इसलिए यह इस तरह है।
अब हम देखते हैं कि हम कैसे मजेदार विधि का उपयोग कर सकते हैं जो परिभाषित किया गया है कि वे आधार वर्ग विधि में हैं, जिससे यहां कोई वस्तु नहीं आती है।
तो, अब यहाँ नहीं, पिछले कार्यक्रम के रूप में आप अगले एक हाँ पर स्विच कर चुके हैं।
तो, यह मजेदार तरीका जो परिभाषित किया गया है कि वे आधार विधि में हैं मूल रूप से यह अनुमति है कि अमूर्त गैर-अमूर्त विधि।
अब, मेरा प्रश्न यह है कि क्या हम इस गैर-सार पद्धति को यहाँ व्युत्पन्न वर्ग में कह सकते हैं या नहीं।
हम इसे यहाँ उपयोग कर सकते हैं हम सुपर राइट के रूप में उपयोग कर सकते हैं, आप सुपर कीवर्ड का उपयोग कर सकते हैं।
उदाहरण के लिए, मज़ेदार विधि या कहीं सही में हम सुपर लिख सकते हैं। मज़ा, सुपर सही और फिर यह एक।
अब हम समझ सकते हैं कि हमने सही तरीके से मज़ेदार तरीका इस्तेमाल किया।
इसलिए, सुपर कीवर्ड द्वारा हम उस सदस्य का उल्लेख कर सकते हैं जो बेस क्लास में है;
हालांकि ऑब्जेक्ट नहीं बनाया गया है, यह हाँ तक पहुंच जाएगा।
तो, यह सही है हाँ हम इसे समझ सकते हैं।
तो, अब गैर-अमूर्त पद्धति अमूर्त वर्ग में हो सकती है, जैसे कि गैर-अवरोधक डेटा हो सकता है अमूर्त वर्ग में वे सुपर कीवर्ड का उपयोग करके एक्सेस किया जा सकता है जो कि किसी भी उपवर्ग वस्तुओं में है।
हमारा अगला उदाहरण:
मूल रूप से अंतिम कीवर्ड को प्रदर्शित करता है।
यदि आप किसी वर्ग को अंतिम घोषित करते हैं तो अंतिम कीवर्ड एक बहुत ही सख्त कीवर्ड है;
इसका मतलब है, इस वर्ग को किसी अन्य वर्ग में विरासत में नहीं दिया जा सकता है, इसका मतलब यह है कि इस से कोई उपवर्ग नहीं बनाया जा सकता है।
तो, यह एक उदाहरण है जहां बाइक एक वर्ग है जिसे हमने अंतिम घोषित किया है।
तो, अंतिम साधन, कोई विरासत संभव नहीं है।
अब, यह कोड निश्चित रूप से एक वैध कोड नहीं है क्योंकि, हम होंडा 1 नामक एक उपवर्ग बनाने का प्रयास कर रहे हैं, बाइक वर्ग, बाइक वर्ग का विस्तार और फिर निश्चित रूप से यदि यह संभव नहीं है।
तो, अगला कथन मुख्य वर्ग भी मान्य नहीं है, अब हम इस कार्यक्रम को चलाते हैं, देखते हैं कि यह कार्यक्रम एक संकलन त्रुटि देता है या यह ठीक काम करता है।
तो अब, हम देख सकते हैं कि यह एक त्रुटि है जो अंतिम बाइक से विरासत में नहीं मिल सकती है।
तो, इसका मतलब है कि हम यह ठीक नहीं कर सकते।
तो, यह एक है।
अब, यह प्रश्न उठता है कि फिर फाइनल का उपयोग क्या है?
कभी-कभी हमारे पास एक छड़ी प्रतिबंध हो सकता है कि यह वर्ग एक छड़ी वर्ग है जिसे किसी भी वर्ग पर नहीं निकाला जा सकता है क्योंकि व्युत्पत्ति का मतलब सुपरक्लास में कुछ सदस्य तक पहुंचना है।
इसलिए, यदि हम इसे सुरक्षित रखना चाहते हैं, तो हम अंतिम कीवर्ड को ठीक कर सकते हैं।
अब एक वर्ग को अंतिम के रूप में बनाया जा सकता है जैसे कि एक विधि को अंतिम के रूप में भी बनाया जा सकता है, एक चर को अंतिम के रूप में भी बनाया जा सकता है।
अब, यहां अगले उदाहरण में, हम एक डेमो 6.12 देने जा रहे हैं, जिसमें दिखाया गया है कि कैसे एक विधि को अंतिम रूप दिया जा सकता है।
यदि हम एक विधि को अंतिम रूप में घोषित करते हैं, जिसका अर्थ है, इस विधि को किसी भी तरह से ओवरराइड नहीं किया जा सकता है।
तो, यह एक उदाहरण है जिसे हम देख सकते हैं।
क्लास बेस एब्सट्रेक्ट क्लास है, यह ठीक है और एक मेथड फन है जिसे फाइनल घोषित किया गया है।
सका मतलब है कि कोई भी ओवरहीटिंग संभव नहीं है।
अब यहाँ व्युत्पन्न वर्ग है, बेस क्लास है, इसमें कोई अन्य विधि नहीं है या सदस्य ठीक नहीं हैं।
अब हम व्युत्पन्न वर्ग का एक ऑब्जेक्ट बना सकते हैं, लेकिन बेस क्लास को संदर्भित करते हैं और फिर हम b.fun कहते हैं।
तो, यह मूल रूप से ऐप्स को कॉल करेगा, अंतिम विधि जो बेस क्लास में परिभाषित की गई मजेदार विधि है।
तो, यह मजेदार तरीका मूल रूप से system.out.println है अंतिम मज़ा कहा जाता है।
अब, हम इस प्रोग्राम को चलाते हैं, हमारे पास क्विक डेमो हो सकता है ताकि हम इसके बारे में देख सकें।
तो, ठीक है, तो यह चल रहा है।
अब हमें यह देखना है कि क्या हम इसे ओवरराइड कर सकते हैं या नहीं?
यह एक विधि को ओवरराइड करने का एक प्रयास है, यह अगला प्रदर्शन है, कृपया।
इसलिए, हम देख सकते हैं, हम इसे एक विधि पर ओवरराइड करने की कोशिश कर रहे हैं जिसे एक आधार वर्ग में अंतिम विधि के रूप में घोषित किया गया है और व्युत्पन्न वर्ग जिसे हम इसे अधिलेखित करने जा रहे हैं।
अब हम इस कार्यक्रम पर त्वरित नज़र डालते हैं।
तो, यहाँ कक्षा आधारित सार विधि और फिर मज़ा भी अंतिम है।
व्युत्पन्न में हमारे पास व्युत्पन्न विधि है, कोई भी निर्माण नहीं है।
अब, यहां शून्य पैन मूल रूप से उस विधि को ओवरराइड करने का हमारा प्रयास है जो आधार वर्ग में है।
अब हम इस कार्यक्रम को संकलित करते हैं।
यदि यह संकलन करता है तो इसका मतलब है कि यह सफल है।
अब हम इस प्रोग्राम को चलाते हैं, इस प्रोग्राम को संकलित करते हैं यह 62b हाँ ठीक है।
अब देखिए यह संकलन देता है कि व्युत्पन्न इस में मौज-मस्ती को अधिलेखित नहीं कर सकते।
तो, हम समझ गए हैं कि अगर एक विधि को अंतिम रूप में घोषित किया जाता है, तो सुपर क्लास में, यह नहीं हो सकता है
ओवरराइड;
हालाँकि, इसे सुपर या इस कोर्स ओके के संदर्भ में उपवर्ग ऑब्जेक्ट में एक्सेस किया जा सकता है।
तो, यह जावा प्रोग्राम में वंशानुक्रम और वंशानुक्रम में कई विशेषताओं के बारे में प्रदर्शन है।
और हमने चर्चा की है, इसलिए बहुत सी बातें हैं।
यह सलाह दी जाती है कि आपको इस प्रदर्शन में हमारे द्वारा उपयोग किए जाने वाले सभी प्रोग्राम का अभ्यास करना चाहिए, ताकि आप अधिक समझ सकें।
और अगर आपको कोई संदेह है, तो आप जिस भी भ्रम में हैं, आप अपने संदेहों को मंच पर पोस्ट करने के लिए स्वतंत्र महसूस कर सकते हैं ताकि, हम आपके प्रश्न का उत्तर दे सकें।
धन्यवाद, आपका ध्यान के लिए धन्यवाद।
कंप्यूटर विज्ञान और इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर लेक्चर के जावा प्रो। देबासीस सामंत विभाग में प्रोग्रामिंग - 43 स्विंग प्रोग्रामिंग - मैंने AWT और AWT के बारे में सीखा है कि किसी भी ग्राफिकल यूजर इंटरफेस आधारित कार्यक्रम को विकसित करने के लिए पर्याप्त है।
हालांकि, जावा डेवलपर ऐसा नहीं था, AWT से खुश होकर, वे AWT से अधिक कुछ देने का सपना देखते हैं जो अधिक सुरुचिपूर्ण होना चाहिए और फिर उपयोगकर्ता के अनुकूल मुझे कहना चाहिए बल्कि प्रोग्रामर फ्रेंडली;
इसका मतलब है, प्रोग्रामर को यह इतना आसान लगेगा कि वहां उन घटकों को अपने कार्यक्रम में शामिल किया जा सके और यह मूल रूप से इस की प्रक्रिया को कहा जाता है, इस हल्के तरीके से इस चीज को विकसित करने के लिए बिना कोड विवरण के वे अपने विंडो प्रोग्राम को विकसित कर सकते हैं। ।
तो, इस मी जावा डेवलपर के साथ संस्करण 6 से शुरू किया गया एक और उपयोगिता पैकेज एपीआई इसे जावा स्विंग कहा जाता है।
इसलिए, आज के व्याख्यान में हम जावा स्विंग के पहले भाग पर चर्चा करेंगे क्योंकि यह इतना विशाल है कि हमें पूरे पैकेज को एक-एक करके कवर करने के लिए कम से कम 2 मॉड्यूल लेने चाहिए।
इसलिए, पहले हम स्विंग के बारे में चर्चा करेंगे।
जैसा कि मैंने आपको बताया कि जावा डेवलपर ने इसे 6 संस्करण में पेश किया, लेकिन संस्करण 5 और निचला संस्करण जावा स्विंग उपलब्ध नहीं है।
अब जावा स्विंग मूल रूप से जावा का एक हिस्सा है
नींव कक्षाएं जो कि एक फाउंडेशन प्रोग्राम है, जिसे आमतौर पर विकसित किया जाता है, जावा स्विंग बनाने के लिए ओरेकल अधिक मंच स्वतंत्र है।
तो, जावा स्विंगिंग वास्तव में, अर्थ लाइट वेट में AWT से बेहतर लाइट वेट कंपोनेंट प्रदान करता है, जिसका अर्थ है कि हम समझते हैं कि एक प्रोग्रामर कई चीजों को जाने बिना ही यह जान सकता है कि उन सभी चीजों को कैसे किया गया।
इसका मतलब है, हमें कार्यान्वयन के विवरणों के बारे में केवल परेशान करने की ज़रूरत नहीं है, केवल यह विचार है कि यदि यह चीज़ उपलब्ध है तो बस इसका उपयोग करें और फिर अपनी समस्या को हल करें।
इसलिए, यह एक बहुत अच्छी लाइब्रेरी की तरह है जिसे हम बहुत समझदार लाइब्रेरी कह सकते हैं, बल्कि ठीक है, ताकि हम आराम से कई अलग-अलग उपयोगिताओं को प्राप्त कर सकें।
अब, इसलिए, जावा जो एक स्विंग है स्विंग को एक पैकेज में शामिल किया गया है जिसे आप देखते हैं कि यह बिल्कुल वैसा ही नहीं है जैसा कि जावा डॉट पैकेज का नाम है, लेकिन यह नई चीज़ javax डॉट स्विंग है।
तो, javax डॉट स्विंग पैकेज है, यह फिर से है जब भी आप अपने नवीनतम संस्करण के साथ jdk को स्थापित करते हैं तो आप स्वचालित रूप से स्थापित कर पाएंगे यह jdk के साथ बंडल है।
अब, इन javax स्विंग पैकेज में कई घटक शामिल हैं जैसा कि हम पहले से ही कुछ घटकों से परिचित हैं जैसे कि बटन टेस्ट फ़ील्ड सूची मेनू आइटम इस तरह से है, लेकिन जब भी इसे स्विंग घटक से AWT घटक में अंतर करना है, तो वे मूल रूप से उपयोग करते हैं JButton स्विंग में बटन के लिए है जैसे कि JTutField स्विंग में एक पाठ क्षेत्र है और इस तरह से प्रत्येक घटक के लिए एक और पूंजी वर्णों के लिए रवाना हो गया।
इसलिए, प्रत्येक घटक के लिए एक 'J' अक्षर को रोका जाता है।
तो, संकेत करें कि यह वास्तव में स्विंग से है।
इसलिए, अब वे सभी बटन वहां मौजूद हैं;
जाहिर है, सवाल यह है कि तब इस बटन से जेबटन या इस तरह के अंतर में क्या अंतर है और जेबटन बटन से अधिक बेहतर क्यों है, हम इन चीजों को समझने में सक्षम होंगे जब हम स्विंग घटक के बारे में अपनी चर्चा शुरू करेंगे, तो निश्चित रूप से यह अधिक है फायदे और सबसे पहली बात यह है कि एक इंटरफ़ेस में दिखाई देने वाले सभी घटक उस घटक की तुलना में बहुत सुरुचिपूर्ण हो सकते हैं जिसे आप AWT के साथ विकसित कर सकते हैं।
वैसे भी, दोनों चीजों के बीच कुछ अंतर है जो AWT और स्विंग है।
पहली बात यह है कि AWT घटक प्लेटफ़ॉर्म पर निर्भर हैं इसका मतलब यह है कि जावा पर्यावरण की आवश्यकता है ताकि उन सभी चीजों को चलाने के लिए कोई अन्य वातावरण न हो जो आप इसका उपयोग कर सकते हैं।
हालाँकि, जावा स्विंग प्लेटफ़ॉर्म स्वतंत्र है जो भी वातावरण हो ताकि आप बिल्कुल ऐसा हो, आपको परेशान होने की ज़रूरत नहीं है आप इसका उपयोग कर सकते हैं।
और AWT एक घटक भारी वजन हैं;
हैवी वेट का मतलब है कि बहुत सी चीजें जिन्हें आपको अपने खुद के कोड लिखने हैं और वे नहीं हैं बल्कि वे बहुत सार हैं, जबकि, स्विंग घटक AWT घटकों की तुलना में बहुत अधिक सार हैं इसका मतलब है कि आपको उन सभी चीजों के बारे में परेशान करने की ज़रूरत नहीं है आ रहा है और फिर कैसे उन सभी चीजों को लागू किया जाएगा आप बस प्लग और प्ले करें।
और AWT प्लगेबल लुक और फील को सपोर्ट नहीं करता है;
इसका मतलब है, जो भी विचार है कि ऐसा लगता है कि यह वास्तव में आ रहा है, ऐसा नहीं है।
इसलिए, कभी-कभी यह कुछ ऐसा दिखाता है जैसे यह एक अलग रूप में दिखाई दे रहा है, लेकिन यह मूल रूप से प्लग करने योग्य है और महसूस होता है।
तो, वास्तव में यह कैसा दिखता है आप इसे इस तरह पा सकते हैं।
AWT स्विंग की तुलना में कम घटक प्रदान करता है क्योंकि इसमें कुछ ही होता है;
हालाँकि, स्विंग बहुत अधिक घटक प्रदान करता है, फिर AWT घटक जैसे कि टेबल, सूचियाँ, फिर स्क्रॉलपैन, टैबबेडपेन और फिर रंगचूसर आदि, वे सभी चीज़ें AWT में नहीं थीं, लेकिन वे यहाँ जावा स्विंग में हैं।
और जावा स्विंग होने का एक और फायदा यह है कि वे मूल रूप से ग्राफिकल लीजर चौराहे की प्रोग्रामिंग में एक अवधारणा का पालन करते हैं जिसे मॉडल व्यू कंट्रोलर कहा जाता है।
इसलिए, इसे मूल रूप से MVC कहा जाता है, AWT MVC का अनुसरण नहीं करता है तो मॉडल व्यू कंट्रोलर जबकि, स्विंग MVC का अनुसरण करता है। मैं MVC के बारे में विवरणों पर चर्चा नहीं करना चाहता जो इस चर्चा के लिए बहुत अधिक प्रासंगिक नहीं है।
वैसे भी यह एक तरीका है कि ग्राफिकल यूजर इंटरफेस कैसे विकसित किया जा सकता है।
अब, जावा मूल रूप से जेएफसी से है;
जेएफसी ओरेकल जावा फाउंडेशन क्लासेस द्वारा विकसित किया गया है, जो ओरेकल सिस्टम से संबंधित ग्राफिकल इंटरफ़ेस विकसित करने के लिए है।
तो, यह केवल जेएफसी से है।
और फिर यहां मूल रूप से जो भी अलग-अलग वर्ग हैं, जेएफ स्विंग पैकेज के लिए चिंतित हैं, जैसा कि हमने यहां दिखाया है जैसा कि यह सही है।
तो, JComponent मूल रूप से उस घटक से संबंधित है जो AWT घटकों के समान ही है और इन चीजों के अलावा एक कंटेनर है और फिर कंटेनर में पैनल और फिर फ्रेम और इन सभी चीजों और अन्य चीजों के साथ डायलॉग होता है। एक एप्लेट भी हो।
तो, यह मूल विचार है और इसे मूल रूप से स्विंग घटक ठीक कहा जाता है।
तो, स्विंग घटक मूल रूप से जैसा कि आप देखते हैं JComponent मूल रूप से घटकों का उपवर्ग है;
इसका मतलब है, जो कुछ भी AWT में उपलब्ध है, आप इसे यहाँ झूले में रख सकते हैं;
इसका मतलब है कि, स्विंग और AWT दोनों का एक साथ उपयोग किया जा सकता है।
आप किसी का भी उपयोग कर सकते हैं।
तो, इसीलिए यह विचार है।
इसलिए, वे सभी मूल रूप से AWT घटक वर्ग के उपवर्ग हैं जो AWT पैकेज में हैं।
और इसीलिए जब भी आपको इसका उपयोग करना हो तो हमें जावा डॉट AWT डॉट स्टार के साथ-साथ Javax.Swing * का आयात करना चाहिए;
इसका मतलब है, वहां मौजूद सभी सुविधाओं का लाभ उठाने के लिए और विशेष रूप से इवेंट हैंडलिंग सुविधाओं को वहां AWT में ही परिभाषित किया गया है।
तो, वैसे भी आपको AWT पैकेज का उपयोग करना होगा जब आप AWT का उपयोग करते हैं या AWT के अलावा आप स्विंग का उपयोग करते हैं।
तो, यह उन वर्गों के बारे में मूल के बारे में विचार है।
अब, हम उन विभिन्न घटकों के बारे में चर्चा करेंगे जो स्विंग में वहाँ हैं क्योंकि यह वहाँ बड़ी संख्या में घटक हैं जैसा कि आपने बताया है।
इसलिए, निश्चित रूप से सभी घटकों पर चर्चा करने में अधिक समय लगेगा।
इसलिए, मैं थोड़ा तेज हो जाऊंगा मैं यह दिखा रहा हूं कि यह वास्तव में क्या घटक है और फिर क्या तरीके हैं और फिर अन्य निर्माणकर्ता क्या हैं, यह आपकी जानकारी के लिए है।
तो, मेरा सुझाव यह होगा कि यदि आप इसे उस उदाहरण के साथ अभ्यास करते हैं जो यहाँ स्लाइड में दिए गए लिंक के साथ-साथ मेरे द्वारा दिए गए लिंक में भी है और आप किसी भी अन्य स्रोत से एकत्रित किसी भी कार्यक्रम का अभ्यास कर सकते हैं जैसे कि यदि आप अभ्यास करते हैं यह अगर आप चलाते हैं तो आप समझ सकते हैं।
वास्तव में बहुत ही डरा हुआ स्तर दूसरे से बहुत गहराई से सीखना बहुत मुश्किल है।
तो, बेहतर होगा कि आप इसे अपने अभ्यास से सीखें।
तो, आपको इसे सख्ती से अभ्यास करना होगा, ताकि आप इसे सीख सकें।
अब, पहले सभी घटक वर्ग जो वहां मौजूद हैं, जैसा कि आप पहले से ही परिचित हैं, इसमें कुछ विधियाँ हैं जैसे कि घटक जोड़ें।
इसलिए, यदि आप ऐड का उपयोग करते हैं तो किसी भी घटक को किसी अन्य में जोड़ा जा सकता है या तो यह एक फ्रेम में है या इसे किसी एक की तरह एप्लेट में जोड़ा जा सकता है।
और इसमें सेट आकार विधि भी है जो हम पहले से ही जानते हैं और लेआउट सेट करते हैं और दृश्यमान सेट करते हैं और वे विधियाँ पहले से ही मौजूद हैं और उन विधियों का उपयोग तब भी किया जाना चाहिए जब भी आप हमारे कार्यक्रम में कुछ जावा स्विंग घटक शामिल करते हैं।
और जावा स्विंग मूल रूप से पहला है कि हम इस बारे में चर्चा करेंगे कि घटकों को अधिक सटीक रूप से कैसे जोड़ा जा सकता है, जावा स्विंग घटक को हमारे कार्यक्रम में जोड़ा जा सकता है।
मुख्य रूप से 3 तरीके हैं जो मैं आपको एक फ्रेम का उपयोग करके दे रहा हूं जिसे हम इसे जोड़ सकते हैं।
इसलिए, इस उदाहरण में, जैसा कि हम देखते हैं कि हम एक फ़्रेम बनाते हैं और इस फ़्रेम में हम उस चीज़ को जोड़ सकते हैं जो सबसे सरल तरीका है।
दूसरी तरफ हम कंस्ट्रक्टर का उपयोग करके एक और तरीका भी बना सकते हैं और यहां एक बात आप इस उदाहरण में देख सकते हैं, हम एक फ्रेम बनाते हैं और फिर यह फ्रेम मूल रूप से है
इस वर्ग के एक निर्माता का उपयोग करना जो मूल रूप से मुख्य कार्यक्रम है, वहां हम इसे शामिल कर सकते हैं और फिर उस निर्माता को उसके लिए बुलाया जा सकता है।
तो, यह इन चीजों को करने का एक तरीका है, यह मूल रूप से एक ही प्रभाव है।
तो, यह मुख्य कार्यक्रम के भीतर एक तरीका है, बिना किसी उपवर्ग का निर्माण किए हम इसे कर सकते हैं, लेकिन यहां एक उपवर्ग का निर्माण हम कर सकते हैं और फिर आप इसका उपयोग कर सकते हैं।
तो, यह अधिक उपयोगी है क्योंकि अगर हमने एक विकसित किया और फिर उसी वर्ग का उपयोग किसी अन्य कार्यक्रम में भी किया जा सकता है, तो यह एक उदाहरण है।
और तीसरा तरीका यह मूल रूप से है कि यह फ़्रेम का विस्तार कर रहा है।
यह लगभग वही है जो पिछले एक है कि यह मूल रूप से वर्ग का विस्तार है और फिर उसी तरह यह एक जैसा है।
तो, मूल रूप से आप एक फ्रेम विरासत में ले सकते हैं या नहीं, उस स्थिति में यह मूल रूप से कार्यक्रम केवल फ़्रेम तक सीमित है, लेकिन पिछले उदाहरण में आप एक फ़्रेम बना सकते हैं आप इसे जोड़ सकते हैं आप अन्य शायद पैनल प्राप्त कर सकते हैं, आप कुछ चीजें जोड़ सकते हैं उस पैनल में या कुछ और की तरह।
तो, जिस तरह से भी आप इसे करना चाहते हैं आप इसे कर सकते हैं।
तो, ये अलग-अलग तरीके हैं, जिनका हम अनुसरण करेंगे, हम आमतौर पर अपने कार्यक्रम में स्विंग घटकों को शामिल करने के लिए अनुसरण करते हैं।
तो, कोई भी एक विधि आप इसका उपयोग कर सकते हैं, लेकिन प्रदर्शन या चित्रण के लिए, हम उस दूसरी विधि पर विचार करेंगे जिसके बारे में हमने ठीक चर्चा की है।
तो, ये अलग तरीके हैं जिस फ्रेम में जावा स्विंग घटक को फ्रेम में जोड़ा जा सकता है और हम एक-एक करके विभिन्न वर्गों पर चर्चा करेंगे।
लेकिन इस अवधारणा के अलावा, यह पिछले एक की तुलना में कुछ अलग है जैसा कि हम देख सकते हैं कि यह यहां है।
इसलिए, JButton आइकन जैसा कि आप देख सकते हैं कि यह मूल रूप से बिना किसी स्तर के डिफ़ॉल्ट है और यह मूल रूप से एक बटन है जो इस पर कुछ निश्चित स्तर के साथ दिखाई देगा और यह मूल रूप से एक महत्वपूर्ण आइकन है;
जहां आइकन एक वर्ग है जिसे जावा डॉट ग्राफिक्स डॉट इमेज में परिभाषित किया गया है और उस आइकन में मूल रूप से एक छवि दिखाई देती है;
इसका मतलब है, एक बटन
एक छवि शामिल कर सकते हैं।
तो, यह इस बारे में एक विचार है;
इसका मतलब है कि, एक बटन में कुछ भी शामिल नहीं किया जा सकता है एक बटन में एक स्तर के रूप में सरल पाठ शामिल हो सकते हैं, एक बटन एक छवि के रूप में भी शामिल कर सकते हैं।
तो, यह मूल रूप से कार्रवाई है।
इसलिए, मैं यहां जो कुछ भी देखना चाहता हूं, वह यह है कि हम जो कुछ भी पहले से सीख चुके हैं, उसे नियमित रूप से लागू करना भी समान रूप से लागू होता है;
इसका मतलब है, ActionListener जोड़ें और फिर आप श्रोता विधियों को इन सभी चीजों को परिभाषित कर सकते हैं।
जैसा कि हम इस कार्यक्रम में देखते हैं कि हम यही काम करते हैं, हम सभी बटन को एक्शन श्रोता को जोड़ते हैं और फिर हम उस क्रिया के प्रदर्शन के लिए विधि को परिभाषित करते हैं और फिर मूल रूप से यहाँ है कि जब भी कोई बटन क्लिक किया जाता है तो वह इस तरह का पाठ दिखाई देगा।
तो सब।
इसलिए, जो भी एक्शन हैंडलिंग तंत्र हमने पहले ही सीखा है, कि वे इस पर भी लागू हो सकते हैं।
और यह उदाहरण बताता है कि एक बटन के साथ एक छवि शामिल हो सकती है जैसा कि आप देखते हैं कि एक छवि भी बटन पर ही है।
तो, कई छोटे चित्र हैं जिन्हें कुछ और अच्छे अहसास और अच्छे लगने के लिए बटन में एम्बेड किया जा सकता है।
इस तरह के अलग-अलग हैं इसमें 3 4 अलग-अलग निर्माता हैं।
और यह एक उदाहरण है जैसा कि हम देखते हैं कि यह मूल रूप से 2 लैब्स फर्स्ट लिबल और सेकंड लाइबल को प्रदर्शित करता है, विधियां लगभग एक ही AWT हैं जो हमने पहले ही चर्चा की हैं।
इसलिए, मैं इसे विस्तृत नहीं करना चाहता।
JTextField उसी टेक्स्ट फ़ील्ड के समान नहीं है जो वह वहाँ है।
और यहाँ एक उदाहरण है जैसा कि हम देखते हैं कि यह AWT के समान उदाहरण के समान है, इस कार्यक्रम में डिफ़ॉल्ट राज्य के साथ 2 पाठ फ़ील्ड शामिल हैं IIT खड़गपुर और AWT ट्यूटोरियल जैसे।
तो, यह TextFieldExample है जिस पर हमने चर्चा की है यह एक उदाहरण है।
इसके 4 अलग तरीके हैं और फिर 4 अलग-अलग निर्माण और 5 अलग-अलग तरीके हैं।
और ये बहुत सरल उदाहरण हैं कि टेक्स्ट फ़ील्ड क्षेत्र जो इस तरह से यहां आएगा।
इसका मतलब यह है कि यह शब्द डॉट लंबाई पहले से ही जावा डॉट में परिभाषित किया गया है कि किसी पाठ में कितने शब्द हैं, इसकी गणना की जा सकती है इसी तरह से पाठ डॉट लंबाई भी है, यह एक विधि है जो इस पाठ में कितने अक्षर हैं।
तो, यह वहाँ प्रदर्शित करेगा।
तो, यह इतना आसान है, हमें वास्तव में बहुत प्रोग्रामिंग करने की ज़रूरत नहीं है, आपको यह ध्यान रखने की ज़रूरत नहीं है कि बहुत महत्वपूर्ण कार्यक्रम के साथ कितने शब्द हैं जैसा कि आप जानते हैं कि शायद सी या जो भी यह अन्य प्रोग्रामिंग भाषा है।
इसलिए, गिनती चरित्र भी ऐसा नहीं है कि आपको पूरे पाठ के लिए एक-एक करके खड़ा होना है।
यह सिर्फ सरल विधि है जो इसे बहुत कुशलता से और प्रभावी ढंग से करने में मदद करेगी।
तो, यह एक अलग अनुप्रयोग है जो कि मेरे दिमाग में आ रहा है समझाने के लिए तो मैंने अभी इसका उल्लेख किया है।
अब, इसलिए, पहले हम PasswordField कंस्ट्रक्टर को 3 4 कंस्ट्रक्टर्स का उपयोग करके परिभाषित किया जा सकता है।
और एक्शन सुनने को भी वहां जोड़ा जा सकता है;
इसका मतलब है कि, पासवर्डफिल्ड प्राप्त करने के बाद आप यह सत्यापित कर सकते हैं कि यह एक सही पासवर्ड है या नहीं और फिर सत्यापन के माध्यम से आपको स्टोर करना होगा, मुझे इन चीजों की तुलना कुछ स्टोर मूल्य जैसे कहीं और करनी होगी।
तो, ये सभी चीजें आप इसे यहाँ कर सकते हैं उपयोगकर्ता नाम पासवर्ड उपयोगकर्ता
नाम पाठ क्षेत्र हो सकता है और पासवर्ड पासवर्डफ़िल्ड कहा जा सकता है और फिर लॉगिन करें यदि आप इसे क्लिक करते हैं, तो जो कुछ भी आपने इसे टाइप किया है वह लॉगिन होगा।
अब, चेकबॉक्स JCheckBox AWT चेकबॉक्स के समान है और जैसा कि हम देखते हैं कि चेकबॉक्स मूल रूप से एक विकल्प है।
इसलिए, इस उदाहरण में, जैसा कि आप देखते हैं कि यह मूल रूप से चेकबॉक्स है, इसमें 3 आइटम हैं और फिर हम यहां क्लिक कर सकते हैं एक से अधिक क्लिक भी संभव है या सिंगल क्लिक भी संभव है कि आपको इसे अपने उपयुक्त कंस्ट्रक्टर के माध्यम से परिभाषित करना है, चाहे आपको सिंगल क्लिक करना होगा या आपको मल्टीपल क्लिक करना होगा।
और JRadioButton रेडियो बटन हम पहले से ही AWT से परिचित हैं, यह भी है, लेकिन यहाँ JButton के छोर AWT की तुलना में बहुत अधिक सुंदर हैं और यह एक RadioButton का उदाहरण है।
और ये इतने सारे हैं, जैसा कि आप देखते हैं।
और फिर JComboBox यह AWT में सूची आइटम के समान है और यहाँ इस उदाहरण में जैसा कि हम 2 कॉम्बो बॉक्स देखते हैं;
ComboBox1 और ComboBox2 बनाया गया है और ComboBox1 में कुछ आइटम हो सकते हैं और ComboBox2 में कुछ आइटम हैं।
तो, कॉम्बोबॉक्स जितने भी किसी भी फ्रेम या किसी भी प्रभाव में शामिल किया जा सकता है और फिर किसी भी आइटम का चयन किया जा सकता है, आप जिस आइटम का चयन करते हैं, वह आइटम मुख्य कॉम्बो बॉक्स स्लाइड में टेक्स्ट फ़ील्ड क्षेत्र में दिखाई देगा।
अब, Java Swing JTable यह AWT की तुलना में एक नया जोड़ है, यह AWT में नहीं था, लेकिन यह अब यहाँ है यह वर्ग JTable मूल रूप से दिखा रहा है कि पूरी तालिका को कैसे प्रदर्शित किया जा सकता है।
इसलिए, यदि आपकी मेमोरी में पहले से ही एक मशीन संग्रहीत है, तो उस तालिका को यहां प्रदर्शित किया जा सकता है।
और फिर यह एक सरल प्रोग्राम है जिसके द्वारा आप यहां एक टेबल प्रदर्शित कर सकते हैं।
और जैसा कि आप देख रहे हैं कि इस तालिका में तीन पंक्तियाँ हैं और फिर स्तंभ शीर्षक ID, NAME और उसके बाद SALARY है और तालिका इस तरह दिखाई देगी जैसा आप यहाँ देखते हैं।
तो, यह इस तरह है।
तो, यहां तालिका केवल एक उदाहरण के लिए है, लेकिन आप विभिन्न वस्तुओं का एक सेट बना सकते हैं
फ़ील्ड और फिर हम मान प्राप्त कर सकते हैं और फिर हम तालिका में रख सकते हैं और फिर तालिका प्रदर्शित की जा सकती है।
JList भी वास्तव में सूची के समान है।
और हमें इसके बारे में ज्यादा चर्चा नहीं करनी है क्योंकि यह कई तरह से AWT सूची के समान है, इसमें 3 कंस्ट्रक्टर 4 विधियां हैं।
और JoptionPane यह भी एक नई चीज़ है जो AWT में नहीं थी।
JoptionPane मूल रूप से एक पॉपअप डायलॉग बॉक्स है या कभी-कभी यह संदेश बॉक्स कहलाता है जब भी आप कुछ गलती करते हैं स्वचालित रूप से एक संदेश बॉक्स या विंडो के साथ पॉपअप होता है।
तो, यदि आप कुछ संदेशों के साथ इस तरह की कोई विंडो बनाना चाहते हैं, तो यह
सही तरीका है और यदि आप चयन करते हैं तो इसका अर्थ है कि आपने स्वीकार कर लिया है और यदि आप इस दृश्य को रोकते हैं तो आप इसे कर सकते हैं।
और यह एक उदाहरण है IIT की तरह एक मैसेज हेलो वेलकम के साथ एक सरल विकल्प पेन बनाने के लिए।
तो, यह कभी-कभी समय होता है जब हमें अपना संदेश आपके उपयोगकर्ता को देना होता है, तब आप उपयोगकर्ता को विकल्प फलक पर कर सकते हैं।
स्क्रॉलबार बनाने के लिए 3 कंस्ट्रक्टर हैं।
JMenuBar JMenuBar से काफी मिलता-जुलता है। एक नई चीज भी है जो AWT में नहीं थी, मूल रूप से जैसा कि आप देख रहे हैं कि यह MenuBar है, वास्तव में यह MenuBar है यदि आप इसे क्लिक करते हैं तो कुछ अन्य मेनू एक के बाद एक दिखाई देंगे।
तो, कई MenuBar को भी आपके प्रोग्राम में शामिल किया जा सकता है और यह JMenuBar के बारे में विचार है।
इसलिए, मैं सिर्फ JMenuBar के बारे में एक विचार दूंगा, जिसमें मूल रूप से कुछ Jenenu शामिल हैं और JMenuItem भी है।
तो, यह एक उदाहरण है जैसा कि हम यहां देखते हैं कि इसमें मूल रूप से MenuItems 1 और i 2 शामिल हैं और फिर यह मूल रूप से वहां दिखाई देता है और जैसा कि आप MenuItem के लिए जानते हैं कि उप मेनू होगा।
तो, यह सब मेनू के तहत सब मेनू है।
ताकि, उन चीजों को साफ किया जा सके।
तो, यह कार्यक्रम आप अपनी समझ के लिए अभ्यास कर सकते हैं।
और फिर अंत में, जेपीपुपमेनु;
JPopupMenu मूल रूप से है जब भी कुछ दिखाई देगा तो मेनू पॉपअप की तरह होगा।
इसमें 2 कंस्ट्रक्टर हैं जैसा कि हम यहां कंस्ट्रक्टर पर देखते हैं बिना किसी अन्य तर्क के जो स्ट्रिंग तर्क है।
CheckBoxMenuItem CheckBoxMenu CheckBox के समान है। इसमें एक AWT वर्ग है।
यह ऐसा है, कई निर्माणकर्ता आमतौर पर इसका उपयोग करने के लिए थोड़ा जटिल होते हैं।
तो, यह कार्यक्रम का हिस्सा है जिसे आप इसे चला सकते हैं।
वैसे भी, हमने स्विंग घटकों के बारे में चर्चा की है, सभी घटकों में कुछ और घटक नहीं हैं और इस समझ से शायद आपने इस बारे में सुना है कि AWT AWT की तुलना में एक नया है जो बहुत पुराना था।
और स्विंग घटकों का उपयोग करके हम कई अन्य निर्माण कर सकते हैं हम अपने कार्यक्रमों में कई घटकों को शामिल कर सकते हैं जो AWT में संभव नहीं था।
कुछ और भी घटक हैं जिन पर चर्चा करना अभी बाकी है।
तो, उन चीजों पर हमारे अगले मॉड्यूल में चर्चा की जाएगी।
आपका बहुत बहुत धन्यवाद।
कंप्यूटर विज्ञान और इंजीनियरिंग भारतीय संस्थान प्रौद्योगिकी खड़गपुर व्याख्यान में जावा प्रो। देबासीस सामंत विभाग में प्रोग्रामिंग - 46 प्रदर्शन - XVII अब, हमें जावा स्विंग सुविधाओं पर डेमो करें।
अब, जावा स्विंग सुविधा को 2 प्रदर्शन मॉड्यूल में कवर किया जाएगा।
इस प्रदर्शन मॉड्यूल में, हम कवर करने जा रहे हैं कि aj फ़्रेम कैसे बनाया जाए, जिसका अर्थ है कि जावा झूलों के बजाय फ्रेम और फिर पैनल।
और फिर स्विंग बटन वास्तव में विभिन्न घटक एक स्विंग होते हैं और फिर जब भी आपको इस घटक को शामिल करना होता है।
कुछ चीजों को याद रखने की आवश्यकता है, या तो जावा कंस्ट्रक्टर का उपयोग करके हम कुछ घटक जोड़ सकते हैं या फ्रेम क्लास का उपयोग कर सकते हैं या एक्शन लिसनर विधि का उपयोग कर सकते हैं और हम यह भी देखेंगे कि जो जे बटन से जे बटन से थोड़ा अलग है कि एक बटन में एक छवि कैसे शामिल हो सकती है, इसका मतलब है कि वास्तव में छवि वाला बटन।
और फिर हम जोड़ और घटाव का उपयोग करते हुए सरल कैलकुलेटर के बारे में चर्चा करेंगे, जिसकी चर्चा हमने अपने टेक्स्टफिल्ड में की है, यहां तक ​​कि वहां प्रदर्शन पर भी ध्यान दिया जाता है, वही चीजें होंगी लेकिन केवल पाठ और शब्द का उपयोग करने वाले शब्दों और वर्णों की संख्या का पता लगाने के लिए जावा के स्विंग का उपयोग करना ।
तो, ये एक और फायदा है कि हम जावा स्विंग से हो सकते हैं यह इस तरह से है कि मैं स्विंग अधिक बेहतर है क्योंकि इसमें बहुत सारे अंतर्निहित कार्यक्रम हैं स्वचालित रूप से यह है।
इसलिए, ऑटोमोटिव या अकाउंट और फिर कैरेक्टर काउंट को भी GUI से और फिर अन्य GUI घटक जैसे TextField PasswordField और फिर Login PasswordField या सब कुछ कवर किया जाएगा और फिर CheckBox RadioButton Jspinner और फिर इन सभी चीजों को टॉगल करें बटन को सुधारा जा सकता है। इन सभी कार्यक्रमों के प्रदर्शन को समायोजित करने के लिए।
j फ्रेम पर प्रदर्शन, जिसका अर्थ है कि जावा स्विंग का उपयोग करके एक कंटेनर में एक फ्रेम कैसे शामिल किया जा सकता है और इन चीजों के लिए जैसा कि आप जानते हैं कि हमें javax.swing.star आयात करना है, यह आवश्यक है अगर हम स्विंग घटक को शामिल करना चाहते हैं। और फिर अन्य चीजों को आयात java.awt.star की तरह शामिल किया जाना चाहिए और ये सभी चीजें वहां हैं जो इस से संबंधित हैं।
वैसे भी, इसलिए हमने इसमें शामिल हैं कि वे चीजें हैं जो वे javax.swing.star हैं। इसमें वे सभी पैकेज शामिल होंगे जो वहां हैं।
और इसके द्वारा उन सभी वर्गों को परिभाषित किया गया है जो इस कार्यक्रम के लिए सुलभ होंगे और यह कार्यक्रम बहुत ही सरल है क्योंकि आप देखते हैं कि हम एक फ्रेम ऑब्जेक्ट का नाम बनाते हैं जिसे हमने बनाया है बस फ्रेम है और स्तर JFrame उदाहरण है।
और फिर हम एक पैनल की भी घोषणा करते हैं और फिर लेआउट को हमने फर्श लेआउट में बैठते हैं जो आपने पहले ही awt के संदर्भ में जान लिया है और फिर स्तर बटन के किनारे के साथ शुरू किया गया है।
लेकिन एक स्तर को JFrame के रूप में आरंभीकृत किया गया है उदाहरण के लिए यह सब और फिर बटन एक वस्तु एक घटक पर है यहां बनाया गया है और उन सभी चीजों को पहले इस पैनल में जोड़ा गया है और फिर पैनल को उस फ्रेम में जोड़ा गया है जो यह नीति है मूल रूप से वह।
तो, पैनल में विभिन्न Jswing घटक शामिल हैं और अंतिम पैनल को फ्रेम ऑब्जेक्ट में शामिल किया गया है और फिर हमें सिर्फ हाँ करना है।
तो, अगर हम इस एप्लेट का आउटपुट देखते हैं तो आप इसे आउटपुट को पा सकते हैं जो आप इसे यहाँ प्राप्त कर सकते हैं जैसा कि आप यहाँ देख रहे हैं थोड़ा स्क्रीन के बारे में होगा तो ठीक है, इसलिए उदाहरण के लिए JFrame
और फिर यह बटन वहाँ है।
तो यह एक सरल उदाहरण है कि एक फ्रेम में विभिन्न Jswing घटकों को शामिल किया जा सकता है कि वे कैसे हैं यहां पैनल स्तर और बटन सब कुछ शामिल है।
अब, अगला उदाहरण मूल रूप से पैनल से संबंधित है, इसलिए एक पैनल कैसे बनाया जा सकता है और पैनल को जोड़ा जा सकता है हमने पहले ही उदाहरण दिया है पिछले मामले में भी यह केवल स्पष्ट रूप से वहां पैनल किया गया है।
तो, आइए हम इस कार्यक्रम का आउटपुट लें और यहां आप देख सकते हैं कि विभिन्न बटन की पृष्ठभूमि को यहां बदला जा सकता है कि कैसे अलग-अलग रंग भी यहां संभव हैं।
और फिर फ़्रेम की एक पृष्ठभूमि ग्रे या सफेद है जिसे आप कह सकते हैं और फिर पैनल जो कुछ भी ग्रे है और यह सब कुछ आपने इसे यहां स्थापित किया है।
अब, हमारा अगला उदाहरण मूल रूप से स्विंग का उदाहरण है, इसलिए एक स्विंग बटन कैसे बनाया जा सकता है और इसे एक फ्रेम में जोड़ा जा सकता है, यह बहुत ही सरल है, जैसा कि आप यहां देखते हैं कि हम पहली बार एक फ्रेम बनाते हैं जिसका शीर्षक फ्रेम है जैसा कि मैं नहीं बताता हूं कि फ्रेम में यह इस मामले में यहाँ है।
फिर हम JButton बनाते हैं बटन को क्लिक के रूप में समतल किया जाता है और फिर हम इस बटन को फ्रेम f में जोड़ते हैं और फिर अंत में हम फ्रेम के विन्यास के बारे में फ्रेम के विन्यास को परिभाषित करते हैं और फिर दृश्यता उन कॉन्फ़िगरेशन प्रोटोकॉल के लिए मानक होते हैं जो आपको करने होते हैं यह।
तो, यह चित्रण के लिए एक बहुत ही सरल उदाहरण है जिसमें एक फ्रेम शामिल है एक फ्रेम सामग्री एक बटन एक स्तर किनारे पर क्लिक करें हाँ यह ठीक है कि यह उदाहरण पर बहुत सरल है।
तो, तीन तरीके हैं जो एक फ्रेम हो सकते हैं और फिर विभिन्न तरीकों को शामिल किया जा सकता है और अंत में, पूरे जीयूआई का निर्माण किया जा सकता है।
इसलिए, यह मूल रूप से निर्माण विधि के अंदर GUI घटक बनाने के बारे में एक विचार है और यहां आप सरल उदाहरण देख सकते हैं यहां हम उस वर्ग का नाम देते हैं जिसे हम GUI के लिए विकसित करने जा रहे हैं, कक्षा का नाम प्रोग्राम है। सरल और इस मामले में और साधारण वर्ग में जैसा कि आप देखते हैं कि इसमें फ्रेम घोषणा है।
और फिर कंस्ट्रक्टर सरल और हम इसके अंदर
निर्माता जीयूआई बनाने के लिए जिस भी प्रक्रिया का पालन करने की आवश्यकता है, हम उसे परिभाषित करते हैं।
जैसा कि आपने यहां किया है एक JButton बनाएं और उस बटन को फ्रेम में जोड़ा गया है और फिर फ्रेम को आकार दिया गया है और जो कुछ भी है वह है और अंत में मुख्य विधि में हम बस कंस्ट्रक्टर को स्वचालित रूप से कॉल करके इस वर्ग का एक उदाहरण बना सकते हैं।
इसलिए, यह चिंता केवल एक निर्माता की है कि वे सरल हैं।
तो इस तरह से वास्तव में इस चीज का क्या फायदा है कि कोड साझा करना संभव है यदि आप अलग-अलग पैकेजों में वर्ग करते हैं और फिर हम इसे शामिल कर सकते हैं।
और फिर इस वर्ग से हम केवल वस्तु का निर्माण कर सकते हैं और फिर उस वस्तु के निर्माण में मूल रूप से जीयूआई के विभिन्न हिस्सों को शामिल किया जाता है जो कि बड़े में शामिल किया जाना है।
तो, यह मूल रूप से बॉटम-अप दृष्टिकोण के बारे में विचार है, इसलिए नीचे का स्तर प्रत्येक जीयूआई घटक के लिए सभी श्रेणी की घोषणा है और फिर शीर्ष स्तर पर बड़ी सामग्री है जिसे यह ठीक से डिज़ाइन किया जा सकता है।
तो, यह एक विचार है इसके बारे में हमारा अगला उदाहरण मूल रूप से एक ही बात है, लेकिन यहां हम एक उदाहरण बना सकते हैं और फिर उस उदाहरण के लिए हम उन वस्तुओं को बना सकते हैं जो वे यहां हैं और फिर हम कह सकते हैं कि बनाने की कोई आवश्यकता नहीं है स्पष्ट रूप से एक ही वर्ग का उदाहरण।
यह एक उदाहरण है जहां हम बिना किसी ऑब्जेक्ट को बनाए हुए देख सकते हैं, हालांकि हम इसमें कुछ घटक जोड़ पाएंगे।
इसलिए, यह उदाहरण मूल रूप से इस तथ्य को दर्शाता है कि वास्तव में यह पिछले उदाहरण के समान है।
अब कहते हैं कि देखते हैं कि अब तक की कोडिंग में क्या अंतर है।
अब यहाँ हमने क्लास सिंपल को परिभाषित किया है जो कि JFrame का विस्तार करता है जो कि यहाँ केवल एक अंतर है जो पहले केवल क्लास के लिए सरल है, लेकिन आपको इसे विस्तारित करना होगा।
इसका मतलब है कि, यह मूल रूप से JFrame का यह उपवर्ग है। वास्तव में JFrame के इस मामले में नमूना 2 का नमूना है और फिर हम एक फ्रेम ऑब्जेक्ट बनाते हैं और फिर हम कंस्ट्रक्टर सरल 2 को परिभाषित करते हैं और फिर हम बटन b बनाते हैं और फिर बटन जोड़ते हैं।
अब यहाँ आप देखते हैं कि हम बटन जोड़ते हैं और स्पष्ट रूप से हमें इस बात का उल्लेख करने की आवश्यकता नहीं है कि यदि यह ऐड बटन इस फ्रेम में जाता है, क्योंकि फ्रेम उपवर्ग वस्तु है।
तो, यह बटन फ्रेम पर ही लगाया जाएगा जो कि मुख्य है जो मुख्य विधि में शामिल है मुख्य वर्ग वहां है और अंत में, मुख्य विधि मूल रूप से इस वर्ग के उदाहरण से बनाई गई है जिसे कंस्ट्रक्टर को कॉल करने के माध्यम से बनाया गया है।
तो, यह मूल रूप से एक ही है क्योंकि यह आपको मिल सकता है दूसरा एक अंतिम उदाहरण अधिक बेहतर है जो यह सब बहुत सरल दिखता है यह थोड़ा सार है, लेकिन यह भी है कुछ प्रोग्रामर इस तरह के कोडिंग को पसंद करते हैं और एक अन्य उदाहरण ActionListener के साथ बटन है।
इसलिए, यहां तक ​​कि सबसे महत्वपूर्ण भाग को संभालना भी है, इसलिए हम उदाहरण के लिए उदाहरण के लिए एक्शन लिस्ट को प्रत्येक बटन से कैसे जोड़ सकते हैं।
और इस उदाहरण में हम देखते हैं कि हम तेजी से एक फ्रेम बनाते हैं और इस फ्रेम में हम 1 बटन का नाम जोड़ते हैं जो हमने बी और बी के रूप में दिया है और इसे ठीक से कॉन्फ़िगर और फ्रेम में जोड़ा गया है और फिर हमें जोड़ना होगा उस के लिए श्रोता विधि ActionListener जोड़ें।
New ActionListener सही विधि है और फिर यह मूल रूप से यह होगा
जो कुछ भी निर्भर करता है वह क्रिया को प्रिंट करेगा, अर्थात यदि हम बटन पर क्लिक करते हैं तो स्वचालित रूप से इस घटना को अंजाम दिया जाएगा घटना कोड को भी एकजुट किया जाएगा कोड भी निष्पादित किया जाएगा और यह इस तरह से जावा बिंदु पर पाठ स्वागत प्रदर्शित करेगा और फिर अंत में यह होगा परिणाम प्रदर्शित करें।
तो, यह एक उदाहरण है जिसे हमने बटन दिखाया है।
अब, यहाँ चित्र के साथ अगला उदाहरण बटन है।
तो, यहाँ एक अच्छी बात यह है कि जावा स्विंग बटन के लिए चिंतित है कि हम बटन पर कुछ बटन छवि जोड़ सकते हैं।
इसलिए, यह कोड वहां है जो आपको केवल उस स्तर को सेट करने के बजाय बस करना है जो हमने उस छवि प्रकार के आइकन में किया है जिसे हमें वहां जोड़ना है।
इसलिए, हमने इसे यहां किया था हमने जेबटन बी बनाया है और फिर हम कहते हैं कि हम एक छवि आइकन जे बनाते हैं।
तो, पाठ फ़ील्ड को कैसे जोड़ा जा सकता है और TextField को जोड़ने के बाद कैसे अलग-अलग गतिविधियों को इस TextField के लिए वास्तविक रूप से हैंडल किया जा सकता है।
इसलिए, यह फिर से बहुत ही सामान्य कैलकुलेटर के समान है जिसे हमने पहले ही चर्चा की है जबकि हम नियमित प्रबंधन को संभालने के बारे में भी चर्चा कर रहे हैं और वे मूल रूप से यहां हैं हम एक ही चीज को शामिल करेंगे, लेकिन यहां हम केवल जावाबटन और जावा पाठ भरने की विधि का उपयोग करते हैं है।
यह मूल रूप से एक ही बात है पहले यह किसी भी स्विंग पैक स्विंग पैकेज के बिना था यहां केवल उस चीज का उपयोग किया जाता है जिसे हमने स्विंग पैकेज आउटपुट और डिस्प्ले में इस्तेमाल किया है और सबकुछ ठीक है, उदाहरण के लिए, ठीक है।
आप कोड के माध्यम से जा सकते हैं और फिर आप समझ सकते हैं कि यह मूल रूप से पिछले कोड के समान है जो वहां मौजूद है और आप बटन को थोड़ा अलग पा सकते हैं बटन बटन की तुलना में थोड़ा अलग है जो कि awt बार का उपयोग करके बनाया गया था। इस तरह के घटक।
अब, हमारा अगला उदाहरण अन्य कुछ आवश्यक घटकों पर चर्चा करने के लिए है, जो स्पष्ट रूप से जावा स्विंग के लिए एक विशेष रूप से विशिष्ट रूप से उपयोग नहीं किया जाता है, अर्थात् लॉगिन उद्देश्य के लिए टेक्स्टफिल्ड के अलावा पासवर्ड फ़ील्ड, जैसा कि आप जानते हैं कि जब भी उपयोगकर्ता को कुछ साइटों में लॉग इन करना होता है। सर्वर, उन्हें मूल रूप से एक एप्लेट या विंडो प्रदर्शित करने की आवश्यकता थी, इसमें लॉगिन और फिर पासवर्ड शामिल थे।
तो, एक TextField के रूप में लॉग इन करें जबकि पासवर्ड एक PasswordField के रूप में दिखाई दिया है, इसलिए PasswordField को यहां पर java स्विंग का उपयोग करके इलाज किया जा सकता है जैसा कि आप देखते हैं।
तो, लॉगिन आप कुछ भी टाइप कर सकते हैं जो कि यहां तक ​​कि कुछ भी पता है, तो आप बस लॉगिन कर सकते हैं जैसा कि आप जानते हैं कि आप लिख सकते हैं कि एक बस उदाहरण के लिए है और पासवर्ड मेरा पासवर्ड है।
अब, यदि हम इसे क्लिक करते हैं और आपके पास जो भी पासवर्ड है, जो आपके प्रोग्राम का है, वह इसे समझ सकता है और तदनुसार यह इस पर पिन करेगा, इसलिए पासवर्ड यह एक है जो कुछ भी है।
अब तो ये चीजें हैं जिन्हें हम कार्रवाई कर सकते हैं और फिर उत्पन्न भी किया जा सकता है और इन घटनाओं के लिए कार्रवाई जो भी आप योजना बना सकते हैं कि आप इंटरफ़ेस में जोड़ सकते हैं, इसलिए यह पासवर्डफिल्ड के बारे में है।
जैसा कि आप यहां 2 चेकबॉक्स और C ++ और जावा को देखते हैं और यदि हम C ++ पर क्लिक करते हैं तो आप देखेंगे कि चेकबॉक्स का चयन जावा से C ++ की तरह हो जाएगा, इसलिए स्वचालित रूप से यह एक जोड़ा जाएगा।
अब रेडियो बटन चेकबॉक्स के समान एक और उदाहरण है जैसा आपने दिखाया है, लेकिन चेकबॉक्स में चेक बॉक्स का आयताकार दृश्य है।
तो, यह यहाँ है इसे चेकबॉक्स कहा जाता है, दूसरी ओर, रेडियोबटन मूल रूप से बटन एक रेडियो की तरह दिखता है, इसका मतलब है कि यह गोलाकार प्रकार है जो रेडियोबटन और चेकबॉक्स के बीच एकमात्र अंतर है अन्यथा प्रक्रिया विधि और सब कुछ चेकबॉक्स के समान ही।
तो, चेकबॉक्स और रेडियो बटन वास्तव में एक ही प्रोग्राम हैं, केवल चेकबॉक्स से घटक प्रकार को बदलकर JRadioButton जैसे और यह कोड है और जैसा कि आप देख सकते हैं कि यह चीजें हैं और अगर हम क्लिक करते हैं तो यहां प्रकाश डाला जाएगा, का उपयोग करके माउस क्लिक इवेंट को घटना को समझने के लिए यहां जोड़ा जाना चाहिए और उस घटना के अनुसार आप हमारे स्वयं के कोड को लिख सकते हैं, ताकि ईवेंट हैंडल सामान्य कोड प्रोग्रामर द्वारा लिखा जा सके।
तो, यह रेडियोबटन उदाहरण का एक उदाहरण है, हमारा अगला उदाहरण मूल रूप से जेस्पिनर है, जैसा कि आप जानते हैं कि जेस्पिनर मूल रूप से पाठ्यक्रम का विकल्प दे रहा है, लेकिन आम तौर पर थोड़ा संख्यात्मक रूप में।
इसलिए, यहां संख्यात्मक रूप और सीमा और सब कुछ निर्दिष्ट किया जा सकता है जैसा कि आप यहां देखते हैं और अगर हम इसे स्क्रॉल बार बिल्कुल नहीं करते हैं तो यह वास्तव में स्पिनर मूल्य का मूल रूप से वृद्धिशील या गिरावट है।
तो इस में
उदाहरण के रूप में हम इस उदाहरण में देखते हैं जैसा कि आप देखते हैं कि हम प्रारंभिक मान 5 के साथ एक स्पिनर जेस्पिनर बनाते हैं, इसलिए डिफ़ॉल्ट रूप से हम इस 0 को बदल सकते हैं और फिर बाद में हमें इसे 0 बनाते हैं और फिर इसमें मानों की सीमा होती है जो इसे भिन्न कर सकते हैं 0 से 10 और 0 से 10 की तरह और वेतन वृद्धि 1 है।
इसलिए, यदि हम उस 0.5 वेतन वृद्धि को दे सकते हैं जिसे आप 0 5 और 0.5 समझ सकते हैं और सब कुछ इतना 0.5 वेतन वृद्धि है।
तो, हम इसे सीख सकते हैं हाँ, जैसा कि आप इसे सीखते हैं जैसा कि आप शुरू में देख सकते हैं कि स्क्रीन में 0 थोड़ा बड़ा है, ताकि हम इसे थोड़ा स्पष्ट रूप से देख सकें, हाँ थोड़ा बहुत थोड़ा हाँ।
अब जैसा कि आप अब यहाँ देखते हैं यदि हम ऊपरी क्लिक करते हैं तो हम इसका उपयोग कर सकते हैं इसलिए यह बढ़ेगा जैसा कि आप देखते हैं कि हम क्लिक कर रहे हैं और स्वचालित रूप से स्पिनर मान वर्तमान मान से 1 वेतन वृद्धि से लेकर हर बार और फिर 10 के बाद किसी भी समय कम हो रहा है आप ठीक ठीक कहते हैं।
इसलिए, यदि हम इसे घटाते हैं तो इससे कोई वृद्धि नहीं होगी।
अब, यहाँ यह विचार है कि यहाँ वृद्धिशील मूल्य का कोई भी मूल्य हो सकता है यहाँ हमारे पास 1 है, इसलिए यदि मैं 0.25 तक कर सकता हूँ तो मानों की सीमा स्वतः ही बदल जाएगी और फिर यह आपके लिए काम करेगा।
तो, यह केवल संख्यात्मक सीमा के लिए है, फ़्लोटिंग-पॉइंट में इसके लिए किसी अन्य सीमा की अनुमति नहीं दी जा सकती है और इन सभी चीज़ों की अनुमति नहीं है, इसलिए यह JSpinner है और हमारा अगला उदाहरण ToggleButton है।
अब, इस उदाहरण में, हम यहाँ देखते हैं कि आकार में थोड़ा बहुत बड़ा है हाँ, तो कहीं भी बटन डिफ़ॉल्ट नहीं है पर अब अगर हम इस पर क्लिक करते हैं तो स्वचालित रूप से OFF में बदल जाते हैं।
तो जाहिर है, इसके लिए दिनचर्या लिखने की जरूरत है, बस यहां कोड आएगा हम देख सकते हैं कि जेबटन के मामले में कोड क्या है?
इसलिए, यहां हमने एक उदाहरण बनाया है कि हमारे पास जो वर्ग है वह मूल रूप से JFrame का विस्तार है।
तो, ए
JFrame के कंस्ट्रक्टर को पहले सार्वजनिक स्थैतिक शून्य मुख्य स्ट्रिंग बनाने की जरूरत है और फिर हम इसे बनाने के लिए यहां एक निर्माता के रूप में ToggleButton उदाहरण बना सकते हैं।
कंस्ट्रक्टर अब सेट शीर्षक द्वारा रीसेट हो गया है, इसका मतलब है कि फ्रेम इस प्रकार है फ्रेम का शीर्षक वास्तव में आइटम श्रोता के साथ टॉगलबटन है, क्योंकि, यह बटन नहीं हो सकता है कि एक्शन इवेंट एक्शन श्रोता यह आइटम श्रोता है और फिर हमने अभी परिभाषित किया है FlowLayout आप किसी भी अन्य FlowLayout को बदल सकते हैं या यदि आप सेट लेआउट को परिभाषित करते हैं तो वे जो भी हैं वे हैं।
तो, डिफ़ॉल्ट लेआउट प्लानिंग वहां होगी और JToggleButton SetAction को सेट करें और फिर सेट साइज सेट ट्रू दिखाई दें और डिफॉल्ट बंद ऑपरेशन सेट करें ये ToggleButton के लिए सामान्य तरीका है कि आपको इसे बाहर निकालना या बंद करना होगा इसलिए यह वहां है
अब यहाँ आप बस टॉगलबटन विधि सेट करने के लिए आते हैं जो आपने उनका उपयोग किया है कि ये मूल रूप से टॉगल कैसे होंगे।
तो, यह चालू है क्योंकि यह चालू है और बीच में बंद है और फिर बटन जोड़ें और फिर सेट की गई कार्रवाई मूल रूप से आइटम जोड़ना है यहां सेट नहीं करना है।
इसलिए, यदि आप इस घटना को सुन सकते हैं यदि ऐसा कुछ भी होता है और फिर हम आइटम को परिभाषित करने का निर्णय लेते हैं तो राज्य परिवर्तन घटना वहां होती है जो आइटम घटना के बारे में है जैसा कि मैंने पहले ही सेट किया है और फिर यदि चयनित है तो यह मूल रूप से पाठ बंद सेट करता है।
यदि आप किसी भी चीज़ का चयन नहीं करते हैं तो यह वही रहेगा जो अब है अगर मैं इसे ट्रू पर बदले में बदल दूं और फिर गलत है तो वास्तव में हम किसी भी मूल्य को वहीं बदल सकते हैं और फिर यहाँ पर ऑन के बजाय ट्रू ऑन बस लिख सकते हैं सच।
जैसा कि आप यहां देख रहे हैं हां अब तो बटन यहां है हम देख सकते हैं कि यह एक है, अगर हम इसे क्लिक करते हैं तो आप देखेंगे कि परिवर्तन सही से गलत हो जाएगा।
तो, बटन पर क्लिक करें हाँ, जैसा कि आप देख रहे हैं कि यह वहां है और अन्य सभी चीजें यहां लागू हैं।
अब हम कुछ घटकों को समझ गए हैं कुछ और घटक भी हैं जो हमारे अगले डेमो क्लास में शामिल होंगे।
अगले डेमो क्लास में JavaSwing घटकों के बारे में कुछ और अवधारणाएँ शामिल होंगी।
आपका बहुत बहुत धन्यवाद।
कंप्यूटर साइंस एंड इंजीनियरिंग इंडियन इंस्टीट्यूट ऑफ टेक्नोलॉजी, खड़गपुर लेक्चर के देबा समसांता विभाग के जावा प्रो में प्रोग्रामिंग - 40 एडब्ल्यूटी प्रोग्रामिंग- II यह हमारी AWT सीखने का अगला भाग है।
हमने कुछ बुनियादी घटकों के बारे में चर्चा की है और वे हमारे विंडो प्रोग्राम को बनाने के लिए बहुत उपयोगी हैं।
अब हम इस मॉड्यूल में लेआउट मैनेजर के बारे में चर्चा करने जा रहे हैं।
इसलिए, अलग-अलग लेआउट हैं जिनकी आवश्यकता है जिसका मतलब है कि मुझे आपकी खिड़कियों को प्रबंधित करने की आवश्यकता है और इसके बारे में हम चर्चा करेंगे।
तो, इसलिए मूल रूप से यह चर्चा लेआउट प्रबंधकों के साथ GUIs GUIs से संबंधित है।
अब, अलग-अलग लेआउट प्रबंधक क्या हैं?
फिर से, लेआउट प्रबंधकों को AWT पैकेज में परिभाषित किया गया है और इसका उपयोग या तो स्पष्ट रूप से या अंतर्निहित रूप से किया जा सकता है, यदि आप इसका उल्लेख नहीं करते हैं तो डिफ़ॉल्ट रूप से कुछ लेआउट भी होगा।
और मुख्य रूप से जावा में चार अलग-अलग प्रकार के लेआउट मैनेजर क्लासेस होते हैं, जिन्हें फ्लो लॉयआउट, बॉर्डरलेआउट, ग्रिडलाइयूट और उसके बाद कार्डलैटआउट कहा जाता है और यह सब लेआउट मूल रूप से यह प्रबंधन करने के लिए है कि संपूर्ण कंटेनर, या तो एक फ्रेम या पैनल या कंटेनर है जो कुछ भी हो सकता है। कामयाब रहे।
अब, हम उदाहरण के साथ एक-एक करके प्रत्येक प्रबंधक के बारे में व्यक्तिगत रूप से चर्चा करेंगे और यह भी देखेंगे कि इन सभी चीजों को प्रबंधित करने के लिए अलग-अलग निर्माणकर्ता और विधियाँ क्या हैं।
आइए सबसे पहले चर्चा करते हैं FlowLayout Manager पर।
तो, FlowLayout प्रबंधक का अर्थ क्या है?
यह वहाँ है।
अब यह प्रबंधक प्रोग्रामर को कंटेनर में विभिन्न तत्वों के प्रबंधन में मदद करता है।
अब तो ऐसा कैसे हो सकता है अगर आप ऐड जोड़ने पर जा सकते हैं।
तो, उन्हें कंटेनर में कैसे जोड़ा जा सकता है?
तो, लेआउट मैनेजर यह फ्लो -आउट प्रबंधक आपको बताता है कि यदि आप पहले घटक को जोड़ते हैं तो यह इस स्थिति में यहां जाएगा।
अब, अगला कंपोनेंट हम अपने आप यहाँ पर जाएगा, फिर यहाँ पर और एक बार ये सब स्पेशल फिल्ड होगा तब अगला हम वहां आएंगे।
तो, यह मूल रूप से यह पंक्ति है और फिर यह एक है।
तो, पंक्ति-वार और फिर यह एक।
तो, इस तरह कंटेनर हम स्वचालित रूप से भरते चले जाएंगे।
अब यहाँ विचार यह है कि आपको यह स्पष्ट रूप से उल्लेख करने की आवश्यकता नहीं है कि यह बटन वहाँ जाएगा या नहीं यह बटन आप बस बटन बनाने पर जाते हैं और फिर इसमें फ़्लो -आउट प्रबंधक का उपयोग करके जोड़ते हैं फिर फ़्लो -आउट प्रबंधक स्वचालित रूप से उन्हें समायोजित करता है।
परंतु;
हालाँकि, आप कह सकते हैं कि विभिन्न तत्वों और उन सभी चीज़ों के बीच एक अंतर है जिसे आप निर्दिष्ट कर सकते हैं और इस फ़्लोएलआउट प्रबंधक का उपयोग करके यह करने की सुविधा है।
अब, देखते हैं कि इस प्रबंधक के लिए वर्ग की परिभाषा क्या है और इसलिए, इस प्रबंधक के तीन निर्माणकर्ता हैं जैसा कि हम यहां देखते हैं FlowLayout और फिर FlowLayout पूर्णांक संरेखण;
इसका मतलब है, जो कि क्षैतिज संरेखण या अंतिम उदाहरण है जो मैंने देखा है कि क्षैतिज तत्व आता है।
और फिर वर्टिकल एलिमेंट का मतलब है शायद यह भी यही है।
तो, इस तरह से यह वहाँ भी है अन्यथा यह रास्ता है।
तो, वहाँ वास्तव में विभिन्न तत्व हैं।
वैसे भी;
इसलिए अलग-अलग निर्माता हैं और फिर से अगर हम देखते हैं कि यह एक और निर्माणकर्ता हैगैप और फिर वीजीएपी;
इसका मतलब है कि।
इसलिए, यदि यह एक घटक है तो यहां एक और घटक जोड़ा जाता है।
तो, अगर यह hgap है, अब अगर यह एक और घटक है तो यह मूल रूप से vgap है।
तो, इन सभी चीजों का आप अपने आई मीन फ्लोआउट मैनेजर क्लास कंस्ट्रक्टर में उल्लेख कर सकते हैं और फिर उन्हें स्वचालित रूप से समायोजित किया जा सकता है।
तो, यह एक अलग तरीका है फ्लोलेयूट प्रबंधक एक प्रोग्रामर को विभिन्न घटकों को बनाए रखने या उन्हें शामिल करने में मदद करता है।
और यहां एक उदाहरण दिया गया है कि हम यह देखें कि हम इस फ़्लोयआउट प्रबंधक को किसी प्रोग्राम में कैसे उपयोग कर सकते हैं।
हमने एक वर्ग को परिभाषित किया है MyFlowLayout जावा प्रोग्राम का नाम है जिसे हम इसे बनाने जा रहे हैं।
सबसे पहले, हम एक फ्रेम बनाते हैं और फिर हम 5 बटन बनाते हैं
इन बटनों को 1, 2, 3, 4, 5 की तरह लेबल किया गया है;
इसलिए 5 बटन बनाए गए हैं।
अब, हमारा उद्देश्य क्या है?
हमारा उद्देश्य इस बटन को इस फ्रेम में जोड़ना है।
तो, ये मूल रूप से कथन है जिसके द्वारा हम इस सभी 5 बटन को फ्रेम में जोड़ सकते हैं।
अब यहां अगला बिंदु आपको दिखाई देता है कि यह फ़्रेम लेआउट के साथ सेट किया जा सकता है, यह एक विधि है जिसे घटक वर्ग और फिर घटक वर्ग के रूप में परिभाषित किया गया है और ff f फ्रेम है जो घटक के उपवर्ग के रूप में फ्रेम है जो कि है setLayout इसके लिए सुलभ है और फिर setLayout हमने बस इस FlowLayout, FlowLayout राइट का उपयोग करके setLayout बनाया है।
इसका मतलब है कि यह सही संरेखण है, अब जैसा कि आप मूल रूप से इन प्रबंधक को देखते हैं FlowLayout प्रबंधक FlowLayout प्रबंधक सभी तत्वों को सही संरेखण और सही संरेखण में प्रबंधित करता है, लेकिन इस दिशा में, यह मूल रूप से इस दिशा की तरह है।
और अगर आप अधिक जोड़ सकते हैं तो यह फिर से आएगा और फिर यह ऐसा है।
तो, हमेशा सही संरेखण तरीका है।
तो, एफ 5 के बाद आप 6 एफ 7 एफ 8 एफ 9 एफ 6 एफ 7 एफ 8 एफ 9 एफ कर सकते हैं, लेकिन संरेखित केवल सही होगा।
तो, इस तरह से यह मूल रूप से भूमिका है कि लेआउट प्रबंधक, इस मामले में, FlowLayout प्रबंधक खेला जा सकता है और आप देख सकते हैं कि कैसे FlowLayout प्रबंधक को इस एक में सौंपा जा सकता है।
हमारे सभी पहले के उदाहरण डिफ़ॉल्ट मैनेजर मूल रूप से फ्लो -आउटआउट मैनेजर हैं, हमने इसका उल्लेख नहीं किया है, यदि आपने उल्लेख नहीं किया है तो डिफ़ॉल्ट है, लेकिन यहां हमने फ्लो -आउटआउट का उल्लेख किया है, जो कि सही संरेखण के साथ है, यह दूसरा निर्माता है जिसे हमने इसे कहा है और यह मूल रूप से है फ्रेम का आकार निर्धारित करना और फिर दृश्यमान सच करना;
ताकि फ्रेम उपयोगकर्ता को दिखाई दे सके।
तो, यह वह तरीका है, जिस तरह से फ्लॉलेटआउट मैनेजर का उपयोग आपके प्रोग्राम में विभिन्न वर्गों के प्रबंधन के लिए किया जा सकता है।
अब हम एप्लेट के बारे में चर्चा करेंगे एप्लेट के बारे में चर्चा करते हैं इतने सारे बटन हैं तो कई अन्य घटक तत्व हैं।
इसलिए, वे सभी इस फ़्लो -आउट प्रबंधक का उपयोग करके प्रबंधित किए जा सकते हैं या कुछ अन्य प्रबंधक अन्य प्रबंधक भी हो सकते हैं।
अब, देखते हैं कि अन्य प्रबंधकों को क्या माना जाता है जिसे अब अगला उदाहरण माना जा सकता है।
तो, बॉर्डरलेयूट मैनेजर का विचार मूल रूप से यह है कि अगर यह आपका पूरा है अगर यह पूरा है तो इसे फ्रेम या एप्लेट होने दें जो कुछ भी है तो बॉर्डरलेआउट का अर्थ है मूल रूप से इसकी कुछ सीमाएं हैं, एक यह एक सीमा और एक सीमा है, दूसरी सीमा, एक और सीमा और केंद्र है।
तो, यह मूल रूप से उत्तर, दक्षिण, पूर्व, पश्चिम और केंद्र है।
तो, इसे सीमा कहा जाता है कहीं भी यह विचार नहीं है कि यह लेआउट प्रबंधक हम इस क्षेत्र में कुछ घटक रखेंगे तो कुछ घटक यहाँ कुछ घटक यहाँ कुछ घटक यहाँ;
इसलिए पूरे फ्रेम को वास्तव में इस रूप में प्रबंधित किया जा सकता है।
तो, यह बॉर्डरलेउट मैनेजर के बारे में विचार है।
अब देखते हैं कि बॉर्डरलेयूट मैनेजर को कैसे आमंत्रित किया जा सकता है और इसका मतलब यह है कि इस वर्ग के लिए यह कैसा है।
और बॉर्डरलेयौट मैनेजर के लिए वर्ग की परिभाषा का संबंध है, इसमें दो कंस्ट्रक्टर हैं पहला पहला डिफ़ॉल्ट कंस्ट्रक्टर है और दूसरा कंस्ट्रक्टर जिसके द्वारा हम hgap और vgap निर्दिष्ट कर सकते हैं;
इसका मतलब है, दो सीमाओं के बीच का अंतर जिसे हम कह सकते हैं और फिर संरेखण को भी संरेखित किया जा सकता है।
अब, यहां एक उदाहरण है कि आप देख सकते हैं कि बॉर्डरलेयूट मैनेजर का उपयोग एक खिड़की को विकसित करने के लिए वहां खेलने के लिए कैसे किया जा सकता है और इस उदाहरण में जैसा कि आप देखते हैं कि फ्रेम वह फ्रेम है जिसमें 5 बटन शामिल हैं जो 5 बटन हैं यहां घोषित किए गए हैं।
ये सभी 5 बटन
उत्तर दक्षिण पूर्व और पश्चिम के रूप में लेबल किया जाता है यह उदाहरण के लिए बटन लेबल है, यह वास्तव में एक बटन है, यह एक बटन है, यह एक और बटन है।
तो, 5 बटन ठीक हैं;
इसलिए उन 5 बटन को यहां घोषित किया गया है और यहां आप देख सकते हैं कि हमने सेट सीमा का उपयोग करके बटन का आकार तय नहीं किया है।
तो, यदि आप इसे करते हैं तो यह सभी बटन उस तरह दिख सकता है, लेकिन यहां यदि आप ऐसा नहीं करते हैं तो यह पूरा हिस्सा मूल रूप से इस बटन के लिए है यह एक और बटन है जो वहां और सब कुछ होगा।
अब, देखते हैं कि उन सभी बटनों को इस के किस भाग में रखा जा सकता है।
तो, हमारा अगला बयान मूल रूप से f dot add है;
इसका मतलब है, हम इस बटन को इस सीमा में इस बॉर्डरलाइन डॉट नॉर्थ का उपयोग करके जोड़ते हैं।
तो, यह मूल रूप से कहने के लिए है कि यह बटन इस तरह उत्तर स्थिति में जाएगा, बटन b2 दक्षिण एक पर जाए और बटन b3 पूर्वी बटन b4 पश्चिम और फिर अंत में, 5 बटन मूल रूप से केंद्र और फिर अंत में, आकार फ्रेम यह वहाँ है और फिर दृश्यमान ये सामान्य विवरण हैं।
अब आप FlowLayout और BorderLayout के बीच अंतर पा सकते हैं।
यदि आप इस मामले में FlowLayout का उपयोग करते हैं उदाहरण के लिए;
इसलिए, यह इस तरह होगा और फिर यहाँ आएँगे तब यह और फिर इसे इस तरह एक, लेकिन यहाँ वास्तव में यह मूल रूप से एक बार जब आप इसे योजना बनाते हैं तो आप अपनी इच्छा के अनुसार अपना घटक रख सकते हैं।
तो, यह बॉर्डरलेउट मैनेजर के बारे में विचार है और अब हमें अगले प्रबंधक के बारे में चर्चा करने दें, इस अगले प्रबंधक को ग्रिडलाइयूट कहा जाता है, यह एक लेआउट मैनेजर के लिए भी बहुत महत्वपूर्ण है, जैसे कि फ्लो -आउटआउट, लेकिन यह बहुत कम है अलग अर्थ भी।
फ़्लो लाइयआउट के मामले में एक ग्रिड का मतलब है कि आप बस जोड़ते जा सकते हैं लेकिन फ़्लो लयआउट के मामले में आप बस जोड़ते चले जाएँगे और फिर स्वचालित रूप से इसे समायोजित कर देंगे और समायोजन hgap vgap और जो कुछ भी है, द्वारा अधिकतम नियंत्रित किया जा सकता है।
लेकिन इस GridLayout के बारे में क्या विचार है कि अगर यह ऐसा है तो हम पूरे कंटेनर को कई ग्रिड में बना सकते हैं, तो ग्रिड की संख्या n क्रॉस m हो सकती है।
यदि n क्रॉस m का अर्थ है कि n संख्या पंक्तियाँ और m संख्या कॉलम हैं।
तो, मूल रूप से, पूरे कंटेनर पैन की तरह होगा।
तो, एन क्रॉस मी;
इसका मतलब है, इतनी सारी चीजें अब फिर से हैं यह बॉर्डरलेयूट से एक अंतर है कि बॉर्डरलैट केवल 4 के मामले में है, लेकिन यहां एन क्रॉस मी का मतलब है मी और एन में।
इसलिए, प्रति तत्व की संख्या को यहां और वहां अब इस उदाहरण में रखा जा सकता है क्योंकि हम देखते हैं कि यह एपलेट है जिसमें छह बटन शामिल हैं।
तो, पहली पंक्ति में दो बटन, दूसरी पंक्ति में एक और दो और तीसरी पंक्ति में प्रत्येक पंक्ति में दो बटन होते हैं।
तो, यह मूल रूप से हम कह सकते हैं कि 3 पार दो है GridLayout आकार यह वहाँ है।
तो, GridLayout केवल इस तरह है कि अब हम देखते हैं कि यह GridLayout आपके घटक वर्ग में कैसे परिभाषित होता है।
और यहां एक उदाहरण है जैसा कि आप देखते हैं कि यह मूल रूप से ग्रिडलाइउट फॉर्म में 9 ग्रिड बनाने के लिए एक उदाहरण है, और यहां 9 ग्रिड में 9 बटन होते हैं जैसा कि आप यहां देखते हैं।
सो हम्
9 बटन बनाएं और फ्रेम यहां है हम इस सभी बटन को यहां जोड़ते हैं।
अब जब भी आप इसे जोड़ते हैं तो यह मूल रूप से उस तरह से चल रहा है, 1 2 3 जैसे एक फ्लो लेआउट मैनेजर जैसा है और अब देखें कि हम ऐसा कैसे कर सकते हैं।
तो, एक नया सेट ग्रिडलआउट तीन क्रॉस इन तीनों से मूल रूप से संकेत मिलता है कि इस मामले में आपके ग्रिड का आकार क्या होगा।
तो, यह GridLayout प्रबंधक और ग्रिड को आमंत्रित करने के लिए यहां सबसे महत्वपूर्ण बिंदु है;
इसलिए यह इस मामले में है।
इसलिए, यदि आप फ्लो का उपयोग करते हैं तो मेरा मतलब है फ्लो -आउट, फिर ग्रिडलाइयूट के बजाय, फ्लो -आउटआउट लगभग वही चीजें हैं जो वहां आएंगी, लेकिन उस स्थिति में, आकार और सब कुछ निर्दिष्ट किया जा सकता है।
यहां प्रत्येक घटक के लिए किसी भी आकार को निर्दिष्ट करने की आवश्यकता नहीं है, बल्कि हम केवल उल्लेख कर सकते हैं, हालांकि हम प्रत्येक के लिए अंतर का उल्लेख कर सकते हैं।
तो, यहाँ आप तीन तीन क्रॉस कर सकते हैं और फिर इन दोनों के बीच क्या अंतर है और हम इन और इन दोनों के बीच का उल्लेख कर सकते हैं, तो उस मामले में मूल रूप से छोटे आकार का भी उल्लेख किया जा सकता है यदि अंतर इस तरह निर्दिष्ट किया गया है।
तो, वहाँ अधिक अच्छी लग रही है वहाँ है, लेकिन हम एक डिफ़ॉल्ट अंतर है मतलब है कि दो आसन्न घटकों के बीच कोई अंतर नहीं होगा।
तो, यह है यह इस तरह दिखेगा।
और इसलिए ये हैं कि अलग-अलग बटन बनाए जा सकते हैं, उन्हें फ्रेम में जोड़ा जा सकता है और उन्हें ग्रिडलाइउट मैनेजर की मदद से जोड़ा जा सकता है और फिर प्रोग्राम को उसी तरह निष्पादित किया जा सकता है, हम इसे देख सकते हैं।
तो, यह GridLayout उदाहरण और फिर CardLayout के बारे में विचार है, यह बिल्कुल एक पैनल की तरह है, निश्चित रूप से, कार्ड वास्तव में क्या है एक कार्ड मूल रूप से एक और है जिसे हम पैनल प्रकार की बात कह सकते हैं, लेकिन कई कार्ड हो सकते हैं फ्रेम में जोड़ा जाएगा।
तो, यह CardLayout की अवधारणा के बारे में विचार है।
तो, हर कार्ड वहाँ मूल रूप से एक तत्व है।
अब, इस लेआउट को क्लास कार्ड लेआउट के रूप में परिभाषित किया गया है जो कि क्लास के घटक के उप-वर्ग में है।
और इसमें दो कंस्ट्रक्टर हैं जैसे कि आप डिफॉल्ट कंस्ट्रक्टर को देखते हैं, जो हमने देखा है वह डिफॉल्ट कंस्ट्रक्टर का परिणाम है अन्यथा हम उल्लेख कर सकते हैं
कार्ड के बीच hgap और vgap भी ताकि कार्ड अपने आकार में कम हो जाएगा।
तो, कार्ड का आकार hgap और फिर vgap का उपयोग करके बनाए रखा जा सकता है।
अब, यह एक उदाहरण है जैसा कि आप देख सकते हैं कि हमने एक एप्लेट में कार्ड जोड़े हैं।
तो, यह एक एपलेट प्रोग्राम है और यहां लेआउट है कि हमारे पास कार्डलैयूट का उपयोग है।
तो यह है
मूल रूप से यह कहने के लिए कि हम इस कंटेनर और सेटलाइट लेआउट के लिए हमारे प्रबंधक के रूप में कार्डलैटआउट का अनुसरण करना चाहते हैं।
तो, यह मूल रूप से वह विधि है जिसके द्वारा CardLayout या अन्यथा setLayout नया CardLayout भी सीधे यहां उपयोग किया जा सकता है।
अब यहाँ हम जोड़ते हैं कि हमने यहाँ क्या जोड़ा है मूल रूप से कार्ड के रूप में 4 5 बटन हैं।
तो, ये मूल 5 अलग-अलग एप्लेटलेट्स हैं जो वास्तव में यहां देखें, पहले एप्लेट दृश्य में हम बस क्लिक करते चले जाते हैं और फिर स्वचालित रूप से यह वहां होगा मैंने तीन 5 अलग-अलग उदाहरणों का उपयोग किया है।
तो, पहले, मान लीजिए कि कार्ड पाँच है।
तो, इसलिए यह विचार यहाँ है कि कार्ड 5 मूल रूप से बटन है।
तो, पूरे बटन मूल रूप से एक कार्ड इस तरह दिखना चाहिए।
तो, यहाँ पूरा बटन एक कार्ड की तरह दिखता है, लेकिन बटन के बजाय कुछ अन्य चीज़ों को भी शामिल किया जा सकता है जो कुछ भी है वह इसमें कुछ अन्य एप्लेट को भी शामिल कर सकता है और।
इसलिए, यहां वास्तव में हमने बटन के रूप में 5 कार्ड बनाए, जैसे कि वे इस एप्लेट में जोड़े जाते हैं और फिर हम कुंजी डाउन पर घोषणा करते हैं जो कि इवेंट हैंडलिंग की पूरी तरह से अलग अवधारणा है।
तो, कीडाउन एक ऐसा तरीका है जिसे इवेंट क्लास में परिभाषित किया जाता है, हम और फिर वह इवेंट क्लास कंपोनेंट के अलावा होता है। की -डाउन मूल रूप से एक अमूर्त तरीका है जिसे हमें इसे लिखना है।
तो, यह कीडाउन कुंजी कीडाउन विधि एक बुनियादी घटना से निपटने है यदि हम एक आई मीन माउस बटन दबाते हैं तो वह कीडाउन या माउस बटन नहीं है जिसे हम कह सकते हैं कि कीडाउन एक कुंजी दबाने से संबंधित है।
इसलिए, यदि हम एक कुंजी दबाते हैं तो ईवेंट जेनरेट होगा;
इसका मतलब है कि, एक कुंजी दबाने पर यह आपकी घटना है और फिर यह मूल रूप से वापस आती है जो कुंजी है कि उपयोगकर्ता ने इसे दबाया है और फिर लेआउट। स्नेक्स मूल रूप से यहां यह कह रहा है कि इस लेआउट का अगला अर्थ है यदि आप इसे दबाते हैं तो यह जाएगा अगले कार्ड।
यदि आप अगले पिछले के बजाय का उपयोग करते हैं तो इस तरह पिछले कार्ड पर जाएंगे।
तो, पिछला या अगला जो कुछ भी है, वह है और सही रिटर्न का मतलब है कि यह सिर्फ वापसी का मामला है।
तो, कुंजी यह KeyDown ईवेंट है, यह ईवेंट स्वचालित रूप से वहां परिभाषित किया जाता है और आप बस इसे दबाते हैं और फिर स्वचालित रूप से यह ईवेंट इसे चला देगा और फिर यह जो भी अगली क्रिया है, उसे उत्पन्न करेगा।
तो, वे विधियाँ हैं।
तो, यह कार्यक्रम वास्तव में ऐसा है यदि आप इसे शुरू में चलाते हैं, तो यह कार्ड 1 है और यदि आप एक कुंजी दबाते हैं तो कार्ड 2 फिर कार्ड 3।
फिर से अगर आप दबाते हैं तो Card4 और Card5, फिर से Card5 के बाद अगर आप इसे फिर से जगह देते हैं तो Card1 और इतने पर।
तो, यह मूल रूप से पॉप अप जैसा दिखता है;
इसका मतलब है, अलग-अलग कार्ड पॉप अप होंगे और फिर आप इसे प्रदर्शित कर सकते हैं।
तो, इस कार्ड में कुछ चित्र या कुछ अन्य तत्व या कुछ अन्य चीजें शामिल हो सकती हैं।
तो, आपके उपयोगकर्ता की तरह अलग-अलग सुविधाओं को देने के लिए अलग-अलग कार्ड की योजना बनाई जा सकती है।
तो, यह तरीका है जिस तरह से CardLayout प्रबंधक को डिज़ाइन किया जा सकता है और फिर निर्णय लिया जा सकता है।
और यहाँ एक ठीक है;
इसलिए इंटरएक्टिव एप्लेट मैं केवल एक उदाहरण देना चाहता हूं कि इंटरेक्टिव एप्लेट कैसे बनाया जा सकता है। एक 5 है और अगर यह 6 है तो ग्यारह को प्रदर्शित किया जाएगा।
तो, यह एक एप्लेट का एक सरल उदाहरण है जो हमारे पास होने वाला है।
अब, देखते हैं कि इस कार्यक्रम के लिए यह एक बहुत ही सरल कार्यक्रम है।
और इसलिए एक एप्लेट प्रोग्राम है, इसलिए एप्लेट का विस्तार किया जाता है यह एप्लेट प्रोग्राम का नाम है।
अब दो टेक्स्ट फील्ड टेक्स्ट फील्ड इनपुटए और इनपुटबी हैं जैसा हमने कहा है।
तो, यह मूल रूप से एक इनपुट है और दो टेक्स्ट फ़ील्ड की तरह इनपुट b है और फिर यह इनिट विधि है जो मूल रूप से दो टेक्स्ट फ़ील्ड बनाती है।
तो, इनपुट ए बनाया जाता है एक मूल रूप से घोषित किया गया है और उन्होंने तुरंत बनाया और 8 मूल रूप से आकार है;
इसका मतलब है कि अधिकतम 8 अंक इन क्षेत्रों में डाले जा सकते हैं।
और फिर इनपुट को एक अतिरिक्त इनपुट साधन जोड़ें।
इसलिए, यह इनपुट वे टेक्स्ट फील्ड इनपुट a और इनपुट b हैं, दो टेक्स्ट फ़ील्ड इस में जोड़े गए हैं और अब यह डिफ़ॉल्ट रूप से ग्रिड डिफ़ॉल्ट है।
तो, इसे मूल रूप से इस तरह प्रदर्शित किया जाता है और फिर ग्राफिक्स हम केवल मूल्य को नियंत्रित करने के लिए पेंट विधि का उपयोग कर सकते हैं और फिर वहां से घटना को ले सकते हैं, वास्तव में यहां घटना भी होती है क्योंकि कुछ नंबर टाइप करना मूल रूप से इस एक के लिए भी एक घटना है। ।
अब, आप यहां देखते हैं कि हम आपके लिए कौन सी पेंट विधि करेंगे।
तो, हम घोषित करते हैं x और y दो मान हैं, दो-तीन अलग-अलग पूर्णांक तत्व चर को xyz घोषित किया जाता है और s एक स्ट्रिंग है।
अब यहां एक महत्वपूर्ण बात यह है कि जो भी चीजें हैं, जावा उन्हें एक स्ट्रिंग के रूप में मानता है।
तो, यह भी एक स्ट्रिंग है, यदि आप कुछ टाइप करते हैं तो यह वास्तव में एक स्ट्रिंग है और फिर उस स्ट्रिंग को पूर्णांक में बदलना होगा।
तो, यह मूल रूप से एक पाठ प्राप्त करने के लिए है मूल रूप से स्ट्रिंग और फिर स्ट्रिंग यह पूर्णांक में परिवर्तित करके पूर्णांक का उपयोग करके है।
तो, x मूल रूप से यहाँ जो भी उपयोगकर्ता इनपुट है वह पूर्णांक के रूप में संग्रहीत है।
इसी तरह, अन्य इस पाठ से वाई दायर किया गया है क्षेत्र z मूल रूप से योग है और फिर हमें इसे प्रदर्शित करना होगा।
तो, हम इस जेड को इस सूत्र, अभिव्यक्ति का उपयोग करके स्ट्रिंग में बदल देते हैं और फिर अंत में, जी डॉट स्ट्रिंग 10 है।
तो, यह हम प्रिंट करेंगे और फिर मूल्य यहां प्रिंट किया जाएगा।
तो, यह एक सरल उदाहरण है जो मूल रूप से हम जो भी एप्लेट जानते हैं उसका उपयोग करके और जीयूआई घटकों का उपयोग करके दिखाते हैं यहां हमने केवल एक पाठ में उपयोग किया है।
इसलिए, यह संवादात्मक है क्योंकि हम इसका उपयोग करते हैं और फिर स्वचालित रूप से इसमें प्रवेश करेंगे और यह परिणाम वहां प्रदर्शित होगा जो यह सब बहुत सरल है एक बार जब आप देखते हैं कि यह सब कुछ करने के लिए कितने कम पाठ्यक्रम हैं तो यह सब कुछ है।
तो, इसीलिए इस प्रोग्रामिंग को लाइटवेट प्रोग्रामिंग कहा जाता है, क्योंकि आप बस इसे लगा सकते हैं और फिर काम को आसानी से पूरा कर सकते हैं और फिर p से बहुत सारे समर्थन हैं AWT पैकेज जो वे आपको देंगे और फिर सब कुछ लागू करेंगे।
तो, केवल यह वास्तव में अन्य प्रोग्रामिंग अवधारणाओं की तुलना में बहुत सरल है।
तो यह
इंटरएक्टिव एप्लेट्स और ईवेंट हैंडलिंग के बारे में एक उदाहरण एक बहुत ही महत्वपूर्ण एक अवधारणा है जिसे अच्छी तरह से चर्चा करने की आवश्यकता है।
हमारे अगले मॉड्यूल में, हम इसके बारे में चर्चा करेंगे, लेकिन मैं इस घटना को संभालने वाली अवधारणा की एक झलक देना चाहता हूं।
इन कुछ स्लाइडों को मूल रूप से समझाया गया है कि वास्तव में ईवेंट हैंडलिंग क्या है क्योंकि हमने फैसला किया है कि जब भी आप एक माउस क्लिक करते हैं तो यह एक घटना बन जाती है जब भी आप एक कुंजी दबाते हैं तो यह एक घटना बन जाती है यदि आप एक माउस को खींचते हैं तो यह एक घटना भी है।
तो, यह मूल रूप से घटना कहा जाता है।
अब, यदि यह घटना होती है, यदि आप एक माउस कुंजी माउस को क्लिक करते हैं तो मान लें कि यदि आप एक बटन क्लिक करते हैं तो बटन मूल रूप से उपयोगकर्ता के लिए कुछ सुविधाएं उत्पन्न करना चाहिए।
मान लीजिए कि आप एक बटन पर क्लिक करते हैं और तब बटन मूल रूप से होता है, जब भी क्लिक करें या तो यह एप्लेट बंद कर देता है या यह मूल रूप से एक वीडियो चलाता है, तो आप स्वचालित रूप से वीडियो खेल में आ जाएंगे और यह वहां प्रदर्शित करेगा।
तो, यह मूल रूप से घटना से निपटने की अवधारणा है।
तो, मुख्य रूप से दो उपकरणों का उपयोग किया जाता है कुंजी को संभालने के लिए मूल रूप से माउस और कीबोर्ड हैं जो मानक माउस हैं और कीबोर्ड मूल रूप से एक घटना उत्पन्न करने के लिए साधन हैं।
और फिर एक बार घटना उत्पन्न होने के बाद उन्हें प्रत्येक कार्यक्रम के लिए संबंधित कार्यक्रम द्वारा नियंत्रित किया जा सकता है।
इसलिए, यहां एक प्रोग्रामर है, हमें यह तय करना होगा कि यदि कोई घटना होती है, तो उस घटना के लिए हम उपयोगकर्ता की तरह उत्पन्न होने वाली संबंधित कार्रवाई क्या होगी।
तो, एक ईवेंट ईवेंट का एक स्रोत हो सकता है जो मूल रूप से अलग घटक है और जिस पृष्ठभूमि पर आपको होना है
प्रोग्राम लिखें कि अगर उस घटना को माउस या कीबोर्ड से ट्रिगर किया जाता है तो परिणाम क्या होगा यह वास्तव में है।
अब तक अलग-अलग तरीके कि माउस घटना यहां हो सकती है हमने कुछ चीजें सूचीबद्ध की हैं।
इसलिए, माउस घटना के लिए अब है, यहाँ एक उदाहरण है कि कैसे घटना यहाँ हो सकती है, मैं कह सकता हूँ कि यह केवल उदाहरण के लिए एक बहुत ही सरल उदाहरण है।
अब आप देख सकते हैं कि हमने यहाँ क्या किया है यह एक एप्लेट है और इस एप्लेट में I मतलब कंटेनर है वास्तव में हम 1 2 3 4 देखते हैं ये 15 बटन हैं।
तो, 15 बटनों को इस तरह से 1 2 3 4 के रूप में लेबल किया जाता है और इन सभी लेआउट्स का आप अनुसरण कर सकते हैं कि मुझे किस लेआउट मैनेजर का पालन करना चाहिए।
मैंने इसे यहां ग्रिड लेआउट के रूप में वास्तव में उपयोग किया है क्योंकि यह ग्रिड के रूप में है यदि यह ग्रिड लेआउट है तो ग्रिड 4 क्रॉस 4 का आकार क्या है और यहां आप देखते हैं।
इसलिए, 16 में से जो ग्रिड घटक पहले 1 2 3 4 से 15 हैं, ये मूल रूप से 15 घटक हैं और फिर अंतिम मूल रूप से वह बटन नहीं है जिसे मूल रूप से टेक्स्ट फ़ील्ड कहा जाता है।
इसलिए मूल रूप से, हम एक ऐसी विंडो बनाना चाहते हैं जिसमें एक दो तीन 15 के रूप में लेबल वाले 15 बटन शामिल हों और एक यह एक है।
अब यहां हम कुछ ईवेंट हैंडलिंग को जोड़ना चाहते हैं।
कार्यक्रम क्या है?
अगर मैं माउस को यहाँ क्लिक करता हूँ तो जो भी माउस क्लिक किया जाता है वह अपने आप यहाँ प्रदर्शित होगा।
इसलिए, अगर हम इसे यहां क्लिक करते हैं, अगर हम शुरू में नहीं करते हैं तो यह एक स्टार माउस के साथ प्रदर्शित होगा-जैसे कुछ भी नहीं क्लिक किया जाता है।
तो, यहाँ मूल रूप से एप्लेट का एक प्रारंभिक दृश्य होगा यह स्टार है और अब यदि उपयोगकर्ता यहां क्लिक करता है तो स्वचालित रूप से यह 6 प्रदर्शित करेगा या यदि हम उपयोगकर्ता यहां क्लिक करते हैं तो यह 8 को प्रदर्शित करेगा।
तो, यह सिर्फ एक सरल अन्य इंटरैक्टिव विंडो है जैसे उपयोगकर्ता इंटरफ़ेस के साथ बातचीत कर सकता है और फिर प्रभाव उपयोगकर्ता के अनुसार प्राप्त किया जाएगा।
अब तो, यह ईवेंट हैंडलिंग है;
मैं सिर्फ यह चाहता हूं कि वास्तव में अभी यहां कोड हो और फिर घटना से निपटने के बारे में अधिक विस्तृत चर्चा की जरूरत है।
अब यहाँ इस तरह की प्रोग्रामिंग के लिए कोड है, मुझे आशा है कि आप बिल्कुल समझ गए होंगे कि हम क्या करने जा रहे हैं।
अब, यहाँ कोड बहुत सुंदर है क्योंकि आप देखते हैं कि कोड बहुत सरल है और सबसे पहले यह है कि n 4 है;
इसका मतलब है, हम चार पार चार लेआउट बनाने के लिए है यह इस तरह है।
तो, कि setLayout द्वारा किया जाता है GridLayout n क्रॉस n यह है;
जाहिर है, स्पष्ट है कि हम अपने लेआउट के लिए प्रबंधक के रूप में ग्रिडलाइउट का उपयोग करना चाहते हैं और फिर यहां वास्तव में सेटफॉन्ट करते हैं, हम फ़ॉन्ट को हेल्वेटिका बोल्ड फ़ॉन्ट 24 के रूप में बनाते हैं;
इसका मतलब है, इस मामले में हमारे द्वारा पहले ही प्रदर्शित किए जाने वाले सभी फोंट वास्तव में यहां हैं।
तो, ये वो फोंट हैं जिनकी हमने यहां चर्चा की है।
तो, यह इन फ़ॉन्ट है जिस पर हमने चर्चा की है वह वास्तव में वैसे भी हेल्वेटिका फ़ॉन्ट है।
तो, यह ऐसा है कि हमने यहां चर्चा की है सेटफोंट और फिर हमें वहां विभिन्न बटन की व्यवस्था करनी होगी।
अब यहाँ अलग बटन है जिसे यहाँ व्यवस्थित किया जा सकता है, मैंने सिर्फ एक लूप बनाया है कि यह एक है और स्वचालित रूप से यह एक मुश्किल लूप है जिसे आप बस अपने आप को फॉलो कर सकते हैं और आप समझ सकते हैं कि लेबल 1 के साथ अलग बटन कैसे बनाया जा सकता है 15 और उन सभी बटन को इस 1 2 3 4 5 में रखा जा सकता है तब 1 2 3 फिर 6 इस तरह से केवल बटन को वहां रखा जाएगा।
और फिर ग्रिडलाइयूट में अगला स्थान एक लेबल द्वारा रखा जाएगा, और उस लेबल में यह लेबल केंद्र है और डिफ़ॉल्ट रूप को मूल रूप से स्टार कहा जाता है।
तो, यह मूल रूप से एक लेबल घटक है जो वहां बनाया गया है।
तो, यह एक लेबल है और फिर ये लेबल भी हैं फ़ॉन्ट सेट करें कई बार नए रोमन फ़ॉन्ट इटैलिक का अर्थ है कि लेबल जो एक अलग फ़ॉन्ट में दिखाई देगा यह इस तरह दिखता है लेबल जोड़ें;
इसलिए वहां लेबल जोड़ा जाता है।
फिर अगली घटना को संभाला जाना है क्योंकि यह केवल विंडोज़ बनाई गई है या हम कह सकते हैं कि एप्लेट बनाया गया है, लेकिन यहां कोई ईवेंट नहीं जोड़ा गया है।
इसलिए, हमारा अगला भाग वहां है कि कैसे घटना को इसमें जोड़ा जा सकता है।
तो, यहाँ यह घटना है।
इसलिए, हमने जिस घटना की योजना बनाई है, वह क्रिया है, क्रिया मूल रूप से फिर से एक अमूर्त विधि है, जिसे घटना वर्ग में परिभाषित किया गया है और जो java.awt पैकेज में है, वहाँ हमने इसे अधिलेखित कर दिया है।
अब ईवेंट ई;
इसका मतलब है, जो भी कुंजी रखी गई है वह मूल रूप से ई ई है या माउस क्लिक यह ईवेंट ई है और फिर इसका परिणाम लिखा गया है;
इसका मतलब है, अगर हम एक बटन पर क्लिक करते हैं 5 कहते हैं, तो ऑब्जेक्ट ऑग मूल रूप से है कि यह बटन 5 है जिसे क्लिक किया गया है।
तो, यह मूल रूप से विधि है कि यह मूल रूप से इसे वापस कर देगा और यदि बटन के e.target उदाहरण;
इसका मतलब है, यदि हम एक बटन बनाते हैं तो यहां लेबल। setText स्ट्रिंग ऑब्जेक्ट मूल रूप से ऑब्जेक्ट का अर्थ है कि यह कौन सा बटन है, यह पहले से ही यहां एक ऑब्जेक्ट परिभाषित है और फिर ऑब्जेक्ट मूल रूप से एक स्ट्रिंग है और फिर उस स्ट्रिंग को वहां प्रदर्शित किया जाएगा और यह बहुत ही है बहुत सरल एक्शन विधि जो यहाँ पर लिखी गई है और वह सब है।
और एक बार जब यह आपके वास्तव में हो जाता है कि यह कार्यक्रम आपके काम करने के लिए तैयार है।
इसलिए, वह प्रोग्राम आउटपुट जैसा कि हमने पहले ही दिखाया है कि वह इसे देगा।
आप अपना खुद का परीक्षण कर सकते हैं ताकि आप इसके बारे में अधिक मज़ेदार हो सकें और संख्या के बजाय आप कह सकते हैं कि बी सी भी आप इसे जांच सकते हैं, एक आप बटन में भी डाल सकते हैं इन चीजों को प्राप्त करें और इसे जांचें;
तो इस अवधारणा के साथ आप जो भी कर सकते हैं उसे प्रयोग कहा जाता है।
तो, यह लेआउट मैनेजर के बारे में एक महत्वपूर्ण अवधारणा है और फिर वहां एक ग्राफिक्स भी है।
इसलिए, जैसा कि मैंने आपको बताया घटक वर्ग के मामले में कई अन्य हैं
चीजें या अन्य AWT पैकेज जो ग्राफिक्स के लिए ग्राफिक्स के लिए एक आवश्यक घटक है।
यदि आप एक एप्लीकेशन सॉफ्टवेयर लुक विकसित करना चाहते हैं जैसे कि पेंटब्रश कहते हैं तो निश्चित रूप से ग्राफिक्स पर विचार किया जाना चाहिए।
और ग्राफिक्स के कई तरीके हैं, वहां घोषित किया गया है, ग्राफिक्स वहां एक बहुत ही महत्वपूर्ण वर्ग है और इसमें कई विधियां हैं, ये सभी तरीके मूल रूप से अन्य ग्राफिक्स ऑब्जेक्ट को आकर्षित करने के तरीके हैं।
उदाहरण के लिए कि आप एक आयत कैसे बना सकते हैं, आप एक दीर्घवृत्त कैसे आकर्षित कर सकते हैं कि आप बहुभुज कैसे आकर्षित कर सकते हैं और आप विभिन्न की पृष्ठभूमि कैसे बना सकते हैं, विभिन्न शैलियों को कैसे देखा जा सकता है कि क्या बिंदीदार या अलग शैली तय की जा सकती है और कई अन्य चीजें हैं हो सकता है।
इसके अलावा, इसे ज़ूम करने की स्थिति के लिए कई अन्य तरीके हैं। कई चीजें हैं जो मैंने सूचीबद्ध की हैं, जिनमें कुछ ग्राफिक्स वर्ग घोषित किए गए हैं, यह मूल रूप से उन तरीकों की एक बड़ी संख्या है जो सभी तरीके मूल रूप से ग्राफिक्स से संबंधित मुद्दों को संभालने के लिए हैं।
अब, यदि आपके पास समझने के तरीके और सब कुछ हैं और फिर अगर मैं आपसे आपके पक्षों का समाधान करने के लिए कहूं।
उदाहरण के लिए यहां;
मान लीजिए हम इस तरह की चीज़ बनाना चाहते हैं तो यह इस तरह के पाठ को प्रदर्शित करेगा और साथ ही यह इस तरह का आंकड़ा खींचेगा।
तो, इस आकृति में, जैसा कि आप इस आंकड़े को एक आयत के रूप में देखते हैं कि एक और आयत खींची जाएगी, इस आयत के भीतर अन्य छोटी आयत की खिड़कियाँ।
और ये सभी चीजें हैं, अंडाकार दीर्घवृत्त होगा वहां आयत होगी यहां एक बहुभुज खींचा जाएगा, दूसरी रेखा खींची जाएगी, रेखा की मोटाई अलग है, अलग रंग और दूसरी रेखा भी होगी।
इसलिए, मूल रूप से, यदि आपके पास ग्राफिक्स विधियां हैं और फिर इस पद्धति का उपयोग करने वाले विभिन्न तरीके हैं, तो मैं इन सभी चीजों को आकर्षित कर सकता हूं, और केवल यह है कि समन्वय को निर्दिष्ट करने की आवश्यकता है।
उदाहरण के लिए, मान लीजिए कि इस दीर्घवृत्त को मैं यहां खींचना चाहता हूं।
तो, दीर्घवृत्त मूल रूप से यह केंद्र का समन्वय है और हमें इनका उल्लेख करना होगा कि प्रमुख अक्ष और लघु अक्ष हैं।
तो, केंद्र, प्रमुख अक्ष, लघु अक्ष और फिर पृष्ठभूमि रंग और फिर ये अलग लाइन रंग हैं और शैली भी वे दीर्घवृत्त ड्राइंग के लिए कई निर्माता हैं;
आप बस इसका उपयोग करें और फिर इसे दबाएं।
इसी तरह आयत के लिए भी यह स्थिति चौड़ाई और ऊंचाई है यदि आप स्थिति और फिर पृष्ठभूमि रेखा का रंग और सब कुछ यह स्वचालित रूप से आकर्षित करेगा।
तो, इस तरह से अलग-अलग घटक को रखा जा सकता है और खींचा जा सकता है और एक तस्वीर इस तरह दिखती है जैसे हम आपको दिखाई देंगे।
मैं इसे आपके लिए एक अभ्यास के रूप में छोड़ दूंगा;
मुझे लगता है कि यह अपना है और आप इसका भरपूर आनंद ले सकते हैं।
मुझे यकीन है कि इसके साथ आप भरपूर आनंद ले पाएंगे।
और वास्तव में AWT कार्यक्रम बहुत सारे रोचक तथ्य हैं, हमने अभी बुनियादी चीजों के बारे में शुरुआत की है और फिर अपने अगले मॉड्यूल में हम इवेंट हैंडलिंग के बारे में चर्चा करेंगे ताकि AWT का संबंध हो जो कि और भी महत्वपूर्ण है। उसके लिए अपना कौशल विकसित करें।
और फिर यह सब AWT भी स्विंग का उपयोग करके अधिक उन्नत तरीके से नीचे हो सकता है।
इसलिए, हमारी पाइपलाइन की उन सभी चीजों पर हम पहले इवेंट हैंडलिंग पर चर्चा करेंगे, फिर हम अपने अगले लेक्चर स्लाइड्स में स्विंग कॉन्सेप्ट के बारे में चर्चा करेंगे।
बहुत बहुत धन्यवाद, आपका ध्यान के लिए धन्यवाद।
जावा प्रोफ़ेसर डेबासिस सामंत डिपार्टमेंट ऑफ़ कंप्यूटर साइंस एंड इंजीनियरिंग इंडियन इंस्टीट्यूट ऑफ़ टेक्नोलॉजी, खड़गपुर लेक्चर - 47 डेमोंस्ट्रेशन - XVIII में प्रोग्रामिंग, यह जावा में जावा स्विंग पैकेज से संबंधित हमारे प्रदर्शन का एक निरंतरता है।
ये प्रदर्शन का दूसरा हिस्सा हैं।
इस प्रदर्शन में, हम कुछ और घटकों को शामिल करने जा रहे हैं जैसे कॉम्बो बॉक्स, फिर जक्शनपैन, फिर जेकोलॉकर, जेट्री, जेटबेडपेन और बहुत सी अन्य चीजें।
तो, हमें पहले डेमो दें।
और यह ComboBox है।
कॉम्बोबॉक्स वास्तव में चेकबॉक्स समूह से बहुत मिलता-जुलता है, कि हमने उनके बारे में चर्चा की है।
और यहाँ एक कॉम्बो बॉक्स को कैसे परिभाषित किया जा सकता है यह उदाहरण हमें स्पष्ट करेगा।
तो, यहाँ ठीक है, इसलिए पहले हम एक फ़्रेम बनाते हैं, क्योंकि कॉम्बो बॉक्स को समाहित करने के लिए एक फ़्रेम होना चाहिए।
तो, फ़्रेम बनाया गया है।
और यह वर्ग स्वयं प्रोग्राम है ComboBox उदाहरण, इस रचनाकार के अंदर एक कंस्ट्रक्टर बेस कार्यान्वयन है।
फिर हम एक फ़्रेम बनाते हैं, फ़्रेम नाम का फ़्रेम नाम ऑब्जेक्ट f है।
और फ़्रेम फ़्रेम शीर्षक के साथ दिखाई देगा कॉम्बो बॉक्स उदाहरण।
और फिर, हम भारत, ऑस्ट्रेलिया, संयुक्त राज्य अमेरिका, इंग्लैंड और सब कुछ की तरह एक सरणी को परिभाषित करते हैं।
तो, मूल रूप से हमारे कॉम्बो बॉक्स में ये शामिल होंगे कि इसमें यह आइटम हैं।
और फिर हम इस आइटम में एक आइटम के रूप में इस सूची को पास करते हुए एक कॉम्बो बॉक्स बनाते हैं।
तो, यह एक तरीका है जो हम कर सकते हैं।
अन्यथा, अलग से भी आइटम जोड़ें, हम इसका उपयोग कर सकते हैं, और फिर कॉम्बो बॉक्स में भी जोड़ सकते हैं।
वैसे भी, तो अगर अंत में हम इस कॉम्बो बॉक्स के लिए सेटिंग्स बना सकते हैं इसके स्थान के बारे में, जहां इसे फ्लोट किया जाना चाहिए, और फिर आकार का मतलब है कि चौड़ाई और ऊंचाई और सब कुछ।
और अंत में, हम इस ComboBox को फ़्रेम में जोड़ते हैं।
और फिर लेआउट आकार और फ्रेम बॉक्स की दृश्यता हमारी आवश्यकता के अनुसार निर्धारित की गई है।
और अंत में, हम केवल कॉम्बो बॉक्स के ठेकेदार द्वारा इस ऑब्जेक्ट उदाहरण को कॉल करते हैं
उदाहरण के ठेकेदार।
तो, यह वह तरीका है जिससे यहां कॉम्बो बॉक्स बनाया जा सकता है।
यहां हमने इस कार्यक्रम को निष्पादित किया है, और हम देख सकते हैं कि यह कॉम्बो बॉक्स अब पहले से ही दिखाई दे रहा है।
पहला आइटम जो आइटम सूची में है, वास्तव में यहां प्रदर्शित किया जाएगा।
और फिर अगर हम स्क्रॉल पट्टी पर क्लिक करते हैं, तो दाईं ओर, फिर वहां मौजूद सभी आइटम यहां जोड़े जाएंगे, और तदनुसार सूची यहां दी जाएगी।
अब, यहाँ वास्तव में इसलिए इस उदाहरण के अनुसार कॉम्बो बॉक्स का आकार पाइप है।
इसलिए, आपको इसकी चर्चा करने की आवश्यकता नहीं है।
आप आसानी से ComboBox की तुलना कर सकते हैं जिसकी हमने चर्चा की है, जबकि आप awt का उपयोग कर रहे हैं।
वे भी एक तरह से हैं।
एक ही तंत्र, यह भी यहाँ पालन किया जा सकता है, लेकिन जैसा कि यह है कि हमने एक अलग उदाहरण का उपयोग किया है, ताकि यह अलग-अलग तरीके दे सके, अलग-अलग एहसान जो कॉम्बो बॉक्स डिज़ाइन किए जा सकते हैं, और आपके विंडो प्रोग्राम में उपयोग किए जा सकते हैं ।
तो, यह ComboBox है।
और एक और बात यह है कि एक तालिका, हम तालिका का उपयोग करके आप कैसे एक तालिका बना सकते हैं।
एक तालिका मूल रूप से कुछ पंक्तियों का संग्रह है, पंक्तियाँ डेटा को समाहित करती हैं, और स्तंभों का एक सेट होता है, उन स्तंभों को मूल रूप से गुण कहते हैं।
इसलिए, हम उस तालिका को परिभाषित करने जा रहे हैं जिसमें तीन विशेषताएँ हैं।
तीन विशेषताएँ आईडी हैं तीन विशेषताएं आईडी, नाम और उसके बाद वेतन हैं।
जैसा कि आप देखते हैं कि स्ट्रिंग कॉलम एक सरणी है, जिसमें आईडी, नाम और वेतन अधिकार के लिए कॉलम शीर्षक शामिल है।
तो, ये ऐसे तरीके हैं जो हम कर सकते हैं।
अब, यहाँ तालिका वास्तव में एक दो आयामी सारणी है, ताकि इस सरणी को आउटपुट स्ट्रीम से या तो पढ़ा जा सके या यहाँ जो हमने इस तालिका को प्रपत्र में संग्रहीत किया है
2 डी सरणियों के वास्तव में।
इस चित्रण के लिए, हालांकि अलग-अलग तरीकों से भी, इसे दूसरे स्रोत से पढ़ा जा सकता है, जिस तरह से यह हो सकता है।
वैसे भी, इस तालिका में तीन पंक्तियाँ हैं जैसा कि हम यहाँ देखते हैं।
पहली पंक्ति में 101 में आईडी है, नाम अमित है, और वेतन यह एक है।
इसी तरह, १०२ और फिर १०१, और ये सभी चीजें हैं।
तो, यह मूल रूप से तालिका की संरचना को पूरा करता है, जिसमें तालिका में डेटा भी शामिल है।
और फिर आखिर में, हमें jt बनाना होगा।
और फिर jt मूल रूप से वह वस्तु है जिसे हमने टाइप JTable से बनाया है।
और फिर जो तर्क हमने डेटा की घोषणा की है, डेटा मूल रूप से कुल रिकॉर्ड शामिल है जो मूल रूप से सभी पंक्तियों में होना चाहिए, और फिर स्तंभ मूल रूप से स्तंभ शीर्षक है।
और फिर अंत में, सीमा निर्धारित करें कि घोड़े का आकार उस तालिका का आकार होगा जो इसे होना चाहिए, और फिर JScrollPane को वास्तव में हमें एक स्क्रॉलपैन शामिल करना होगा, ताकि यह मूल रूप से तालिका के लिए स्क्रॉल करना संभव हो।
और फिर, हम इन सभी स्क्रॉल फलक के साथ-साथ इस फ़्रेम में तालिका जोड़ते हैं, और यह फ़्रेम का निर्माण पूरा करता है।
अब, देखते हैं कि इस फ़्रेम का आउटपुट कैसा दिखेगा।
जैसा कि आप यहाँ देखते हैं, हाँ, तो ये मूल रूप से तालिका के आकार के अनुसार, तालिका की तरह दिखेंगे, और इसमें कॉलम के साथ-साथ सभी पंक्तियाँ भी होंगी।
सभी पंक्तियाँ उन सभी डेटा के अनुरूप हैं, जिन्हें हम पहले ही इस उदाहरण में देख चुके हैं।
इसलिए, फिर से हम कुछ और तालिका प्रविष्टियाँ जोड़ सकते हैं, जिनका अर्थ है कि पंक्तियाँ और सब कुछ बस जोड़ना है।
वास्तव में कोई समस्या नहीं जोड़ना, यह मूल रूप से आकार की कोई सीमा नहीं है जिसे आप उस तालिका तक सीमित कर सकते हैं।
और एक बार जब यह तालिका होती है, तो इसे JTable में पहले से ही चर्चा की गई विभिन्न विधियों द्वारा संसाधित किया जा सकता है।
इन सभी पद्धति का उपयोग तालिका के अंदर विभिन्न तत्वों तक पहुंचने के लिए किया जा सकता है, कितनी पंक्तियां हैं, तत्वों की संख्या क्या है, ये सभी चीजें हैं।
यहां तक ​​कि खोज को मुख्य विभिन्न तरीकों के साथ भी लिया जा सकता है जो वहां घोषित है।
अब, यह तालिका उदाहरण बहुत सरल है।
तो, प्रोग्रामिंग के लिए चिंतित है, बिल्कुल वैसा नहीं है जैसा कि आप यहाँ देखते हैं।
विषय वास्तव में सूची वस्तु।
तो, यहाँ एक और तरीका है।
इसलिए, आप आइटम को एक-एक करके स्वतंत्र रूप से जोड़ सकते हैं, और फिर इसे केवल सूची में पॉप्युलेट किया जा सकता है।
तो, यह दूसरा संस्करण है, विभिन्न मदों को एक सूची में संग्रहीत करने का दूसरा तरीका।
जैसा कि हम यहां देखते हैं कि हम पहले एक फ़्रेम बनाते हैं, क्योंकि फ़्रेम में यह सूची शामिल होनी चाहिए।
और फिर हमने यहां भी लिस्ट बनाई है।
यहाँ सूची को डिफ़ॉल्ट सूची मॉडल की तरह बनाया गया है जिसे हमने उस ओके के बारे में एक विचार बनाया है, यह वास्तव में सूची का एक स्ट्रिंग है l1।
फिर l1 डॉट एलिमेंट एलिमेंट, इसमें शामिल है कि हम इस सूची में एक आइटम जोड़ रहे हैं।
इसलिए, आइटम 1, आइटम 2, आइटम 3, और आइटम 4, हमने सूची में चार अलग-अलग आइटम जोड़े हैं।
और फिर अंत में, हम इस सूची का उद्देश्य बनाते हैं, इस का नाम केवल सूची कहा जाता है।
और फिर हम इस ऑब्जेक्ट को इस तर्क के रूप में पास करते हैं कि इसका अर्थ है, इसमें वे सभी आइटम शामिल होंगे जो हमने इसमें जोड़े हैं।
और अंत में, ये सामान्य विवरण होते हैं, जैसे सेट सीमा, फिर सेट करें f f सूची जोड़ें, फ़्रेम में सूची जोड़ना, और आकार सेटिंग, लेआउट सेटिंग, और फिर दृश्यता सेटिंग यह सब है।
और फिर अंत में, हम इस प्रकार के प्रोग्राम का ऑब्जेक्ट विंडो के रूप में बनाते हैं, और फिर हम इसे एक बनाते हैं।
तो, यह सूची का एक उदाहरण है, यह वहां है।
अब, जैसा कि हमने हाइलाइट किया है, हम रखने के माध्यम से चयन कर सकते हैं।
यदि हम माउस को रखते हैं, तो वहां हाइलाइटिंग होगी।
और यहाँ यह है कि केवल एक माउस हो सकता है, माउस भी खत्म हो सकता है, और फिर कई मल्टीपल लिस्ट आइटम भी इस तरह चुने जा सकते हैं।
और वह चयन किसी भी जगह हो सकता है, क्योंकि यह एक नियंत्रण बटन के रूप में जाना जाता है, और माउस को नियंत्रित करने के अलावा।
आधार पिछले चयन का फ़ोकस समान रहेगा, और अगला भी फ़ोकस को बदला जा सकता है, दोनों फ़ोकस को मर्ज किया जा सकता है, और फिर बड़ा फ़ोकस बनाया जा सकता है।
इस तरह की सभी चीजें जो यहां की जा सकती हैं।
अब, इसलिए यह सूची का उदाहरण है।
अब, अगला उदाहरण है कि हमारे पास OptionPane की अवधारणा को चित्रित करने की योजना है।
और OptionPane मूल रूप से फ़्रेम की तरह दिखता है, आइए हम OptionPane विंडो का एक त्वरित रूप देखते हैं कि यह ठीक हो सकता है।
ऑप्शनपैन मूल रूप से निर्धारित आकार है, इसे आकार नहीं दिया जा सकता है या इसे यहां नहीं बदला जा सकता है केवल इसे पार करने के लिए एक क्रॉस बटन का उपयोग किया जा सकता है या इसे इस तरह से चुनने के लिए बटन दबाया जा सकता है।
और जैसा कि हम यहाँ देखते हैं OptionPane हेलो जैसे संदेश के साथ बनाया गया है, जैसे IIT खड़गपुर में आपका स्वागत है।
तो, यह OptionPane का विचार है।
जैसा कि आप जानते हैं कि OptionPane आमतौर पर कभी-कभी हमारे किसी भी प्रोग्राम में दिखाई देता है, जब भी आप किसी फाइल के कुछ डेवलपमेंट को डाउनलोड करने की प्रगति के बारे में माउस या सब कुछ का उपयोग करते हुए देखते हैं या यदि कोई त्रुटि होती है तो मूल रूप से त्रुटि संदेश है या इसे मूल रूप से उस पर संवाद संदेश कहा जाता है।
वैसे भी, तो यह एक उदाहरण है कि इस तरह के एक विकल्पपैन कैसे बनाया जा सकता है।
इस चीजों के लिए, हमें OptionPane JoptionPane के वर्ग कॉल का उपयोग करना होगा, और फिर इस चीज़ के लिए एक ऑब्जेक्ट बनाया जा सकता है।
और शो संदेश संवाद का उपयोग करते हुए, और आप कौन सा संवाद इस में जोड़ना चाहते हैं कि आप इसे शामिल कर सकते हैं।
और फिर अंत में, एक और तर्क जिसमें फ्रेम है, और अंत में यह ऑब्जेक्ट बनाया जाएगा, और इसे अंतिम कार्यक्रम में जोड़ा जा सकता है।
तो, यह प्रोग्राम कोड है बहुत सरल कुछ पंक्तियाँ हैं, और उस तरह का कोड किसी भी OptionPane की तरह प्रदर्शित करने के लिए पर्याप्त है। ।
और यदि किसी विशेष मेनू का चयन किया जाता है, तो यह मेनू यहां चुना जा सकता है।
तो, मेनूबार और मेनू आइटम का एक विशिष्ट रूप जैसा कि हम इस एप्लेट में देखते हैं, यहां केवल एक मेनू है।
तो, अब हम कोड देखते हैं, जैसा कि आप यहाँ कोड देखते हैं।
तो, जेनमेनू, और सबमेनस दो मेनू हैं।
यदि हम मेनू का चयन करते हैं, तो मेनू का चयन किया जाएगा, और फिर सबमेनू होगा।
और JMenuItem, वहाँ आइटम हैं I 1 से i 5 आइटम वहाँ पहचाने गए हैं।
और फिर इस उदाहरण में मेनू उदाहरण जैसा कि हम देखते हैं कि हम एक MenuBar ऑब्जेक्ट और mb बनाते हैं और फिर मेनू नया JMenu, मेनू बनाया जाता है।
और फिर सबमेनू भी एक अन्य ऑब्जेक्ट बनाया जाता है जैसे कि जेनमेनू फिर से जेनमू ऑब्जेक्ट है, लेकिन अलग-अलग स्तर का सबमेनू होना।
और फिर हम आइटम को एक i 1, i 2, i 3 जोड़ते हैं
इस मेनू आइटम में मूल रूप से वहाँ निर्मित बुला रहा है।
इसलिए, हम बनाते हैं और फिर अंत में हम इस मेनू आइटम को इस मेनू में ही जोड़ते हैं।
तो, यह एक मेनू का निर्माण पूरा करता है, जिसमें 1, 2, 3, 4 जैसे सबमेनू आइटम शामिल हैं।
और फिर यह भी मूल रूप से मेनू आइटम बनाता है, जिसका आउटपुट पहले से ही हमने अनुभव किया है, यह इस तरह दिखेगा।
और फिर अगर मैं आपसे एक और मेनू जोड़ने के लिए कहता हूं, तो वही प्रक्रिया जिसे आप कॉपी पेस्ट दोहरा सकते हैं और फिर बस मान बदल सकते हैं, और मेनू आइटम बार और सब कुछ।
तो, एक और मेनू अगर यह वहां है, तो यह यहां दिखाई देगा।
इसलिए, कई मेनू जोड़े जा सकते हैं, और फिर उन्हें साइडबार या मेनूबार में रखा जा सकता है।
तो, यह मूल रूप से मेनूबार है।
और फिर इसके लिए MenuBar में कई अन्य मेनू भी शामिल हैं।
जैसा कि आपने किसी अन्य विंडोज़ एप्लिकेशन जैसे शब्द या पावर में देखा है, इस तरह के कई मेनू इंगित करते हैं, और जैसा कि हम यहां भी देखते हैं।
कई मेनू मेनूबार में शामिल किए जा सकते हैं, और फिर प्रत्येक मेनू में मेनू आइटम को जोड़ा जा सकता है।
और फिर किसी विशेष मेनू से प्रत्येक मेनू आइटम को इन सभी चीजों को क्लिक करके चुना जा सकता है।
तो, यह भी MenuBar की तरह एक और उदाहरण है।
तो, यह एक उदाहरण है, इसलिए यह सब है।
और अगले हमारे दृष्टांत से हमें पॉपअप मेनू मिलेगा।
नाम पॉपअप मेनू के रूप में, यह भी केवल मेनू आइटम के समान है।
लेकिन, एक पॉपअप मेनू है, यह दिखाता है कि ठीक है, आइए हम इसका त्वरित उत्पादन करते हैं कि यह पहले पॉपअप मेनू की तरह कैसे दिखता है।
जैसा कि हम पॉपअप मेनू देखते हैं, यह मूल रूप से ठीक है।
और जब भी हम इसे क्लिक करते हैं, तो पॉप अप मेनू दिखाई देगा।
और इसमें कुछ आइटम के साथ पॉपअप मेनू दिखाई देगा, इसलिए यह पॉपअप मेनू का विचार है।
इसलिए, यह तब तक नहीं होगा जब तक आप इसे क्लिक नहीं करते हैं, इसलिए इसे पॉपअप कहा जाता है, जब भी कुछ घटनाओं पर क्लिक होता है।
तो, पॉप अप मेनू वहाँ दिखाई देगा।
इसलिए, यह उदाहरण की तुलना में कुछ अलग है, जिसे आपने awt के बारे में माना है वह केवल इस चीज के लिए विशिष्ट है।
और यहां हम देख सकते हैं, हम पहले एक फ़्रेम बनाते हैं।
तो, फ़्रेम में यह पॉपअप मेनू शामिल होगा, और नाम अंतिम जे पॉपअप मेनू है, अंतिम यह पॉपअप मेनू वास्तव में है हां, हम इसे बनाते हैं।
और फिर इस पॉप अप मेनू का नाम वास्तव में संपादित है।
इस संपादन मेनू के लिए, आइटम हैं जो हमने यहां कट, कॉपी और पेस्ट की तरह जोड़े हैं।
और फिर अंत में, हम इस पॉप अप मेनू में इन सभी आइटम जेमेनू आइटम को काट, कॉपी, पेस्ट के रूप में जोड़ते हैं, जिसे हमने पॉप अप मेनू आइटम में जोड़कर बनाया है।
और अंत में, हम सिर्फ माउस श्रोता को पंजीकृत करते हैं, क्योंकि यदि हम माउस को क्लिक करते हैं, तो केवल यह एक है।
तो, यहाँ भी इस मामले में पंजीकृत होने की जरूरत है, और यह रजिस्टर मूल रूप से
परिभाषित पॉपअप मेनू डॉट शो विधि यह वहां है, और फिर ई मूल रूप से उस घटना को लेते हैं जो तब हो सकती है।
और अंत में, इस पॉपअप मेनू आइटम को फ़्रेम में जोड़ा जाता है।
और यह आपके एप्लिकेशन प्रोग्राम में एक पॉपअप मेनू जोड़ने को पूरा करता है।
तो, यह एक उदाहरण है जो मूल रूप से है।
हमारा अगला उदाहरण है कि हम पॉपअप मेनू के समान के बारे में चर्चा करने जा रहे हैं, लेकिन इसे मेनू में चेक बॉक्स मेनू आइटम कहा जाता है।
तो, यह एक मेनू आइटम है, लेकिन चेकबॉक्स के साथ, ताकि अंतर और ठीक हो।
पहले ठीक से देखें कि यह कैसा दिखता है वास्तव में इस उदाहरण में चेकबॉक्स मेनू आइटम पर एकल के साथ, जैसा कि हम यहां देखते हैं।
इसलिए, यदि आप मेनू मेनू में देखते हैं, तो मेनूबार में प्रदर्शित होता है, और यदि यह मेनू आइटम शामिल है और पॉपअप जैसा दिखता है यदि आप इसे क्लिक करते हैं, तो वह मेनू आइटम दिखाई देगा।
और फिर इसके दो मान हैं जैसे खुला, और फिर दो ठीक मान।
तो, यह दो आइटम है यह वहाँ है, और विकल्प एक है, यह क्या है?
खुला और मान दो।
खुला और मान दो।
और मान दो चेकबॉक्स के साथ है, जहां ओपन ठीक है।
तो, मान दो चेकबॉक्स है।
तो, यह विचार है कि चेकबॉक्स को मेनू आइटम में जोड़ा जा सकता है।
अब, यह उद्धरण थोड़ा ठीक हो सकता है, हम यहां से गुजर सकते हैं और समझ सकते हैं।
तो, यहां उस घटना को संभालने की जरूरत है, क्योंकि यह इस घटना से जुड़ी हुई घटना है।
तो, घटना के बिना, यह वास्तव में उस तरह का स्वाद नहीं देगा।
और जैसा कि हम देखते हैं कि कार्यक्रम में फिर से फ़्रेम शामिल है, और फिर फ़्रेम में कुछ डिफ़ॉल्ट बंद ऑपरेशन विधि शामिल है, जिन्हें स्वयं फ़्रेम क्लास के रूप में परिभाषित किया गया है।
इसलिए, इस फ़्रेम क्लास के लिए, हमने इसे बुलाया।
और यही वह चीज है जो जरूरी है।
और यह मूल रूप से करीबी साधनों पर बाहर निकलने के रूप में सेट है, अगर हम सिर्फ मेरा मतलब है कि हमारे माउस क्लिक को हटा दें, और वहां यह मूल रूप से स्वचालित रूप से बंद हो जाएगा, इसलिए आपको यह करना होगा।
अन्यथा, एक बार जब आप इसे खोलते हैं, तो यह बना रहेगा, इसलिए हमें करीब से बाहर निकलना होगा।
और फिर हम JMenuBar बनाते हैं जो हमने पहले ही चर्चा की है कि MenuBar क्लास में MenuBar कैसे बनाया जा सकता है।
तो, JMenuBar वर्ग, यह वहाँ है।
और हम Jenenu ऑब्जेक्ट बनाते हैं, इसलिए एक JMenu ऑब्जेक्ट्स है, इस का नाम फ़ाइल है, और फिर सेट Mnemonic कुंजी ईवेंट VK है, जिसका अर्थ है कि यदि घटना वास्तव में फ़ंक्शन से संबंधित है, तो यह जगह लेगा।
तो, यह एक परिभाषा है, हमने इसे यहां उपयोग किया है।
और फिर मेनू आइटम, हमने खुले की तरह जोड़ा है, और फिर एक और मेनू आइटम जो हमने दिखाई है, वह मूल रूप से ठीक है।
इसलिए, हां इतना मेनू आइटम जो हमने यहां ओपन वन, मेन्यू आइटम एक के रूप में बनाया है, जो मूल रूप से एक तर्क के रूप में प्रमुख घटना वर्चुअल नंबर किसी भी नंबर के साथ है।
और फिर हम इस मेनू आइटम को जोड़ते हैं, और फिर JCheckBox मेनू आइटम, केस मेनू आइटम, इस तरह के नए चेकबॉक्स मेनू आइटम, और ठीक है, इसलिए ये कुछ बहुत सारे हैं।
और अब यहाँ मूल रूप से एक्शन एल रूटीन में है जैसा कि हम यहाँ देखते हैं, अलग एक्शन जो यहाँ सार बटन को हैंडल कर सकता है।
हम एक अमूर्त बटन प्रकार बना सकते हैं यहाँ एक बटन एक अमूर्त बटन है, अमूर्त बटन एक स्रोत के रूप में एक घटना के साथ बनाया जाता है।
और फिर बटन को मॉडल मिलता है, और यदि इसे चुना जाता है, तो यह सच है, फिर इसे वहां प्रदर्शित किया जाएगा।
और फिर कुछ स्तर हैं, हमने इस स्ट्रिंग का उपयोग किया है, और वे आइकन छवि भी हैं, हम यहां बना सकते हैं।
और फिर चयनित सही या गलत के आधार पर मूल्य 1 और मान 2।
इसे चुना जाएगा, और फिर यह अवधि में इस बटन को जोड़ देगा, और फिर अंत में यह अभी पूरा हो जाएगा।
तो, अब हम फिर से डेमो कर सकते हैं।
तो, यह एक उदाहरण है जो मेनू में आइटम चेकबॉक्स मेनू आइटम से संबंधित है।
यह इसे रोक देगा, जहां भी गणना है, और फिर इसे बंद करें।
अब, हम प्रोग्राम में आते हैं जो मूल रूप से इस तरह के आउटपुट डेमो देने के लिए विशेष रूप से यहां उपयोग किया जा सकता है।
और हम पहली बार JProgressBar की एक वस्तु बनाते हैं, यहाँ jb है।
और पूर्णांक I 0 के बराबर 0 से बराबर बराबर 0 मूल रूप से दो नंबरों को इनिशियलाइज़ करता है।
और फिर हम इस उदाहरण का एक निर्माता बनाते हैं, इसलिए प्रगति बार उदाहरण।
अब, एक नए JProgressBar के रूप में jb में 0 से 2000 तक की सीमा है मूल रूप से उन मूल्यों की श्रेणी है जिन्हें आप अध्यक्षता कर सकते हैं, लेकिन यह वास्तव में प्रगति की गणना प्रतिशत गणना में की जाएगी।
इसलिए, कोई मुद्दा नहीं है।
तब जे बार JProgressBar का आकार मूल रूप से स्थान और चौड़ाई के साथ तय किया गया था।
और फिर सेट वैल्यू मूल रूप से 0 है, प्रोग्राम बार शून्य स्थान से शुरू होगा, फिर जेबी सेट स्ट्रिंग पेंट।
तो, यह मूल रूप से सच है, क्योंकि यह प्रगति को सही उजागर करेगा।
और फिर अंत में, हम jb को जोड़ते हैं जिसका मतलब है कि प्रगति बार, हमने यहां फ़्रेम में जोड़ा उसी का निर्माता है।
तो, इसे फ़्रेम में सेट किया गया है, साइड सेट लेआउट ठीक है।
अब, यहां प्रगति को गतिशील रूप से बदलने के लिए, हमें यहां एक और फ़ंक्शन को परिभाषित करना होगा, जिसे इट्रेट कहते हैं।
और यह फ़ंक्शन जैसा कि हम सिर्फ लूप देखते हैं, और लूप तब तक जारी रहेगा जब तक कि यह 0 से दो 2000 तक पूरा न हो जाए, j b सेट वैल्यू i है।
और फिर प्रगति मूल रूप से है, यहां मूल रूप से कितनी गति है कि मैं प्लस 20, इसलिए 20 अब, अगले एक उदाहरण इस मायने में बहुत महत्वपूर्ण है कि जावा स्विंग का उपयोग करके एक पेड़ की संरचना तैयार की जा सकती है।
और एक पेड़ की संरचना का उपयोग करें जो आप विभिन्न से परिचित हैं, जब भी आप कमांड तालाब का उपयोग करके एक निर्देशिका खोलते हैं या कुछ का मतलब है कि कंप्यूटर में कमांड का उपयोग करना।
इसलिए, यदि आप निर्देशिका संरचना को देखते हैं, तो jt मूल रूप से एक निर्देशिका संरचना दिखा रहा है जो संभव है।
इस उदाहरण में, जैसा कि हम देखते हैं कि यह एक बहुत ही सरल संरचना है, फिर से यह विस्तार किया जा सकता है कि क्या इस पेड़ की संरचना में कुछ अन्य नोड्स हैं या नहीं।
उदाहरण के लिए, यहां शैली निर्देशिका संरचना में मूल है, यहां शैली में दो हैं जिन्हें रंग और तालाब नाम दिया गया है।
इसलिए, यदि हम रंग का चयन करते हैं, अगर कुछ तत्व हैं, तो यह स्वतः ही उस अधिकार में विस्तारित हो जाएगा, और फिर लाल, नीला, काला सही।
और अगर लाल सामग्री कुछ और, तो यदि आप इसे क्लिक कर सकते हैं, लेकिन इस मामले में यह नहीं है, तो यह इस तरह है।
तो, यह एक पेड़ जैसा दिखता है, इसलिए इसका मुख्य है।
और मुख्य उप मुख्य से, और फिर उप मुख्य से इस तरह आइटम है।
इसलिए, पदानुक्रम की कोई सीमा नहीं है जिससे हम वास्तव में ऊपर से नीचे तक जा सकते हैं, जैसा कि हम वहां देख सकते हैं।
अब, हम वास्तव में देखेंगे कि कैसे इस तरह के एक मेनू, और फिर सबमेनू या सीधे या सीधे सीधे घटक में जोड़ा जा सकता है।
तो, यह उदाहरण दिखाता है, पहले हमें एक फ्रेम बनाना है, इस मामले में एफ फ्रेम है।
और फिर हम बस एक निर्माता के रूप में पेड़ के उदाहरण के रूप में कार्यक्रम पर चर्चा करते हैं, हम इस वस्तु को एक निर्माता के रूप में लागू करेंगे, यही कारण है।
और यहां पेड़ में अलग-अलग वस्तुओं को डिफ़ॉल्ट म्यू टेबल, ट्री नोड और फिर शैली द्वारा घोषित किया जा सकता है।
तो, यह पहली एक शैली है।
इसलिए, हमारे पास शैली के रूप में लेबल है, इसलिए वह वहां है।
हम कुछ अन्य रंग तालाब भी बनाते हैं, क्योंकि वे वास्तव में टेबल नोड टी नोड भी हैं।
इसलिए, हमने यहां तीन टी नोड बनाए हैं;
शैली, रंग और तालाब।
और फिर हम शैली नोड्स में रंग और तालाब जोड़ते हैं, यह मूल रूप से शैली नोड का उप नोड है, इसलिए हम इसे जोड़ते हैं।
और अगले हम कुछ और नोड बनाते हैं जो विभिन्न रंगों जैसे लाल, नीले, काले और हरे रंग से संबंधित होते हैं, और अंत में हम नोड रंग में इस नोड को जोड़ते हैं।
तो, यह मूल रूप से उप नोड या वास्तव में नोड रंग के बच्चे हैं, इसलिए यह नोड रंग के बच्चों के रूप में दिखाई देगा।
तो, यह विभिन्न नोड्स के गठन को पूरा करता है।
और अंत में, हम सिर्फ J ट्री बनाते हैं जिसका अर्थ है ट्री, और इसमें रूट नोड को पास करना।
तो, यहाँ हम देखते हैं कि हम बनाते हैं JT में पेड़ है, और रूट नोड यहाँ शैली है।
इसलिए, शैली को पारित करना।
और फिर अंत में, हम इस पेड़ को फ़्रेम में जोड़ते हैं, और फ़्रेम का अन्य साइज़िंग, दृश्यता, और आकार सब कुछ किया जाता है।
इसलिए, इस प्रकार मूल रूप से अपने स्वयं के फ़्रेम को कैसे बनाया जाए, और जैसा कि आउटपुट दिखाया गया है, यह मूल रूप से पेड़ को इस तरह प्रदर्शित करेगा।
तो, यह पेड़ का उदाहरण है, और कई और वस्तुओं को जोड़ा जा सकता है, आपके पास कई अन्य चीजें हो सकती हैं।
हमारा अगला उदाहरण रंग चयनकर्ता है।
जैसा कि आप जानते हैं कि आप पसंद से या तो रंग का उपयोग कर सकते हैं, जैसा कि हमने पहले ही कुछ अन्य प्रदर्शन सत्रों में एक उदाहरण का अनुभव किया है।
लेकिन, यहाँ रंग पसंद है, जावा स्विंग आपको विभिन्न रंगों के सामान्य पेड़ रखने के लिए देता है, और वहाँ से हम अपनी पसंद का रंग चुन सकते हैं।
और फिर उस रंग को एक पृष्ठभूमि के रूप में या एक तालाब के रंग के रूप में या जो कुछ भी हो, के रूप में सेट किया जा सकता है और यह एक उदाहरण है जो आपको बता सकता है।
अब, हम यहां उदाहरण देखते हैं।
तो, यह एक फ़्रेम है, और फ़्रेम में एक बटन रंग शामिल है।
यदि हम इस बटन पर क्लिक करते हैं, तो रंग विकल्प अपने आप यहां आ जाएगा।
तो, यह रंग पसंद आता है, और फिर इस रंग की पसंद अलग होती है जिसे मेनू में विकल्प मेनूबार कहा जाता है क्योंकि मुझे RGB, HAS, और HSB ये सभी चीजें दिखाई देती हैं।
तो, ये अलग तरह से रंग को चुना जा सकता है, और फिर इसे सेट किया जा सकता है, और इसे स्वचालित रूप से सेट किया जा सकता है।
तो, सब कुछ मूल रूप से हल्का है जैसे कि साधन, उन्हें आपको उनके प्रत्यक्ष कार्यान्वयन के बारे में परेशान करने की ज़रूरत नहीं है, यह वहां है।
आप बस इसे जोड़ सकते हैं, फिर अपने कार्यक्रम में आप सभी सुविधाओं तक पहुंच सकते हैं, यह वहां है।
इसलिए, जैसा कि हम अलग-अलग रंग मोड देखते हैं जिसका मतलब है RGB पैटर्न, इसे दिखाया जा सकता है।
और तदनुसार, उनके लिए अलग रंग भी सेट किया जा सकता है।
तो, यह तरीका है अब यहाँ पर जिस तरह से रंग को वास्तव में चुना जा सकता है, उसने आपको चार अलग-अलग तरीके दिए हैं जिससे रंग चुना जा सकता है।
और एक रंग पर क्लिक करके भी
वहाँ बिंदु, हम रंग को जोड़ सकते हैं जैसा कि हम बदलते रंग को देखते हैं, हम रंग बिंदु और सब कुछ बदल सकते हैं।
इसलिए, जब भी आप रंग चुनते हैं, तो यह वहां तय करेगा कि हमने कौन सा रंग चुना है, और पिछला रंग क्या है जो इतिहास है।
सभी इतिहास का रंग आपको हाल के फलक में दिखाया जा सकता है।
और फिर सभी रंगों को चुना गया है, और फिर यह चीजें हैं।
अब, इतनी सारी चीजें जो वहां मौजूद हैं, लेकिन न्यूनतम संख्या में कोडिंग संभव है।
और यहां वह कोड है जो मूल रूप से जावा स्विंग में कलर चॉइस घटक से निपट सकता है।
जैसा कि हम कोड देखते हैं, यह मूल रूप से उस वर्ग का नाम है जिसे हम लागू करने जा रहे हैं रंग चयनकर्ता उदाहरण जे फ्रेम का विस्तार करते हैं, और जैसा कि हमें कुछ घटनाओं को इनपुट करना होगा।
इसलिए, कार्रवाई श्रोता को लागू करना चाहिए।
तो, यह मूल रूप से कार्रवाई श्रोता है।
और फिर हम बटन J बटन बनाते हैं जो मूल रूप से शुरू में उस रंग के लिए होता है जिसे वहां बनाने की आवश्यकता होती है, जैसा कि हमने वास्तव में जेबटन रंग से शुरू किया है, इसलिए यह वहां है।
तो, हम बटन बनाते हैं, और रंग के रूप में लेबल।
और फिर एक्शन श्रोता को इस एक, सी ऐड बटन में जोड़ें, इसलिए हम इस बटन को इस घटक में जोड़ते हैं।
और फिर कंटेंट पेन वास्तव में प्राप्त करें, इसलिए कंटेंट पेन मूल रूप से यह रंग वास्तव में कंटेंट होगा।
और फिर हमने प्रदर्शन को परिभाषित किया है, इसलिए यहां की दिनचर्या को संभालने वाली घटना एक्शन ई इवेंट का प्रदर्शन करती है।
इसलिए, प्रारंभिक रंग में रंग मूल रूप से लाल रंग के रूप में चुना जाता है, ये डिफ़ॉल्ट रंग हैं।
अन्यथा, रंग को जे कलर चॉसर के रूप में सेट किया जा सकता है, फिर डायलॉग दिखाएं इस रंग को चुनें क्योंकि मूल रूप से एक संवाद है जो वहां होगा, और वास्तव में प्रारंभिक रंग के साथ।
और फिर बैकग्राउंड कलर को एक रंग के रूप में सेट करें, जिसका अर्थ है कि आप जो भी रंग चुनेंगे, वह उस रंग के साथ लेआउट सेट करेगा जो कि सभी है।
और फिर अंत में मुख्य उदाहरण में, हम इस रंग चयनकर्ता की एक वस्तु बनाते हैं।
और फिर रंग चयनकर्ता को इस घटक में रखा जाएगा, और फिर इसे आकार और फ़्रेम विस्थापित किया जाएगा।
तो, यह वह तरीका है जो वहां है, यह इतना बड़ा नहीं है कि इसे चरण कहा जाता है या बुनियादी जटिल प्रक्रियाएं बहुत सरल हैं, केवल आपको वहां रंग चयनकर्ता उदाहरण जोड़ना होगा।
और इसे आपके सिस्टम में जोड़ा जा सकता है।
अब, हमारा अगला उदाहरण मूल रूप से TabbedPane है।
तो, TabbedPane मूल रूप से हमें एक TabbedPane विंडो का दृश्य है।
TabbedPane जैसा कि आप देखते हैं कि एक टैब्ड है, इसलिए वहां कई टैब हैं, जैसा कि हम इस उदाहरण में यहां देखते हैं।
एक TabbedPane तीन मेनू मुख्य, विज़िट और सहायता के साथ दिखाई देता है।
तो, इसी तरह अलग-अलग मेनू को वहाँ जोड़ा जा सकता है, और यह उदाहरण यहाँ इसके बारे में विचार को स्पष्ट करता है।
तो, हम पहले आकार का पाठ क्षेत्र कहते हैं 200, 200 यहाँ, तो इसका मतलब है कि यह आकार 200 का पाठ क्षेत्र है।
और यह पाठ क्षेत्र वास्तव में एक अंतिम के रूप में शामिल होगा, इसलिए मूल रूप से हम इस पाठ क्षेत्र को एक पैनल में जोड़ते हैं।
और दो अन्य पैनल पी 2 और पी 3 हैं जो हमने वहां जोड़े हैं।
तो, मूल फलक के अलावा, पी 1, पी 2 और पी 3 होगा।
तो, पी 2, पी 3 मूल रूप से अलग-अलग मेनू से संबंधित पैनल हैं, इस पर हैं।
तो, पी 1 मुख्य के लिए है, पी 2 यात्रा के लिए है, और पी 3 मदद की तरह है।
और हम इसे TabbedPane में कैसे जोड़ सकते हैं, यह मूल रूप से है, जैसे कि हमने tabbed pane object tp बनाया है, बस हम इन सभी मेनू को जोड़ने जा रहे हैं tp add, tp add main, tp add say visit, tp help help 1 , पी 2, पी 3 जैसा दिखता है।
और फिर अंत में, हमें इस tp को उस फ़्रेम में जोड़ना है, और यह एक tabbed फलक बनाने का तरीका पूरा करता है जिस तरह से यह आउटपुट को देखेगा जैसा हमने देखा है।
तो, यह वह तरीका है जिसमें टैब्ड पैन को जोड़ा जा सकता है, और टैब्ड पैन में कुछ अन्य तत्व भी शामिल हो सकते हैं या इसमें कुछ ईवेंट जनरेशन शामिल हो सकते हैं, ताकि यदि हम इस टैब्डपेन को क्लिक करें, तो कुछ चीजें दिखाई देंगी।
तो, हमारा अगला उदाहरण JSlider है।
हम पहले से ही परिचित हैं JSlider, JSlider की कुछ झलक हमारे रंग चयनक उदाहरण में उपयोग की गई है।
यह मूल रूप से समान है, लेकिन यह एक स्वतंत्र रूप से जेएसलाइडर है, स्लाइडर कैसा दिखेगा जैसा कि हम यहां देखते हैं कि यह एक आउटपुट है, मुझे बड़ा हां कहना चाहिए।
तो, यहाँ हम एक स्लाइडर का उदाहरण देख सकते हैं।
और फिर एक स्लाइड बटन है, अगर हम क्लिक करते हैं, और फिर खींचें, तो स्लाइडर ऊर्ध्वाधर रेखा के पार चला जाएगा कुछ क्षैतिज, स्लाइडर के लिए अभिविन्यास भी संभव है, लेकिन आमतौर पर यह प्रतीत होता है कि ऊर्ध्वाधर एक है।
और इसलिए यह स्लाइडर है जैसा कि हम स्लाइडर को देखते हैं यदि हम इसे स्थानांतरित करते हैं, और एक छोटी सी स्थिति, स्लाइडर को रखा जाता है एक मूल्य लिखा जा सकता है।
तो, वहाँ तरीके हैं कि स्लाइडर मूल्य भी पढ़ा जा सकता है।
अब, यहां एक सरल उदाहरण है कि इसमें एक स्लाइडर शामिल हो सकता है।
तो, हम स्लाइडर के नाम को स्लाइडर के रूप में JSlider देते हैं।
और फिर मूल रूप से स्लाइडर क्षैतिज है, ताकि क्षैतिज आंदोलन हो।
यदि आप JSlider या वर्टिकल लिखते हैं तो इसका मतलब है, वर्टिकल स्लाइडर वहाँ होगा।
अब, अगले तीन आइटम बहुत महत्वपूर्ण हैं।
तो, पहले पता चलता है कि 0 और 50 मूल रूप से है, 0 और 50 ठीक है।
तो, 0 और 50 मूल रूप से सीमा है, और फिर 25 मूल रूप से पिक्सेल सही में चौड़ाई सही है, इसलिए डिफ़ॉल्ट वहाँ डिफ़ॉल्ट है।
जब भी यह सीमा में डिफ़ॉल्ट स्थान प्रकट होता है, तो वह मान वहां दिखाई देगा।
तो, यह एक 25 है, यह वास्तव में डिफ़ॉल्ट स्थान है, जब भी मैं यह दिखाना शुरू करता हूं यह वहां है हाँ।
तो, डिफ़ॉल्ट स्थान 25 है, और फिर श्रेणी मूल रूप से 0 से 50 है।
तो, न्यूनतम 0 है, और अधिकतम 50 है।
और फिर हम इसे फ़्रेम या पैनल में जोड़ सकते हैं।
इस मामले में,
हमने यह एक पैनल जोड़ा है, इसलिए स्लाइडर को एक पैनल में जोड़ा गया है।
और फिर पैनल, अंत में फ़्रेम में जोड़ें।
और यह वह तरीका है जिससे स्लाइडर हो सकता है।
इसलिए, हमारे पास लगभग सभी महत्वपूर्ण जेएसविंग घटक हैं, जो जेएसविंग पैकेज में हैं, कई और भी हैं।
वे चीजें जो आप लिख सकते हैं, आप अपनी खुद की और अधिक अभ्यासों की आवश्यकता कर सकते हैं, ताकि आप इसे अधिक विवरण में सीख सकें।
आपका बहुत बहुत धन्यवाद।
देबस समता विभाग के कंप्यूटर विज्ञान और इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर व्याख्यान में 35 प्रो-प्रोग्रामिंग प्रोग्रामिंग - II में हम एप्लेट के बारे में चर्चा कर रहे हैं।
जावा सिंटैक्स का उपयोग करके एप्लेट लिखने के तरीके के बारे में हमारे पास कुछ बुनियादी विचार हैं।
इसलिए, कई और चीजें भी सीखी जानी चाहिए ताकि एप्लेट का संबंध हो।
इसलिए, आज कुछ और अवधारणाओं पर चर्चा करेंगे और अगले मॉड्यूल में भी हम अधिक अग्रिम अवधारणाओं पर चर्चा करेंगे।
तो, एप्लेट बहुत महत्वपूर्ण है जो कि जावा प्रोग्रामिंग में अवधारणा कहलाती है और इसके कई अनुप्रयोग हैं, इसलिए, हम ठीक उसी तरह से संगठित तरीके से एपलेट को डिज़ाइन कर सकते हैं।
अब, ऐसा करने से पहले हमें एप्लेट के बारे में कुछ बुनियादी विचार रखना चाहिए।
तो, मूल विचार का अर्थ है, यह वास्तव में एक एप्लेट है और इसकी उपयोगिता क्या है।
दरअसल, जब जावा ने उस समय कॉन्सेप्ट प्रोग्रामिंग अखाड़े में शुरुआत की, तो यह एक अत्यधिक आवश्यकता थी कि, कैसे एक प्रोग्रामिंग लैंग्वेज इंटरनेट प्रोग्रामिंग को सपोर्ट कर सकती है।
अब, अब तक इंटरनेट प्रोग्रामिंग का मूल आधार यह है कि कोई ब्राउज़र वेब पेज को कैसे ब्राउज़ कर सकता है।
इसलिए, आमतौर पर एचटीएमएल पेज, एचटीएमएल में लिखे वेब पेज को हाइपरटेक्स्ट मार्कअप लैंग्वेज कहा जाता है।
अब, HTML में कई चीजें शामिल हो सकती हैं।
एक उदाहरण के लिए यह एक आंकड़ा है जिसे हमने यहां दिखाया है यह मूल रूप से वेब पेज है, ठीक है।
और फिर इस वेब में अगर हम देखें तो इसमें कई तत्व होते हैं।
उदाहरण के लिए, यह एक छवि है और यह भी एक छवि है और कुछ टेक्स्ट बॉक्स हैं और कुछ लिंक हो सकते हैं जैसे आप यहाँ देखते हैं।
तो, यह लिंक है जो कई लिंक हैं, यह मूल रूप से मेनू है जिसे हम इस तरह कह सकते हैं।
तो, वहाँ कई तत्व हैं।
अब, इन कई तत्वों में से एक तत्व एक एप्लेट हो सकता है।
तो, एप्लेट शायद हम कह सकते हैं मान लीजिए कि, यह भी एक एप्लेट जैसा है।
तो, इस एप्लेट की अपनी सामग्री है और यह मूल रूप से कुछ उद्देश्य प्रदान करता है, अगर हम इस एप्लेट पर क्लिक करें या इसके बजाय आप इस एप्लेट का उपयोग इंटरनेट से बातचीत करने के लिए करते हैं तो इस तरह की अवधारणा है।
तो, मूल रूप से एप्लेट का मुख्य उद्देश्य इंटरनेट प्रोग्रामिंग के लिए है और इस इंटरनेट प्रोग्रामिंग के लिए, हमें एक HTML पेज बनाना होगा;
और HTML पेज बनाने के लिए हम कुछ कोड का इस्तेमाल कर सकते हैं;
कुछ कार्यक्रमों को निष्पादित किया जाना है और उस कोड को उस प्रोग्राम को वास्तव में एप्लेट प्रोग्राम कहा जाता है।
तो, अनिवार्य रूप से एप्लेट केवल इस उद्देश्य के लिए है।
अब, इस एप्लेट के बारे में यही विचार है।
अब, इस एप्लेट प्रोग्रामिंग के लिए, आइए देखें कि जावा हमें किस तरह से अनुकूल बनाता है, जावा के समर्थन क्या हैं जो हमारे पास हो सकते हैं।
अब, जावा एपीआई में, एप्लेट पैकेज में परिभाषित पैकेज के साथ एक पैकेज है।
तो यह
जावा डॉट एपलेट पैकेज जिसे हम कहते हैं और एक वर्ग है जिसे एप्लेट क्लास कहा जाता है।
तो, जावा डॉट एप्लेट पैकेज में एक क्लास होती है जिसे एप्लेट क्लास कहा जाता है।
तो, हम अपने एप्लेट प्रोग्राम को वास्तव में बनाने के लिए इस एप्लेट क्लास का उपयोग कर सकते हैं।
दरअसल, एप्लेट क्लास के बारे में मूल विचार क्या है?
बिल्कुल, एप्लेट क्लास एक अमूर्त वर्ग है और इसकी कुछ पूर्वनिर्धारित विधि है, वे विधियां भी अमूर्त विधियां हैं।
इसलिए, यदि हमें अनिवार्य रूप से एक एप्लेट बनाना है, तो यह मूल रूप से इस एप्लेट क्लास से विरासत में मिलेगा।
यहां इस अर्थ में निहित है कि सभी विधियां जो एप्लेट में हैं, इसका मतलब है कि अमूर्त विधियां यहां लिखी जानी हैं।
वैसे भी, इसलिए यह लेखन और एप्लेट कार्यक्रम के बारे में मूल विचार है।
इसलिए, हमें पहले इस पैकेज को आयात करना होगा, इस पैकेज को आयात करना होगा जब भी हमें इस एप्लेट को लिखना है और फिर एक बार इस पैकेज को आयात करना है, तो हमें इस पद्धति को अधिलेखित करना होगा।
और यहां एक और बात यह है कि, एप्लेट्स और सामान्य कार्यक्रम का कई अर्थों में अलग-अलग संदर्भ है।
इस मायने में अलग है कि एप्लेट के मामले में जैसा कि हम देखते हैं कि हमें कुछ अलग कार्यक्रम की आवश्यकता है।
उदाहरण के लिए, जावा एप्लिकेशन के लिए, हमें जावा कमांड की आवश्यकता होती है, जबकि एप्लेट के लिए हमें एप्लेटव्यूअर नामक अलग प्रोग्राम की आवश्यकता होती है।
तो, जावा रनटाइम इंटरप्रेटर जिसे जावा कमांड कहा जाता है, वह वास्तव में एप्लेट पर लागू नहीं होता है।
और फिर एक और महत्वपूर्ण बात यह है कि, जावा को खोलने की आवश्यकता है या एप्लेट प्रोग्राम को ब्राउज़र की मदद से निष्पादित करने की आवश्यकता है, जैसे हॉट जावा, नेटस्केप नेविगेटर, इंटरनेट एक्सप्लोरर वगैरह।
तो, हमें एप्लेट, एक ब्राउज़र या एक एप्लेटव्यूअर चलाने की आवश्यकता है।
तो, यह मूल विचार है, एप्लेट्स और फिर जाहिर है, एप्लेट्स और एप्लिकेशन के बीच का अंतर।
वैसे भी, इस पेंटिंग और एप्लेट के बारे में हम बाद में कई बातों पर चर्चा करेंगे।
और एक महत्वपूर्ण बात यह है कि इस एप्लेट के अलावा विंडो बेस्ड प्रोग्राम एक महत्वपूर्ण बात यह है कि एप्लेट हमेशा एक ईवेंट संचालित प्रोग्राम है।
तो, घटना संचालित साधन, एप्लेट कुछ देखने के लिए तैयार है और यह उपयोगकर्ता के साथ बातचीत कर सकता है।
तो, यह मूल रूप से उपयोगकर्ता इंटरनेट के साथ बातचीत करता है, उपयोगकर्ता कंप्यूटर के साथ बातचीत कर सकता है, लेकिन यह एप्लेट्स के माध्यम से बातचीत है।
तो, यह परस्पर क्रिया एक दूसरे अवधारणा AWT का उपयोग करके एप्लेट में संभव है, इसे Abstract Window Toolkits कहा जाता है।
तो, मूल रूप से एप्लेट और AWT एक साथ काम करते हैं।
इसलिए, हम वास्तविक एप्लेट प्रोग्राम AWT के लिए प्रभावित नहीं कर सकते हैं और फिर एप्लेट अलग तरीके से चीजें नहीं हो सकती हैं, दोनों चीजों पर संयुक्त रूप से विचार किया जा सकता है।
तो, इसीलिए हमें java dot applet डॉट स्टार को इम्पोर्ट करना होगा, इसका मतलब है, सभी applet क्लास की सुविधाओं के साथ-साथ, हमें java डॉट awt डॉट स्टार को इम्पोर्ट करना होगा।
इसका मतलब है कि AWT में जो भी वर्ग परिभाषित किए गए हैं, वे होने चाहिए।
AWT के बारे में हम एप्लेट को कवर करने के बाद विवरण में चर्चा करेंगे।
वैसे भी, यह इस बारे में विचार है कि एप्लेट मूल रूप से एक कार्यक्रम संचालित एक कार्यक्रम है।
अब, घटना संचालित कार्यक्रम क्या है जिसे एक उदाहरण का उपयोग करके बेहतर ढंग से समझा जा सकता है, आइए हम इस छवि को यहां देखें।
और वास्तव में, यदि आप इस तरह के ऐपलेट्स को ध्यान से देखते हैं जो आप अपने मोबाइल में देखते हैं या जो कुछ भी है।
और यह मूल रूप से एक कैलकुलेटर प्रोग्राम है, जिसका अर्थ है, अगर हम 7 पर क्लिक कर सकते हैं और फिर 8 फिर प्लस और फिर 1 2।
तो, इसका मतलब है कि परिणाम होगा।
तो, यहाँ आप देखते हैं कि क्या क्लिक है, मैंने कहा क्लिक करें।
तो, माउस 7 और 8 पर क्लिक करें।
इसलिए, यदि हम 7 पर क्लिक करते हैं, तो मूल रूप से क्या होगा, 7 का चयन किया जाएगा या यह मूल रूप से यहां दिखाई देगा।
इसी तरह, 7 के बाद 8, तो 7 यहाँ दिखाई देंगे, प्लस और फिर 1 और फिर 2 यदि हम चयन करते हैं, तो वे भी वहां होंगे।
और फिर मान लीजिए, प्लस का मतलब है कि, यह एक घटना है।
इसका मतलब है कि हम जो भी पहले सेलेक्ट करना चाहते हैं उसे जोड़ लेंगे, साथ ही अगला जो सेलेक्ट होने वाला है।
तो, ये मूल रूप से संचालित घटना कहते हैं।
तो, यहाँ विचार यह है कि, यहाँ विभिन्न घटक हैं।
ये मूल रूप से इन एप्लेट्स में अलग-अलग तत्वों को ट्रिगर किया जा सकता है और फिर एक बार इन एप्लेट्स को ट्रिगर किया जाता है और ईवेंट उत्पन्न हो जाएंगे।
यह इवेंट आधारित प्रोग्रामिंग की अवधारणा है।
तो, एप्लेट मूल रूप से एक इवेंट बेस प्रोग्रामिंग अवधारणा है।
अब, इसलिए हमने उस एप्लेट के बारे में जान लिया है कि यह मूल रूप से विंडो प्रोग्राम है जो वास्तव में उपयोगकर्ता आधारित विंडोज प्रोग्राम और इवेंट संचालित कार्यक्रम है।
तो अब, हमें इस बारे में सीखना है कि यह ग्राफिकल यूजर इंटरफेस फेस विन्डोज़ कैसे बनाया जा सकता है और फिर ईवेंट कैसे जेनरेट किया जा सकता है।
तो, ये मूल अवधारणाएं हैं, अगर हम इसे सीख सकते हैं और फिर ऐपलेट सीखने की हमारी अवधारणा पूरी हो जाएगी।
अब, इस चीज़ पर जाने से पहले, आइए देखें कि एक एप्लेट की संरचना क्या होती है।
अब तो, एप्लेट के पास कुछ आवश्यक घटक हैं।
अब, जैसा कि मैंने आपको पहले ही बताया कि, ये 2 पैकेज हैं, जब भी आपको एप्लेट प्रोग्रामिंग करनी होगी।
और फिर अगली बात यह है कि, हमें अपना वर्ग बनाना है, यही आपका कार्यक्रम है और इसे एप्लेट वर्ग से विरासत में प्राप्त किया जाना चाहिए।
तो, हमारा अगला सिंटैक्स मूल रूप से यह एक सार्वजनिक वर्ग है यह आपका नाम है जिसका अर्थ है, उपयोगकर्ता नाम परिभाषित करता है और फिर एप्लेट निकालता है।
तो, यह एक सीमा हो सकती है जिसका मतलब विरासत में मिला कार्यक्रम है।
अब, विभिन्न तरीकों का हिस्सा।
अब, फिर से कई तरीके हैं।
इसलिए, जैसा कि हम देखते हैं कि एक init पद्धति है और फिर प्रारंभ विधि और स्टॉप विधि फिर पेंट विधि विध्वंस विधि है।
तो, ये 5 मानक विधियां हैं जो आमतौर पर तब होती हैं जब कोई कार्यक्रम अपने स्वयं के एपलेट को डिजाइन करना चाहता है।
अब, इन सभी तरीकों को फिर से जैसा कि मैंने आपको बताया था, ये अमूर्त विधि हैं, जिन्हें क्लास एप्लेट में परिभाषित किया गया है, जो एक अमूर्त वर्ग है।
इसका मतलब है कि अगर हम अपना खुद का एप्लेट प्रोग्राम करना चाहते हैं तो हमें इस तरीके को लिखना होगा।
तो, यह मूल रूप से यदि आप एप्लेट प्रोग्राम लिखना चाहते हैं तो इसका मतलब है कि आपको init के तरीकों को लागू करना होगा, विधियाँ शुरू करनी होंगी, विधि को रोकना होगा, रंग विधि और विध्वंस विधि को नष्ट करना होगा।
जरूरी नहीं कि सभी विधियां अनिवार्य हों, यह सभी विधियां मूल रूप से वैकल्पिक हैं आप जरूरत पड़ने पर इसका उपयोग कर सकते हैं। एप्लेट वास्तव में, यह हमारे लिए कुछ भी नहीं कर रहा है, लेकिन यह केवल देखा जाता है।
तो, एप्लेटव्यूअर, इसे ब्राउज़ करें और फिर इसे अपनी स्क्रीन पर प्रदर्शित करें और दिखा दें कि कुछ भी नहीं है, कोई घटना नहीं है, कोई अन्य सामग्री नहीं है, कोई अन्य तत्व वगैरह नहीं हैं।
इसलिए, इस तरह से मैं यहां जोर देना चाहता हूं कि जिन तरीकों का हमने उपयोग किया है, वे अनिवार्य हैं;
वे अनिवार्य नहीं हैं वे वैकल्पिक हैं, लेकिन अधिमानतः यदि आप उन्हें करना चाहते हैं तो आपको उन्हें अपनी आवश्यकता के अनुसार ठीक से लागू करना चाहिए।
अब, अगली बात यह है कि, एप्लेट प्रोग्राम में इन सभी तरीकों को यहां और वहां लिखा जाना चाहिए या नहीं।
वास्तव में उत्तर है हां, हम लिख सकते हैं कि पहले init लिखना आवश्यक नहीं है फिर शुरू करें फिर जो कुछ भी है उसे पेंट करें, लेकिन हम किसी भी क्रम में लिख सकते हैं।
हालाँकि इन सभी विधियों का निष्पादन एक विशिष्ट आदेश का पालन करता है।
उदाहरण के लिए, जैसा कि हमने यहां देखा है, एप्लेट को निष्पादित किया जाएगा यदि आप इन सभी तरीकों को वहां परिभाषित करते हैं तो पहले init करें, एक बार init निष्पादित होने के बाद, प्रारंभ को लागू किया जाएगा और फिर विधि में पेंट किया जाएगा।
ये 3 विधियाँ हैं यदि इसे आपके एप्लेट प्रोग्राम में परिभाषित किया गया है तो उन्हें उसी क्रम में निष्पादित किया जाना चाहिए।
और अंत में, स्टॉप और फिर नष्ट करें यदि वे आपके कार्यक्रम में घोषित किए जाते हैं तो उन्हें इन आदेशों में निष्पादित किया जाना चाहिए।
इसलिए, आदेश बहुत महत्वपूर्ण है जैसा कि हम यहां सीखते हैं और फिर हम एक उदाहरण देंगे ताकि हम समझ सकें कि यह आदेश यहां कैसे महत्वपूर्ण है।
अब ठीक है, अब हम देखते हैं:
इस विधि का उद्देश्य क्या है;
init मेथड यह मूल रूप से एप्लेट को इनिशियलाइज़ करने के लिए उपयोग किया जाता है।
आरंभीकरण का अर्थ है, यदि हम एप्लेट की पृष्ठभूमि का रंग, एप्लेट की शैली बदलना चाहते हैं या आप एप्लेट शुरू करने से पहले कुछ करना चाहते हैं।
तो, यह मूल रूप से प्रारंभिक है।
वैसे भी, हमारे पास इस पद्धति का विस्तृत प्रदर्शन, विस्तृत वर्णन होगा कि उनका उपयोग कैसे किया जाता है;
init वास्तव में कई एप्लेट डिजाइन में कई महत्वपूर्ण अनुप्रयोग हैं।
इसलिए, जब भी हम कुछ केस अध्ययनों पर विचार करेंगे, हम विवरणों पर चर्चा करेंगे।
और फिर अंत में स्टॉप स्टार्ट विधि।
तो, init के बाद;
इसका मतलब है कि, इनिट विधि प्रारंभिककरण के लिए है, यह केवल एप्लेट को इनिशियलाइज़ नहीं करेगा और फिर प्रारंभ मूल रूप से शुरू हो रहा है और;
एप्लेट का प्रारंभ और निष्पादन।
तो, इसे मूल रूप से इनिट के बाद कहा जाता है यदि इसे यहां परिभाषित किया गया है और वास्तव में, यह मूल रूप से एप्लेट को पुनरारंभ करने के लिए कॉल करता है जब भी यह बंद होता है।
उदाहरण के लिए, आप एक वेब पेज ब्राउज़ कर रहे हैं, जहां एप्लेट की तुलना में आप बस इन वेब पेज को छोड़ देते हैं और फिर वापस आते हैं।
जब भी आप इसे छोड़ते हैं, एप्लेट मूल रूप से बंद हो जाता है, और जब आप वापस आते हैं तो उसी एप्लेट को निष्पादित करना शुरू हो जाता है।
तो, यह मूल रूप से इस पद्धति के बारे में विचार है।
तो, विधि शुरू करें।
और यहाँ एक उदाहरण है;
यह उदाहरण मूल रूप से आदेश के निष्पादन, init के निष्पादन के क्रम, प्रारंभ और पेंट विधि को दिखाता है।
अब, इस कार्यक्रम को पहले देखते हैं, जैसा कि हम यहाँ देखते हैं कि हम एक वर्ग की घोषणा करते हैं, जो कि हमारे एप्लेट का नाम है, यह मूल रूप से एप्लेट निकालता है।
और यहां, संदेश मूल रूप से संदेश है जिसे हम इसका उपयोग करना चाहते हैं, एक स्ट्रिंग हो सकता है, और यहां आप इनिट विधि देख सकते हैं।
यह यहां बहुत महत्वपूर्ण है क्योंकि हम देखते हैं कि हमने यहां क्या किया है, सेटबैकग्राउंड और ये कलर डॉट सियान।
इसका मतलब है कि, इस एप्लेट का बैक ग्राउंड एक सियान रंग और फिर अग्रभूमि, पाठ के रूप में सेट है यदि आप इस एप्लेट के भीतर प्रदर्शित करना चाहते हैं।
यह मूल रूप से एक लाल रंग के रूप में चुना गया है।
और मैसेज को इनिशियलाइज़ किया जाता है जैसे कि स्क्रीन के साथ है।
तो, पक्ष में init पर इस बात का संदेश है।
तो, यह मूल रूप से इनिट विधि है।
अब, यहां प्रारंभ विधि, जब भी विधि प्रारंभ होती है निष्पादन होता है।
यह मूल रूप से कुछ भी नहीं कर रहा है केवल संदेश मूल रूप से अद्यतन कर रहा है कि अंदर शुरू करें।
तो, इसका मतलब है, संदेश इन प्लस एक के साथ संवर्धित है।
और फिर पेंट विधि अगर हम देखते हैं;
पेंट विधि बिल्कुल फिर से संदेश के अंदर संदेश पेंट और फिर जी डॉट ड्रॉस्ट्रिंग (), यह संदेश जो पहले से ही इस संदेश में स्टोर में प्राप्त किया गया है, और ये मूल रूप से संदेश को प्रिंट करते हैं।
अब, अभी क्या संदेश है?
इसलिए, जब भी इसे इनिशियलाइज़ किया जाए।
इसलिए, संदेश प्रारंभ में इनसाइड में है और फिर जब भी प्रारंभ किया जाता है, तो वही विधि इन विधियों के साथ जुड़ जाएगी।
और अंत में, जब भी पेंट को बुलाया जाता है, तो विधि को फिर से जोड़ दिया जाएगा और संदेश इनसाइड इनिट हो जाएगा, फिर इनसाइड स्टार्ट और फिर इनसाइड पेंट और अंत में यह वहीं आ जाएगा।
अब, यह मूल रूप से है, मेरा मतलब उन तरीकों से है जिनके बारे में हमने चर्चा की है।
यदि हम इसे चलाते हैं, तो init, शुरू करें और फिर पेंट करें और स्वचालित रूप से इस तरह से आप आउटपुट देख सकते हैं।
तो, इसका मतलब है, यह दर्शाता है कि अन्य सभी निष्पादन पहले init हैं, फिर शुरू करें और फिर पेंट विधि।
तो, इस तरह से निष्पादन एप्लेट के मामले में होगा, जब भी यह अपना निष्पादन शुरू करता है।
अब, आगे की समाप्ति के लिए 2 विधियां उपयोग की जाती हैं, रोकें और नष्ट करें विधि।
इसलिए, जैसा कि मैंने आपको बताया था, स्टॉप मेथड का मतलब है अगर आप इस ब्राउज़र को छोड़ना चाहते हैं और तब वास्तव में एप्लेट इसके निष्पादन को रोक देगा।
तो, यह मूल रूप से रोक का विचार है।
अब, स्टॉप मूल रूप से अपने दृष्टिकोण को सही ढंग से रोक रहा है, लेकिन कुंजी पूरी तरह से नहीं।
तो, यह मूल रूप से नष्ट करने के लिए विधि है।
एक बार नष्ट करने की विधि का उपयोग आपके एप्लेट प्रोग्राम में किया जाता है, और जब भी यह विधि लागू होती है।
इसका मतलब है, कि यह मेमोरी से पूरी तरह से हट जाएगा और जब भी आप फिर से ब्राउज खोलेंगे तो हमें इसे फिर से लोड करना होगा, लेकिन अगर आप नष्ट का उपयोग नहीं करते हैं।
स्टॉप का मतलब है कि यह मेमोरी में होगा, लेकिन मेमोरी से पूरी तरह से नहीं हटाया जाएगा या इसे नष्ट नहीं किया जाएगा।
तो, नष्ट मूल रूप से एक एप्लेट के निष्पादन को पूरी तरह से मारता है।
अब, यहां एक उदाहरण दिया गया है जो मूल रूप से समझाता है कि स्टॉप विधि यहां कैसे काम करती है, लेकिन इस आंदोलन में मूल रूप से बहुत सी चीजें ग्रहण करेंगी।
अब, यहां हमने मूल रूप से एक कार्यक्रम या वर्ग पर चर्चा की, इस वर्ग की हमने यहां चर्चा की है, हालांकि, हमें इस बारे में कोई जानकारी नहीं है कि यह फ्रेम और सब कुछ कैसा है।
यह फ्रेम एक AWT में परिभाषित किया गया है, आइए मान लें कि हमने एक वर्ग को नमूनाफ्रेम कहा जाता है, जो एक फ़्रेम का विस्तार करता है।
मूल रूप से फ्रेम मूल रूप से एक अलग विंडो है, जिसे एप्लेट में शामिल किया जा सकता है या एक अलग से इसे देखा जा सकता है।
तो, फ्रेम मूल रूप से इस तरह है, यह सिर्फ हम कह सकते हैं जैसे एक सेट अप्लेट विंडो;
यह एक खिड़की है जिसे हम कह सकते हैं।
और ये फ्रेम हम मूल रूप से एक घटना की अवधारणा है, यह ठीक जगह ले जाएगा।
इसलिए, इन चीजों के बारे में बहुत कुछ जाने बिना, हम मानते हैं कि, एक फ्रेम बनाया जाएगा और यह फ्रेम बस कुछ होने की प्रतीक्षा करेगा।
तो, यह मूल रूप से कोड ऐसा करेगा।
और यह पेंट विधि है, जैसा कि हम इस वर्ग में देखते हैं, यह पेंट विधि जब भी कहा जाता है, तो यह पेंट विधि एक स्ट्रिंग खींचेगी, यह वास्तव में फ्रेम के शीर्षक में खिड़की में है।
अब, इसलिए यह इस कार्यक्रम का पहला भाग है, और फिर जैसा कि हम देखते हैं, अगले भाग में, हमें उस विधि को परिभाषित करना होगा जिसे हमने Mywindow घोषित किया है।
तो, यह मूल रूप से विधि है जो घोषित की गई है।
फिर से यह विधि मूल रूप से केवल इस चीज को नहीं करेगी जब भी किसी एप्लेट को इसका निष्पादन शुरू किया जाता है, यह मूल रूप से स्क्रीन पर विंडो प्रदर्शित करेगा।
और फिर अंत में, यह मूल रूप से एप्लेट क्लास प्रोग्राम है और यह मुख्य कार्यक्रम है जिसे हम कह सकते हैं, यहां हम इनिट विधि की घोषणा करते हैं।
Init मेथड एक फ्रेम बनाते है, यह f है फ्रेम।
और फिर इस फ्रेम को एक फ्रेम विंडो और उसके सेट के आकार को आरंभीकृत किया जाता है;
आकार क्या है?
उदाहरण के लिए, यह;
यदि यह फ्रेम है और यह एप्लेट है, तो यह फ्रेम का आकार है।
और ए फ्रेम विंडो यह मूल रूप से यहां इस तरह दिखाएगा, और यहां यह मूल रूप से एप्लेट के भीतर पेंट है, यह है;
यह एप्लेट विंडो में है।
अब, इस कार्यक्रम में अगर हम शुरू करते हैं, तो जब भी यह एप्लेट दर्शक के माध्यम से चलाया जाता है।
तब यह मूल रूप से इसे प्रदर्शित करता है और जैसे ही हम इसे प्रदर्शित करते हैं फ्रेम भी प्रदर्शित करते हैं।
तो, दोनों चीजें आपकी स्क्रीन पर दिखाई देंगी।
और फिर, शुरू, इसका मतलब है कि यह इस काम को करेगा, फिर यह बंद हो जाता है
अब, यदि हम देखते हैं कि यहां एक उदाहरण फिर से है;
तो, यह एक एप्लेट क्लास की परिभाषा है और यह है कि पूरा एप्लेट क्लास शामिल है।
अब, इस एप्लेट क्लास में अगर हम देखें;
हम init विधि, प्रारंभ विधि, विधि को रोकते हैं और विधि को नष्ट करते हैं।
दृष्टांत के लिए हम इस सभी विधि को बहुत सरल बनाते हैं।
यह मूल रूप से, एक स्ट्रिंग का उपयोग करता है और स्ट्रिंग को इस एक द्वारा इनिशियलाइज़ किया जाएगा और फिर आइटम को जोड़ने के लिए एक विधि को मूल रूप से यह सब विधि कहा जाता है।
अब, addItem पद्धति को यहां परिभाषित किया गया है, मूल रूप से स्ट्रिंग का एक तर्क है और यह मूल रूप से स्ट्रिंग को कंसोल पर प्रिंट करता है, इसका मतलब है कि जावा कंसोल विंडो के रूप में उपयोग करें और फिर यह मूल रूप से जो कुछ भी स्ट्रिंग हैं, वह इसे और फिर मूल रूप से जोड़ देगा। संदेश की अवधारणा के समान ही, जिसे अंतिम उदाहरण में दिखाया गया है।
और दमन का अर्थ है मूल रूप से, इसे साफ करना और फिर इसे वास्तव में पेंट करना।
तो, यह दमन है;
रेपेंट विधि मूल रूप से हर समय आउटपुट दिखाती है।
अब, तो यह शुरू होगा एप्लेट को घूरने के लिए यहां, जब भी इस विधि को बुलाया जाता है या एप्लेट को निष्पादित किया जाता है, तो स्वचालित रूप से आह्वान किया जाएगा।
और फिर एप्लेट को दिखाना शुरू हो जाएगा, और फिर ऐसा होगा;
तो फिर स्टॉप और फिर नष्ट एप्लेट में आ जाएगा।
अब, यहां पेंट विधि में, इसलिए एप्लेट के लिए चिंता का विषय है;
तो यह मूल रूप से आयत खींचेगा और इस आयत के भीतर यह मूल रूप से एक स्ट्रिंग खींचेगा।
अब, हम देखते हैं, इस कार्यक्रम का आउटपुट, यह कैसा दिखता है, तब आप समझ सकते हैं।
इसलिए, मूल रूप से जब भी हम इसे शुरू करते हैं, तो यह एप्लेट को शुरू करता है और एप्लेट को शुरू करता है, क्योंकि इस ऐडिटम अवधारणा के अनुसार यह कंसोल पर जाता है।
और एप्लेट भी होगा, जो यहां नहीं दिखाया गया है।
वैसे भी, एप्लेट वहाँ आ जाएगा और एप्लेट एप्लेट क्षेत्र पर स्ट्रिंग प्रदर्शित करेगा।
और फिर जब भी आप इसे रोकते हैं, तो यह मूल रूप से एप्लेट को बंद कर देगा और फिर एप्लेट को अनलोड करने का मतलब है, मेमोरी से पूरी तरह से साफ हो जाना।
तो, इस तरह से विनाश विधि इसे साफ कर देगी।
अब, ये विधियाँ कई अनुप्रयोग हैं, जब भी हमारे पास एक बहुत ही जटिल वेब आधार ब्राउज़िंग अनुप्रयोग होना चाहिए, ये हैं।
अब, इस अद्यतन के अलावा अन्य नष्ट और बंद एक और दो बहुत महत्वपूर्ण विधियां हैं।
वहाँ अद्यतन और फिर पेंट विधि कहा जाता है।
तो, अद्यतन विधि मूल रूप से है, ठीक इसके विपरीत यह init पद्धति के सेट पर है मूल रूप से पुन: आरंभीकरण है जिसे हम एप्लेट क्लास को अपडेट करने के लिए कह सकते हैं।
इसलिए, हम इसे एक उदाहरण के रूप में बदल सकते हैं जैसा कि हम देखते हैं, अगर हम एक अपडेट विधि को परिभाषित करते हैं और फिर हम पृष्ठभूमि का रंग, अग्रभूमि का रंग बदल सकते हैं तो हम ऐसा कुछ कर सकते हैं।
इसलिए, अगर हम अद्यतन के माध्यम से कुछ सेटिंग्स के साथ आरंभीकरण करते हैं, तो हम चीजों के प्रकार को रीसेट कर सकते हैं।
और फिर ये अपडेट विधि अगर हमारे पास है, तो इसे स्वचालित रूप से लागू नहीं किया जा सकता है।
पेंट विधि में आपको इसे अपडेट करने के लिए इसे कॉल करना होगा।
तो, यह मूल रूप से पेंट विधियों में अपडेट है, इसलिए यह इसे अपडेट करेगा और फिर बाद में
अपडेशन, पेंट विधि में आप जो भी कर सकते हैं, आप करेंगे।
इसलिए, अपडेट मूल रूप से आपके एप्लेट में सेटिंग्स को बदल रहा है। अब, रिपेट विधि यहां एक और उदाहरण है, आप इसे अपडेट करना चाहते हैं।
अब, उदाहरण के लिए मान लीजिए, यह आपका संपूर्ण एप्लेट दृश्य है, ये संपूर्ण एप्लेट हैं।
अब, एक विशेष भाग जिसे मैं इसे बदलना चाहता हूं, मान लीजिए कि इस हिस्से को मैं इसे बदलना चाहता हूं, लेकिन अन्य भाग सूचकांक रहेगा।
इसलिए, जब भी आप कुछ ग्राफिक्स या पेंटब्रश और इस तरह के एक का उपयोग करके ड्राइंग करते हैं, तो मैं इसे चुन सकता हूं;
और चयनित भाग मैं इसे फिर से लिख सकता हूं और फिर कुछ ऐसा है जिसे हम इसका उपयोग कर सकते हैं।
तो, रिपींट विधि मूल रूप से है, न कि पूरे एप्लेट्स व्यू हो सकते हैं या एप्लेट व्यू के किसी विशेष हिस्से को फिर से तैयार किया जा सकता है या इसे फिर से लिखा जा सकता है।
तो, यह विचार विधि के बारे में है।
अब, मेरे पास एक उदाहरण हो सकता है, ताकि हम समझ सकें, यह अद्यतन और पुनरावृत्ति विधि कैसे काम करती है, बहुत दिलचस्प कार्यक्रम है।
इस कार्यक्रम को बैनर उदाहरण कहा जाता है।
और फिर एक अन्य निर्माता, यह मूल रूप से कुछ देरी के साथ है, इसका मतलब है कि पुनरावृत्ति और अद्यतन का एक साथ उपयोग किया जाना चाहिए।
इसलिए, जब एक बार दमन होता है, तो निम्नलिखित द्वारा
अद्यतन है।
तो, एक समय की देरी जिसे हम निर्दिष्ट कर सकते हैं, लंबे समय तक अधिकतम पता लगाता है कि यह इंगित करता है कि, मिलीसेकंड में अधिकतम समय क्या है, यह होना चाहिए कि अद्यतन को कॉल करने से पहले एप्लेट को इंतजार करना चाहिए।
तो, यह मूल रूप से है, अब अगर आप तुरंत प्रभाव को नहीं देख सकते हैं।
तो, इसीलिए कुछ देरी तो फिर से होनी चाहिए।
ताकि, कुछ दृश्य, कुछ छाप यहां प्राप्त की जा सके। कार्यक्रम भी।
तो, एप्लेट ने आपको थ्रेडिंग, दोनों चीजें एक साथ यहाँ जोड़ दीं।
अभी
यहाँ, इसलिए एक थ्रेड क्लास बनाया जाता है टी थ्रेड क्लास है और यह स्टेट इंट है।
अब, तो यह एक बूलियन वैरिएबल स्टॉपफ्लैग है।
अब, हमारे द्वारा घोषित की गई इनिट विधि;
init विधियां मूल रूप से पृष्ठभूमि और अग्रभूमि को बदलने के लिए कुछ नहीं कर रही हैं।
इसलिए, पृष्ठभूमि के अग्रभूमि के रूप में हम इस तरह बदलते हैं।
और फिर यहां मूल रूप से प्रारंभ विधि है जिसे हमने यहां घोषित किया है।
प्रारंभ विधि में हम इस एप्लेट का धागा बनाते हैं।
तो, इस धागे का मतलब है, यह स्वतंत्र रूप से तब तक चलेगा जब तक आप इसे पसंद नहीं करते।
तो, यह मूल रूप से, स्टेट थ्रेड को परिभाषित करते हुए मूल रूप से बनाया गया है, जो कि थ्रेड का मतलब है कि ये इस एपलेट के धागे हैं, इसलिए एप्लेट धागा है।
और फिर stopFlag गलत है, इसका मतलब है कि इसे चलाया जाता है।
तो, अगर हम कुछ को क्लिक करते हैं, तो यह एक स्टॉपफ्लैग सही लाइन होगी। यहाँ विधि और t.start आप जानते हैं;
आप देखते हैं कि यह शुरुआत मूल रूप से थ्रेड शुरू कर रही है न कि एप्लेट स्टार्ट विधि की।
तो, यह पूरी तरह से अलग है क्योंकि आपके पास चलने योग्य उपकरण हैं।
तो, स्वचालित रूप से शुरू होगा;
इसका मतलब है, हम धागे के निष्पादन को शुरू करते हैं।
तो, एप्लेट की स्टार्ट विधि में, हम थ्रेड शुरू करते हैं।
यदि आप देखते हैं तो विधि चलाएं, यह वास्तव में यहां अधिक बुद्धिमान एक कोड है।
यह रन विधि क्या करती है यह मूल रूप से है, यहां शुरू में यह फिर से दब जाएगी, जो भी प्रत्याहार का अर्थ है प्रारंभिक पुनरावर्तन वहां है, फिर धागा 250 के लिए सोएगा, क्योंकि कुछ वजन वहां होना है।
इसलिए, वह उपयोगकर्ता नहीं कर सकता है, अन्यथा यदि आप लगातार बदलते हैं तो आप उस परिवर्तन को सही नहीं पा सकते हैं।
इसलिए, इसमें देरी हुई है।
तो, यह नींद का मतलब है, धागा बस कुछ भी किए बिना इंतजार करेगा और फिर चरित्र को संदेश से ठीक किया जाएगा;
इसका मतलब है, पात्रों के तार से तेज सुधारक और फिर यह मूल रूप से अगला संदेश है 1 के अधिकतम 1 के अगले सुधारक के प्रतिस्थापन का मुकाबला करके संदेश प्राप्त किया जाएगा।
तो, मूल रूप से हर बार, मान लीजिए स्वागत है;
इसलिए पहले चरित्र का स्वागत किया जाता है, फिर अगले विकल्प का मूल रूप से स्वागत है, इस तरह से स्वागत करने के बाद।
तो, यह मूल रूप से रन विधि होगी क्योंकि थ्रेड निष्पादित होगा।
तो, यह एक-एक करके, एक-एक करके आगे बढ़ेगा।
तो, यह सामने 1 से एक बार में 1 वर्ण लेगा, और फिर सबस्ट्रिंग प्राप्त करेगा, और फिर सबस्ट्रिंग को अगला प्रदर्शित किया जाएगा और फिर इसे मूल रूप से अपडेट किया जाएगा और इसे फिर से लिखा जा सकता है।
तो, इस तरह से अद्यतन और प्रत्यावर्तन पर जाना होगा और यह विचार है कि यह पहले ए है और फिर ए यहां आ जाएगा, फिर सरल चलती हुई यहां आएगी, फिर यह यहां आएगी और फिर दूसरे भाग में होगी और इस तरह से वह एपलेट चलना शुरू हो जाएगा।
इसलिए, अगर हम इसे चलाते हैं और फिर हम देख सकते हैं कि यह वास्तव में एप्लेट इस पर एक जीवन देता है और फिर एक सुंदर एक कार्यक्रम है जिसे आप इसे देख सकते हैं।
वैसे भी, जब भी हम धरना-प्रदर्शन देंगे, हम इसका अमल दिखाएंगे।
फिर यहां रुकें, इसलिए जब भी स्टॉप का मतलब कहें, मान लें कि उपयोगकर्ता इस एक का चयन करें।
तो, स्टॉप का आह्वान किया जाएगा और फिर स्टॉपफ्लैग सच है फिर धागा बंद हो जाएगा और फिर एप्लेट कि बैनर अपने निष्पादन को रोक देगा।
वैसे भी, इतना मूल विचार कि अलग-अलग विधियाँ, जो एक एप्लेट में हैं जैसे कि init, start, stop तत्पश्चात पेंट, अपडेट, इस सभी तरीकों को हम इस बारे में एक आइडिया देने की कोशिश करते हैं कि ये तरीके कैसे हैं।
और जब भी आप अलग-अलग एप्लिकेशन चलाते हैं, तो अलग-अलग प्रोग्राम आप भी नया कर सकते हैं, अलग-अलग एप्लेट को देखने का अलग तरीका।
और अधिक से अधिक, उन सभी चीजों को भी महान प्रभाव में आ जाएगा जब भी हम एक कैलकुलेटर विकसित करते हैं।
इसलिए, हमारे प्रदर्शन में ठीक यही देखा जाएगा कि कैसे उन सभी अग्रिम एपलेट को डिजाइन किया जा सकता है और फिर उन तरीकों का उपयोग किया जाएगा।
तो, ये वे विधियां हैं जिनके बारे में हमने वहां चर्चा की है और इसलिए ठीक है।
तो, ये अंतिम मानक विधियां हैं।
इन मानक तरीकों के अलावा, कई और तरीके भी हैं, कोई भी विधि भी हो सकती है, जिसे उपयोगकर्ता एप्लेट में लागू और जोड़ सकता है।
और उन सभी चीजों पर, जब भी हम एप्लेट प्रोग्रामिंग के बारे में अधिक अग्रिम विशेषताओं पर चर्चा करेंगे, हम चर्चा करेंगे।
धन्यवाद।
जावा प्रोफ़ेसर देवाशीस सामंत डिपार्टमेंट ऑफ़ कंप्यूटर साइंस इंजीनियरिंग इंडियन इंस्टीट्यूट ऑफ़ टेक्नोलॉजी, खड़गपुर लेक्चर - 13 इनहेरिटेंस में प्रोग्रामिंग इसलिए, इस व्याख्यान में हम एक महत्वपूर्ण वस्तु उन्मुख प्रतिमान पर चर्चा करेंगे जिसे इनहेरिटेंस कहा जाता है।
हमने एनकैप्सुलेशन पर चर्चा की है, फिर विरासत एक अन्य महत्वपूर्ण वस्तु उन्मुख प्रतिमान है;
आज के व्याख्यान में हम वंशानुक्रम के बारे में चर्चा करेंगे।
तो, पहले हमें अवधारणा के बारे में सीखना चाहिए और फिर यह अवधारणा मूल रूप से जावा प्रोग्राम में कैसे लागू हो सकती है। ।
तो, यह अवधारणा इस तरह है और फिर एकल वंशानुक्रम का अर्थ है, यदि यह केवल इकाई पर और कई विरासत से विरासत में मिला है, अगर एक इकाई कई संस्थाओं से विरासत में मिली है।
इसलिए, अवधारणा यह है कि दोनों एकल के साथ-साथ कई विरासत भी हैं और फिर विरासत में कई स्तरों के साथ पदानुक्रम भी हो सकता है;
इसलिए, बहु स्तरीय विरासत।
तो, बच्चों को माता-पिता से विरासत में मिला है, नाती-पोतों को इस तरह से बच्चों से विरासत में मिला है।
तो, ये कॉन्सेप्ट वास्तव में बहुत सामान्य है, यह वहां मौजूद है, लेकिन अभी तक जिस वस्तु का संबंध है वह अवधारणा भी है।
यहाँ उदाहरण के लिए, यदि हम विचार करते हैं कि पशु एक प्रकार की वस्तु है तो पशु की अन्य प्रकार की वस्तुएँ हैं।
इसलिए शाकाहारी, मांसाहारी इसे पसंद करते हैं, इसलिए यहां जानवर एक सामान्य है, जबकि शाकाहारी एक विशेष है और अगर हम शेर और लकड़बग्घा को देखें तो वे अधिक विशेष हैं।
तो, सामान्यीकृत से अधिक विशेषज्ञता तक विरासत की अवधारणा है और इसे आईएस-ए अवधारणा कहा जाता है;
इसका मतलब है, शेर एक जानवर है, लकड़बग्घा एक जानवर है;
तो, यह एक अवधारणा है।
इसलिए, उनका अनुसरण किया जाता है, वे मूल रूप से आईएस-ए संबंध से संबंधित हैं।
और कई पदानुक्रम हो सकते हैं;
इसका मतलब है, कि पदानुक्रम का मतलब है कि यह अलग स्तर में है।
अब, इसलिए इस अवधारणा को मूल रूप से एक वर्ग दिया जाता है जिसे हम आमतौर पर एक सुपर क्लास कहते हैं।
और, यदि हम इस वर्ग से एक और वर्ग बना सकते हैं तो इसे उप-वर्ग कहा जाता है।
यहाँ एक उदाहरण के रूप में हम देख सकते हैं कि वाहन एक सुपर क्लास है जबकि, CAR और TRUCK दो उप वर्ग हैं।
इसी तरह, FireTruck TRUCK वर्ग का एक और उपवर्ग है।
तो, यहाँ TRUCK
सब क्लास फायरट्रेक का सुपर क्लास है।
तो, यह मूल रूप से कहता है कि हम इसके सुपर वर्गों से विरासत में मिली कक्षाओं की संख्या बना सकते हैं।
अब विरासत की अवधारणा क्या है?
हम इस बात पर चर्चा करेंगे कि मूल रूप से एक उप वर्ग अपने मूल वर्ग से क्या प्राप्त करेगा।
अब, जावा प्रोग्राम में विरासत की यह अवधारणा बहुत महत्वपूर्ण है, यह इसलिए है क्योंकि पुन: प्रयोज्य है।
इसलिए, अगर हमारे पास एक ट्रक है, तो हम क्लास ट्रक के इस कोड को साझा कर सकते हैं, और फिर हम FireTruck में कुछ अन्य कोड को लागू कर सकते हैं, यह मूल रूप से कोड शेयर क्षमता या पुन: प्रयोज्यता यहां तक ​​कि रखरखाव, कोड मेंटेनेंस बहुत है महत्वपूर्ण पहलू जो विरासत की अवधारणा का उपयोग करके किया जा सकता है।
अब, एक वर्ग की विरासत कैसे संभव है।
तो, जावा प्रोग्राम में एक सिंटैक्स है।
एक वर्ग में वंशानुक्रम एक प्रमुख शब्द के माध्यम से संभव है जिसे विस्तार कहा जाता है।
तो, यहाँ वर्ग यह उपवर्ग का नाम है जिसे मूल रूप से आप विरासत में प्राप्त करना चाहते हैं।
और यह सुपर क्लास का नाम है जिसे यहां से आपको विरासत में प्राप्त करना है और यह मूल रूप से कोड या विधि या सदस्यों के अलावा उपवर्ग का कोड है जो इस उपवर्ग में है।
तो, यहाँ मूल रूप से सभी कोड जो कि सुपर क्लास में हैं, इस पद्धति में भी यहाँ सुलभ हैं।
तो इस तरह, मूल रूप से कोड पठनीयता का विचार तस्वीर में आता है।
तो, यह इस बारे में विचार है कि इन चीजों को विरासत का उपयोग करके किया जा सकता है।
अब हम कुछ उदाहरण देखते हैं, ताकि हम विरासत के बारे में इस विचार के बारे में समझ सकें।
बहुत सरल उदाहरण है, कि हम चर्चा करने जा रहे हैं मान लीजिए कि एक वर्ग है जिसे 2 डी बिंदु कहा जाता है।
तो, 2 डी बिंदु एक वर्ग है और हम 3 डी बिंदु नामक एक अन्य वर्ग को प्राप्त करना चाहते हैं।
इसका मतलब यह है कि 2 डी बिंदु, अगर इसमें कुछ सदस्य और विधियां हैं तो ये सभी सदस्य और विधि इस 3 डी बिंदु के लिए उपलब्ध हो सकते हैं या हम कह सकते हैं कि कुछ विधि को ओवरराइड किया जा सकता है;
इसका मतलब है कि, इस विधि में इसे फिर से परिभाषित किया जा सकता है।
अब, हम एक उदाहरण देखते हैं।
तो, यहाँ मूल रूप से एक क्लास पॉइंट 2 डी का विवरण है, इसमें दो सदस्य एक्स और वाई हैं और प्रदर्शन विधि है।
तो, ये इस वर्ग की रचना हैं।
अब, यहां प्वाइंट 3 डी जो मूल रूप से विरासत में मिला है, यह मूल रूप से प्वाइंट 3 डी है जो प्वाइंट 2 डी विरासत में मिला है।
तो, यह है तो यह सही किया जाना चाहिए यह Point2D है।
तो, प्वाइंट 3 डी, प्वाइंट 2 डी का विस्तार करता है;
इसका मतलब है कि, पॉइंट 3 डी को क्लास प्वाइंट 2 डी से विरासत में मिला है।
और, यहाँ हम देख सकते हैं कि हम पूर्णांक z को एक नए तत्व के रूप में घोषित करते हैं।
इसका मतलब यह है कि इस वर्ग के लिए पॉइंट 3 डी ये सभी चीजें जो वहां मौजूद हैं, यहां भी सुलभ हैं।
तो, इसका मतलब है कि xy और z तीनों सदस्य इस या इस वर्ग के सदस्यों के लिए उपलब्ध हैं Point3D।
आप इसे फिर से कैसे प्रदर्शित कर सकते हैं कि प्रदर्शन विधि जो कि प्वाइंट 3 डी में है, वह भी वहीं है।
हालांकि, जो विधि यहां और वहां परिभाषित की गई है, वे अलग हैं।
इसका मतलब है कि यह डिस्प्ले सुपर क्लास मेथड डिस्प्ले को ओवरराइड करता है।
अब, दूसरी ओर यदि हम डिस्प्ले 1 और डिस्प्ले 2 कहते हैं तो दो विधियाँ हैं और यहाँ इस परिवर्तन के साथ, यह क्या विचार है कि xy इस वर्ग के लिए उपलब्ध है।
इसी तरह, डिस्प्ले 1 इस विधि के लिए भी सुलभ है।
तो, यह मूल रूप से एक पॉइंट 2 डी है एक सामान्यीकरण अवधारणा एक सामान्य है, फिर पॉइंट 3 डी एक विशेष है;
इसका मतलब है कि, यह प्वाइंट 2 डी के अलावा कई और चीजें हैं।
तो, यह विरासत की अवधारणा है।
और यह स्पष्ट रूप से, एकल विरासत का एक उदाहरण है और जैसा कि यह एक बहुत ही सरल उदाहरण है जिसे हम आमतौर पर इसे साधारण विरासत उदाहरण ठीक कहते हैं।
तो, यह सरल विरासत के बारे में विचार है।
सरल विरासत और यहाँ एक मुख्य विधि है जिसे आप घोषित कर सकते हैं।
अब यदि आप इस विधि को थोड़ा ध्यान से देख सकते हैं तो आप देख पाएंगे कि ये ऐसी वस्तुएं हैं जिन्हें हमने 2D क्लास प्वाइंट 2 डी और प्वाइंट 3 डी के लिए बनाया है।
और ये मूल रूप से आरंभिक हैं।
इसी प्रकार, यहाँ बिंदु 3 का आरंभीकरण मूल रूप से बिंदु 2 ठीक है।
तो, यह मूल रूप से पॉइंट 2 का प्रारंभिककरण है।
अब, यहाँ यदि आप पी 2 को कक्षा में एक बिंदु के रूप में देखते हैं तो मूल रूप से पॉइंट 3 डी एक्सई सुलभ है।
तो, यह विचार है कि आभासी विरासत के माध्यम से सभी सदस्य और विधियाँ उपवर्ग की वस्तु के साथ सुलभ हैं।
इसलिए, यह उस साधारण विरासत का एक उदाहरण है जिसकी हमने चर्चा की है।
अब, हम जल्दी से इस बारे में चर्चा करते हैं कि विभिन्न प्रकार के वंशानुक्रम क्या हैं जो कि जावा प्रोग्राम में संभव है।
तो, इसे मल्टी लेवल सिंगल इनहेरिटेंस भी कहा जाता है।
इस बहुस्तरीय सिंगल इनहेरिटेंस के अलावा मल्टीपल इनहेरिटेंस नामक एक अवधारणा है।
एक उदाहरण के लिए यह वर्ग इस और इस से विरासत में मिला है।
इसलिए, यदि कोई वर्ग दो वर्गों से विरासत में मिला है, तो यह कई उत्तराधिकारियों का उदाहरण है।
और, यहां मूल रूप से हाइब्रिड उदाहरण है। उदाहरण के लिए;
यह वर्ग इस एक से विरासत में मिला है।
इसलिए, ये एकल हैं, लेकिन यह वर्ग इस से विरासत में मिला है।
तो, इसे हाइब्रिड इनहेरिटेंस कहा जाता है, जिसका अर्थ है कि दोनों एकल सरल और साथ ही कई विरासत भी हैं।
अब हालांकि, सुपर जावा प्रोग्रामिंग का संबंध है कि सभी उत्तराधिकार संभव नहीं हैं, बल्कि जावा में हमारे पास केवल एक विरासत है, कई एकल विरासत, बहु स्तरीय एकल विरासत संभव हैं।
जबकि, अन्य दो संभव नहीं हैं जावा कई विरासत के साथ-साथ संकर विरासत का समर्थन नहीं करता है।
तो, विरासत के माध्यम से हम यह एक हो सकता है।
अब, यहां त्वरित जावा प्रोग्रामिंग इस की हमारी प्रोग्रामिंग अवधारणा पेश करती है।
एक उदाहरण के रूप में हम एक वर्ग व्यक्ति के बारे में कह सकते हैं कि हमने जो कुछ भी विचार का उल्लेख किया है उसे हमने जावा कोड में लिखा है जैसे कि ओके।
आप उस आकृति चित्रों से संबंधित हो सकते हैं, जिसे हमने अंतिम स्लाइड में दिखाया है जो मूल रूप से इस एक से संबंधित है।
यह एक वक्र वर्ग है व्यक्ति एक सामान्य वर्ग है और अब छात्र वर्ग को परिभाषित किया जा सकता है।
इसलिए, यह व्यक्ति हमारे पास है तो हमारे पास छात्र वर्ग हो सकता है जो मूल रूप से व्यक्ति वर्ग का विस्तार करता है;
तो, यह वहाँ है।
इसके बाद, इस तरह से व्यक्ति वर्ग के बारे में घोषित किया जा सकता है और अब यहाँ आप प्रिंटडाटा देख सकते हैं जो इस पद्धति में घोषित किया गया है, यहाँ भी इस तरह से छात्र वर्ग के बायोडाटा को प्रिंट करने के लिए उपयोग किया जाता है।
अब तो, यह वह क्लास स्टूडेंट है जिसे क्लास पर्सन से विरासत में मिला है।
यहां एक उदाहरण के लिए, हम मुख्य विधि का उपयोग करते हैं जहां वर्ग की विभिन्न वस्तुओं को व्यक्तिगत रूप से घोषित किया जा सकता है जैसे कि वे अपने स्वयं के नए वर्ग हैं।
तो, इस तरह एकल वंशानुक्रम संभव है।
अब, इनहेरिटेंस पर विचार करें जैसे कि यह बहुत सरल है यह समझना बहुत मुश्किल नहीं है कि जावा इस बात को इतना सरल क्यों बनाता है।
केवल एकल वंशानुक्रम की अनुमति देना और इस विरासत को दूसरे स्तर पर जाना जा सकता है।
यही बात अगर मैं कहता हूं कि नियमित कर्मचारी कर्मचारी का विस्तार करता है, तो स्थायी कर्मचारी अस्थायी कर्मचारी कर्मचारी का विस्तार करता है।
इसलिए, कि अन्य दो अलग-अलग वर्गों को कर्मचारी से विरासत में मिला हिस्सा निजीकरण से विरासत में मिला है।
इसलिए, इस तरह से विस्तार की किसी भी सीमा तक कोई सीमा नहीं है।
अब, यहां एक और अच्छा उदाहरण है, ताकि आप इसके बारे में समझ सकें।
तो, कई ज्यामितीय वस्तुएं हैं।
तो, सभी ऑब्जेक्ट सामान्य प्रकार के होते हैं और फिर वे एक विशेष प्रकार हो सकते हैं।
तो उदाहरण के लिए, 1 डी ऑब्जेक्ट 2 डी ऑब्जेक्ट 3 डी ऑब्जेक्ट।
दूसरी तरफ अगर हम 3D ऑब्जेक्ट पर विचार करते हैं तो वे फिर से अलग प्रकार के होते हैं, 2D ऑब्जेक्ट ये अलग प्रकार के होते हैं, 1 डी ऑब्जेक्ट भी अलग प्रकार के होते हैं।
अब, आगे क्या विशेषज्ञता भी कहा जाता है किया जा सकता है।
उदाहरण के लिए, 2D वस्तु त्रिभुज चतुर्भुज और इसी तरह आगे विशेषज्ञता की हो सकती है;
चतुर्भुज शायद एक और विशेषज्ञता आयत, इस एक समांतर चतुर्भुज।
अब, इस तरह की विरासत पदानुक्रम;
अब यदि आप सभी ज्यामितीय वस्तुओं के हेरफेर के लिए एक प्रोग्राम बनाना चाहते हैं, तो पहले हम जियोऑब्जेक्ट बना सकते हैं
मूल रूप से इसमें सभी सामान्य विशेषताएं हैं।
फिर जो भी विशेष गुण धीरे-धीरे अपने विरासत वर्गों में जोड़े जा सकते हैं।
और फिर अंत में, निचले स्तर पर कक्षाएं प्राप्त की जा सकती हैं, वे मूल रूप से अधिक परिष्कृत या अधिक विशिष्ट वर्ग हैं जिन्हें आपकी समस्या को हल करने की आवश्यकता है।
तो, यह एक अवधारणा है जिसका पालन वहां किया जाता है और अब आप उन सभी प्रकार की वस्तुओं को लागू करने के लिए कार्यक्रम लिख सकते हैं जिन्हें हमने केवल इस वर्गीकरण में सूचीबद्ध किया है।
तो, इस अवधारणा को इस तरह बढ़ाया जा सकता है।
अब, हम एक अवधारणा के बारे में चर्चा करेंगे जो विधि अधिभार है।
प्वाइंट 2 डी से विरासत में मिली प्वाइंट 3 डी के उदाहरण में, हमने विधि ओवरराइडिंग के बारे में चर्चा की है;
इसका मतलब है, कि वे वहाँ एक विधि प्रदर्शन है जो मूल रूप से दोनों वर्गों में परिभाषित किया गया है।
यदि हम एक ऐसी विधि की घोषणा करते हैं जो पहले से ही एक सुपर क्लास में परिभाषित की जाती है तो विधि जिसे ओवरराइडिंग विधि कहा जाता है।
इसका मतलब है कि आपको विधि को ओवरराइड करना होगा।
तो, इस अवधारणा को एक विधि अधिभावी कहा जाता है।
इसलिए, इसे ओवरराइड करने की विधि मूल रूप से आवश्यक है कि जिस पद्धति को हमने एक सुपर क्लास में घोषित किया है वह कभी-कभी हमें यहां फिर से परिभाषित करने की आवश्यकता हो सकती है।
इसलिए, यदि हम यह करना चाहते हैं कि यदि फिर से परिभाषित किया जाए तो हम इसे इस तरह कर सकते हैं।
इसलिए, यह पिछले उदाहरण का फिर से जारी है जिसके बारे में हमने चर्चा की है।
यहाँ प्रदर्शन विधि जो यहाँ घोषित की गई है, ये डिस्प्ले मूल रूप से इन डिस्प्ले को ओवरराइड करती है और फिर हम इसे यहाँ इस प्रोग्राम में उपयोग कर सकते हैं क्योंकि हम देख सकते हैं कि यह यहाँ है।
तो, इस विधि के रूप में हम कर सकते हैं आप यहाँ इस विधि को देख सकते हैं जैसा कि आप यहाँ देख सकते हैं।
तो, प्वाइंट 2 डी पी 2 डी क्लास का प्वाइंट है और प्वाइंट 3 डी क्यू 3 डी क्लास का प्वाइंट है।
और, यहाँ आप देख सकते हैं x एक और वर्ग है जिसे हमने बनाया है जो मूल रूप से कास्टिंग है;
इसका मतलब है, क्यू 3 डी का एक बिंदु है, लेकिन हम इस तरह की विशेष सुविधाओं का उपयोग करके 2 डी में डाल सकते हैं।
इसलिए, टाइपकास्टिंग हम बाद में यहाँ पर विवरणों पर चर्चा करेंगे।
तो, तब x डॉट प्रदर्शन तब यह मूल रूप से हम इस वर्ग के प्रदर्शन विधि को कॉल करेंगे, हालांकि q में यह ओवरराइडिंग है।
तो, यह इस तरह से है कि हम इस एक का उपयोग कर सकते हैं इस अवधारणा को गतिशील बंधन कहा जाता है।
तो, डायनेमिक बाइंडिंग एक प्रकार का रनटाइम है जिसे स्कोप नियम कहा जाता है।
इसलिए, गुंजाइश तय की जाएगी, जिसमें से, क्योंकि अगर हम दूसरों के साथ कास्ट करेंगे तो बाइंडिंग अलग और इसी तरह होगी।
इसलिए, इन गतिशील को हमारे व्यावहारिक वर्ग में प्रदर्शित किया जाएगा;
इसलिए, हम इन सुविधाओं को अधिक स्पष्ट रूप से समझ सकते हैं।
इसलिए, यह विधि के बारे में यह विचार है कि यह वहां है।
अब, विरासत में मिली इस अवधारणा के बारे में एक बात जो हमें ध्यान देनी चाहिए कि एक उपवर्ग ऑब्जेक्ट सुपर क्लास चर या विधि का उल्लेख कर सकती है यदि यह ओवरराइड नहीं है।
इसका मतलब है, सभी विधियाँ और चर उपवर्ग के लिए सुलभ हैं यदि यह उस वर्ग में ही परिभाषित नहीं है।
दूसरी ओर एक सुपर क्लास;
इसका मतलब है कि रिवर्स संभव नहीं है।
इसका मतलब है, सुपर क्लास किसी भी वैरिएबल या किसी भी तरीके का उपयोग नहीं कर सकती है जो उपवर्ग में परिभाषित है।
तो, एक तरह से यह वास्तव में यातायात है।
इसलिए, हम केवल उपवर्ग प्लेटफॉर्म से ही प्रवेश कर सकते हैं, लेकिन सुपर क्लास प्लेटफॉर्म से सुपर विधि के अलावा सुपर क्लास को परिभाषित करने वाले चर हैं जो हम उपवर्ग से कुछ भी एक्सेस नहीं कर सकते हैं।
अब, एक और बहुत महत्वपूर्ण अवधारणा है, इसे सुपर कीवर्ड कहा जाता है जो मूल रूप से कई उद्देश्य के लिए उपयोग किया जाता है।
तो, सुपर कीवर्ड के कई निहितार्थ हैं;
जावा में सुपर कीवर्ड का उपयोग करने वाला तत्काल माता-पिता वर्ग चर का उल्लेख कर सकता है।
वे मूल रूप से हैं, परिवर्तनशीलता है;
सुपर इस कीवर्ड का उपयोग पैरेंट क्लास विधि को लागू करने के लिए भी किया जा सकता है और सुपर का उपयोग पेरेंट क्लास कंस्ट्रक्टर को इनवाइट करने के लिए भी किया जा सकता है।
तो, इस सुपर क्लास के कई उपयोग हैं।
हमारी बाद की स्लाइड्स में हम देखेंगे कि कैसे सुपर क्लास तीन अलग-अलग सुविधाओं की सेवा कर सकता है:
संदर्भ चर, संदर्भ विधि और निर्माणकर्ता को संदर्भित करते हैं जो वहां सुपर क्लास में हैं।
अब, यह एक उदाहरण है यदि आप इस उदाहरण को थोड़ा ध्यान से देख सकते हैं, तो आप समझ पाएंगे कि यह मूल रूप से सुपर कीवर्ड का उपयोग करके एक उदाहरण है, जहां हम एक उदाहरण चर के मूल वर्ग का उल्लेख कर सकते हैं।
अब, हम इस उदाहरण में देखते हैं कि हम देख सकते हैं कि यह रंग एक चर है जिसे एक वर्ग के जानवर में घोषित किया गया है और कुत्ता एक अन्य वर्ग है जो पशु को विस्तारित करता है और कुत्ते वर्ग में हम फिर से रंग चर घोषित कर सकते हैं।
तो, यह रंग मूल रूप से ओवरराइड चर है;
इसका मतलब है, यह रंग और यह रंग उनके पास दो अलग-अलग क्षेत्र हैं।
अब, यहां अगर हम सुपर क्लास में देखते हैं तो चर का रंग सफेद है, जबकि सफेद है, जबकि कुत्ते का रंग काला है।
अब, प्रिंट रंग विधि में जो मूल रूप से क्लास डॉग में नए तरीके हैं, मूल रूप से अगर हम इस रंग को देखें तो यह इस रंग को संदर्भित करता है।
लेकिन, अगर हम यह उल्लेख करना चाहते हैं कि यह रंग मैं उल्लेख करना चाहता हूं जो सुपर से संबंधित हैं तो मुझे सुपर लिखना चाहिए। रंग।
तो, यह सुपर डॉट रंग इस मूल्य को संदर्भित करेगा जबकि, यह रंग इस एक को संदर्भित करेगा।
अब, इस प्रकार की अवधारणा होने से अब हम देखते हैं कि यह मूल रूप से मुख्य कार्यक्रम पर है।
तो, यहाँ इस प्रकार के ऑब्जेक्ट्स को टाइप करें और फिर d.printColor हम इसे कॉल करेंगे और जब भी इसे कॉल करेंगे तब यह मूल रूप से आउटपुट दिखाएगा जो इस तरह दिखेगा।
इसलिए, आउटपुट इस पहले प्रिंट रंग काले के कारण है, क्योंकि यह एक और फिर सुपर रंग सफेद है।
तो, ये दो आउटपुट हैं।
तो, यह एक अवधारणा है कि सुपर कीवर्ड का उपयोग मूल वर्ग उदाहरण चर को संदर्भित करने के लिए किया जाता है।
अब, यह यह है एक और भी इसका उपयोग है
पैरेंट क्लास वेरिएबल को संदर्भित करने की तरह कहा जाता है, सुपर को पेरेंट क्लास विधि का संदर्भ देने के लिए भी इस्तेमाल किया जा सकता है।
विधि यह है कि अवधारणा पिछले एक के समान है।
अब, फिर से इस उदाहरण को देखें कि यहां जानवर एक और वर्ग है, जिसके पास खाने की विधि है।
फिर से कुत्ते में जो सुपर क्लास जानवर के उपवर्ग में विरासत में मिला है, इसे भी खाने की घोषणा की।
इसका मतलब है, कि यह विधि मूल रूप से इस एक से अधिक की विधि है।
तो, इस विधि का अपना एक तरीका है जो वर्ग के कुत्ते के दायरे में है और इस पद्धति में इस तरह का प्रिंट स्टेटमेंट है।
अब, छाल उनकी पूरी तरह से नई विधि है और यह काम भी एक अन्य विधि है जो इसे परिभाषित किया गया है।
तो, छाल और काम वर्ग कुत्ते में नव जोड़ा विधि है।
अब, जहाँ भी अब आप कार्य पद्धति को देखते हैं जो कि क्लास डॉग में एक नई विधि है जिसे यह कहते हैं।
अब, super.eat () आप समझ सकते हैं कि इसका क्या मतलब है।
इसका मतलब है कि यह इस तरह की विधि है जबकि, छाल हमेशा की तरह है क्योंकि कोई संकल्प नहीं है और फिर यह मूल रूप से यह एक है।
तो, ये मूल रूप से नामस्थान को हल करते हैं।
तो, खाओ विधि इस के अंतर्गत आता है अगर यह सुपर डॉट द्वारा उपसर्ग है और ये विधि है।
इसलिए, इस सुपर विधि का उपयोग करते हुए हम यह उल्लेख कर सकते हैं कि यह विधि सुपर क्लास विधि की है या ओवरक्लास पद्धति की है यदि यह ओवरराइड है।
और, यह इस एक बहुत ही सरल का एक उदाहरण है जिसे आप समझ सकते हैं कि डी ऑब्जेक्ट बनाया गया है और d.work () है, अगर हम कहते हैं कि आप अनुमान लगा सकते हैं कि यह आपको क्या आउटपुट देना चाहिए;
जाहिर है, आप जांच कर सकते हैं कि यह आपको किस आउटपुट को देना चाहिए।
तो, कुत्ते सुपर काम करते हैं।
खाओ () यह मूल रूप से तब खा रहा है, इसे भौंकना और फिर महान खाना फिर से खाना।
अब, यह सुपर क्लास के उपयोग का एक और उदाहरण है जो मूल रूप से मूल वर्ग निर्माता का आह्वान कर रहा है।
हम अपने बाद के कार्यक्रम में इस तरह के निर्माण का अक्सर उपयोग करेंगे।
तो, हमें इसे बहुत ध्यान से समझना चाहिए फिर से यह एक सुपर क्लास है, इसमें एक कंस्ट्रक्टर जानवर है।
तो, यह सुपर क्लास कंस्ट्रक्टर है, कुत्ता एक अन्य वर्ग है जिसे विरासत में मिला है
जानवर में सुपर वर्ग।
तो, यह जानवर का एक उपवर्ग है और यहाँ अगर हम देखते हैं कि कुत्ता एक निर्माता है।
और, यह ड्रा कंस्ट्रक्टर हम सुपर का उपयोग करते हैं।
इसका मतलब यह है कि अगर हम इस कहने का उपयोग करते हैं कि कुत्ते को सुपर क्लास कंस्ट्रक्टर भी कहा जाएगा, तो यहां पशु कहा जाता है।
इसलिए, मूल रूप से अगर हम इसे लिख रहे हैं तो इसका मतलब है कि यह एक सुपर क्लास कंस्ट्रक्टर है, जिसे यहां बुलाया गया है और फिर अंत में, अपने तरीके से कुत्ते को।
तो, इसका मतलब यह है कि इस कंस्ट्रक्टर में हमारे पास दो प्रिंट स्टेटमेंट हैं और यह एक है।
अब, यदि हम इस परीक्षण मामले को चलाते हैं और फिर यदि हम इसे चलाते हैं तो आप देख सकते हैं कि इस प्रकार का आउटपुट आपको मिल सकता है।
पशु बनाया जाता है और कुत्ता बनाया जाता है क्योंकि ये दो चीजें हैं।
तो, यह सुपर के उपयोग की अवधारणा है यहां सुपर कीवर्ड;
इसलिए, अगर हम कोष्ठक के भीतर सुपर लिखते हैं, तो यह इंगित करता है कि यह मूल रूप से मूल वर्ग निर्माता को बुलाएगा।
तो, सुपर हम देख सकते हैं कि सुपर एक बहुत ही महत्वपूर्ण कीवर्ड है।
हमने पहले इस तरह के कुंजी शब्द का उपयोग किया है और फिर एक और महत्वपूर्ण शब्द नया भी।
इसलिए, ये नए और सुपर बहुत महत्वपूर्ण कीवर्ड हैं, हम बाद में कुछ और कीवर्ड भी समझेंगे।
अब, यह माता-पिता को सुपर का उपयोग करके एक पैरेंट क्लास कंस्ट्रक्टर को लागू करने का एक और उदाहरण है।
यह उदाहरण पिछले उदाहरण के समान है, पिछला उदाहरण बहुत सरल था।
यहां आप देख सकते हैं कि प्वाइंट 2 डी सुपर क्लास है, 3 डी एक उपवर्ग है और यहां जब भी हम एक निर्माता प्वाइंट 3 डी बनाते हैं तो हम इसका निर्माण करेंगे;
इसका मतलब है, हम कर सकते हैं।
अभी,
यहां आप फिर से ध्यान दें कि प्वाइंट 2 डी में दो कंस्ट्रक्टर हैं।
तो, सुपर अगर हम कहते हैं तो यह किस निर्माता को संदर्भित करेगा, वास्तव में यह इस बात पर निर्भर करता है कि किस तरह के तर्क हैं।
यदि हम इस तरह के तर्क को कहते हैं तो यह मूल रूप से उस निर्माता को प्रतिबिंबित करता है जो इसके तर्क से मेल खाता है।
उदाहरण के लिए, यहां सुपर एक डिफ़ॉल्ट निर्माता है।
दूसरी ओर हम लिख सकते हैं कि सुपर इन का उपयोग करते हुए कहते हैं कि तीन अलग-अलग मूल्य हैं;
फिर उस कंस्ट्रक्टर को यहां बुलाया जाएगा।
इसलिए, यह पार्सिंग उचित तर्क का उपयोग करने पर निर्भर करता है जो उस कंस्ट्रक्टर से मेल खाता है, अब सुपर में उस कंस्ट्रक्टर को संदर्भित करेगा।
तो, यह सुपर कंस्ट्रक्टर के बारे में विचार है।
और जब भी हम इस तरह की विरासत का उपयोग करते हैं तो एक बहुत ही महत्वपूर्ण अवधारणा यह है कि गतिशील विधि संकल्प।
तो, यह अवधारणा मूल रूप से रनटाइम बहुरूपता है यदि हम कई ऑब्जेक्ट बनाते हैं, तो कई ऑब्जेक्ट कई ऑब्जेक्ट अंत में होते हैं, जो विधि से संबंधित है जो कि ऑब्जेक्ट को थोड़ा भ्रमित करता है।
तो, यह भ्रम ठीक होने से बचा जा सकता है, अगर आप इस अवधारणा को थोड़ा ध्यान से समझ सकते हैं।
यह इस पद्धति से इस पद्धति में बदल गया।
तो, इसे एक रनटाइम बहुरूपता कहा जाता है और इसमें कई उपयोग हैं, उन उपयोगों पर हम चर्चा करेंगे जब पैकेज और अन्य के बारे में चर्चा करेंगे।
इसलिए, यदि हमें कई वस्तुओं को एक सरणी में संग्रहीत करना है और फिर विभिन्न प्रकार की वस्तुओं को रखना है तो बेहतर विचार यह है कि वह सरणी कर सकता है
सुपर क्लास ऑब्जेक्ट प्रकार x घोषित किया जाता है।
और, फिर अगर इसे सुपर क्लास घोषित किया जाता है तो किसी भी उपवर्ग वस्तु को उस या सरणी में रखा जा सकता है और यह अलग-अलग वस्तु के बावजूद y में प्रक्रिया हो सकती है।
तो, यह जावा में रनटाइम बहुरूपता का एक अच्छा उदाहरण है।
अब, यह एक और उदाहरण है आप अनुमान लगा सकते हैं कि यह आपके लिए क्या आउटपुट देगा।
तो, ए यह एक सुपर क्लास है, यह एक व्युत्पन्न वर्ग, विरासत में मिला वर्ग, उपवर्ग है और यह मुख्य तरीका है और आप समझ सकते हैं कि यह कैसे हो सकता है।
तो, आप बस इस बिंदु को देखें और फिर आप उत्तर देने का प्रयास कर सकते हैं तब आप समझ सकते हैं कि आपने इसे समझा है या नहीं।
इसलिए, यदि आप इसे इस प्रोग्राम को चलाते हैं और यह इस तरह का आउटपुट देगा, जिसे आप कह सकते हैं और आप इसे हल कर सकते हैं कि यह मूल रूप से इस तरह का आउटपुट कैसे दे रहा है।
तो, यह मूल रूप से इस बारे में विचार है कि यदि वंशानुक्रम है, तो आपको इस बारे में थोड़ा स्पष्ट होना चाहिए कि कैसे अलग-अलग विधि को कहा जाता है।
तो, अमूर्त वर्ग मूल रूप से वह वर्ग है जिसमें स्पष्ट रूप से परिभाषित होने की कोई विधि नहीं है या विधि को किसी भी कोड के बिना शून्य के रूप में रखा जा सकता है।
अब, सार
वर्ग के रूप में इसके पास कोई कोड या कोई अन्य चीज नहीं है।
इसलिए, उस वर्ग की कोई भी वस्तु नहीं बनाई जा सकती है।
तो, इसके कुछ गुण हैं जैसे और अमूर्त वर्ग यह एक विशेषक के माध्यम से घोषित किया जाता है जिसे सार कहा जाता है।
और, इसमें फिर से अमूर्त विधि और गैर-अमूर्त विधि हो सकती है।
सभी विधि जो हमने अब तक चर्चा की है, गैर-सार;
यदि कोई विधि अमूर्त खोजशब्द के साथ उपसर्ग करती है तो उसे अमूर्त विधि कहा जाता है।
इसका तात्पर्य यह नहीं हो सकता है कि एक अमूर्त वर्ग के लिए कोई वस्तु नहीं बनाई जा सकती है।
और, इसकी अंतिम विधि हो सकती है यदि सार वर्ग में अंतिम विधि है तो वह वस्तु नहीं हो सकती है क्योंकि यह विधि अपने व्युत्पन्न वर्ग में अतिप्राप्त नहीं हो सकती है।
तो, यह अमूर्त वर्ग के बारे में विचार है और फिर, अमूर्त वर्ग इस तरह है।
इसलिए, यदि हम एक विधि की घोषणा कर सकते हैं तो कोई उद्देश्य नहीं बनाया जा सकता है, लेकिन इसका उपयोग इसके लिए कई वर्गों को प्राप्त करने के लिए किया जा सकता है।
यह मूल रूप से एक टेम्पलेट देता है, टेम्पलेट का अर्थ है यह एक सामान्यीकरण एक अवधारणा है कि यह वह है जिसका अंतिम कार्यान्वयन तब होगा जब हम उपवर्ग प्राप्त करेंगे।
फिर अंतिम कीवर्ड:
अंतिम कीवर्ड बहुत ही एक सख्त कीवर्ड है जिसे हम कह सकते हैं कि यदि हम एक अंतिम घोषित कर सकते हैं, तो इस अंतिम वर्ग का उपयोग विरासत के लिए नहीं किया जा सकता है।
इसलिए, कोई भी वर्ग अंतिम वर्ग से नहीं लिया जा सकता है, जिसका अर्थ है कि अंतिम वर्ग एक सुपर क्लास नहीं हो सकता है।
और, अंतिम के रूप में एक वर्ग की घोषणा के अलावा, हम किसी वर्ग में किसी भी विधि को अंतिम रूप में भी घोषित कर सकते हैं।
यदि हम एक चर को अंतिम घोषित करते हैं, तो उस चर को किसी भी व्युत्पन्न वर्ग में अधिभूत नहीं किया जा सकता है।
और, यदि किसी विधि को अंतिम घोषित किया जाता है, तो उसी विधि को किसी भी वर्ग की वस्तुओं में ओवरराइड नहीं किया जा सकता है।
तो, इस अर्थ में अंतिम रूप से कि यह मूल रूप से किसी भी व्युत्पन्न वर्ग में अधिक कार्यान्वयन संभव नहीं है।
इसलिए, हमने उन मूल अवधारणाओं के बारे में चर्चा की है जो जावा कार्यक्रमों में कक्षाओं की विरासत से संबंधित हैं।
अब, कई और प्रश्न हैं जिनका उत्तर बाद की कक्षाओं में दिया जा सकता है।
उदाहरण के लिए, क्या आप अन्य वर्ग से एक वर्ग प्राप्त कर सकते हैं जो अन्य पैकेज में परिभाषित है?
अब, यहाँ पहले पैकेज की अवधारणा सीखनी चाहिए;
इसलिए,
कि हम इस प्रश्न का उत्तर दे सकते हैं।
और, फिर जानकारी छिपाना जो एक और लंबित काम पर है जिसे हम अपने अगले व्याख्यान घंटों में चर्चा करेंगे।
आपका बहुत बहुत धन्यवाद।
कंप्यूटर विज्ञान इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर व्याख्यान में जावा प्रो। देबासीस सामंता विभाग में प्रोग्रामिंग, 05 जावा एप्लेट प्रोग्रामिंग तो, हमने कुछ कार्यक्रम चलाए हैं और फिर उन्हें जावा वातावरण में कैसे बनाया जा सकता है।
तो, शुरू में आपको इसका सामना करना मुश्किल हो सकता है, लेकिन आपको अपना खोना नहीं लिखना चाहिए, अब तक जावा एप्लेट प्रोग्रामिंग का संबंध है, मूल रूप से हां, एप्लेट के लिए जावा प्रोग्रामिंग।
इसलिए, जैसा कि मैंने आपको बताया था कि प्रोग्रामिंग दो प्रकार की होती है, जो अनुप्रयोग आपने पहले ही सीख लिया है।
और फिर अनुप्रयोग सबसे सरल सरल प्रोग्राम हैं वास्तव में वे मूल रूप से उदाहरण के लिए हैं, सी सी ++ अजगर जो आपने पहले ही परीक्षण कर चुके हैं, लेकिन एप्लेट थोड़ा सा है
[difficu / कठिन] विभिन्न प्रकार के कार्यक्रम।
और फिर जावा एक अद्वितीय कार्यक्रम भाषा है जो मूल रूप से ऐसा करने के लिए मानती है।
तो, एप्लेट नाम वास्तव में जब भी आप कुछ छोटा उल्लेख करना चाहते हैं, तो यह मूल रूप से देर हो चुकी है।
तो, छोटे अनुप्रयोग को जावा एप्लेट कहा जाता है।
तो, यह मूल रूप से जावा एपलेट कुछ भी नहीं है, लेकिन जावा में एक छोटा कार्यक्रम है, लेकिन अधिक विशेष रूप से ये छोटे कार्यक्रम हैं ग्राफिकल यूजर इंटरफेस संबंधित प्रोग्राम लिखने के लिए।
अब, तो एप्लेट मूल रूप से भी एक दृश्य है और फिर हम जावा का उपयोग करके एक दृश्य कैसे बना सकते हैं यह अवधारणा जावा एप्लेट प्रोग्रामिंग है।
और आम तौर पर एक जावा एप्लेट इस तरह दिखाई देगा और यदि आप जावा एप्लेट देखते हैं तो यह केवल एक विंडो जैसा दिखता है।
तो, एक एप्लेट एक खिड़की के अलावा कुछ भी नहीं है।
जैसा कि विंडो मूल रूप से एक बार है जिसे टाइटल बार कहा जाता है।
और फिर खिड़कियों का एक नाम है और फिर ये मूल रूप से खिड़कियों का प्रदर्शन क्षेत्र है।
तो, यह एक एप्लेट के बारे में विचार है और फिर एप्लेट यह एक एपलेट का बहुत सरल संस्करण है जो मैंने आपको दिखाया है और यहां आप छवि को शामिल कर सकते हैं, फिर मल्टीमीडिया दस्तावेज़ पाठ लिंक जो नहीं है।
तो, यह मूल रूप से प्रदर्शन क्षेत्र है, जहां हम कई घटकों को शामिल कर सकते हैं, जो कि जीआई या विंडोज़ प्रोग्रामिंग के मामले में आवश्यक है।
अब, इसलिए हम एक सरल एप्लेट के लिए एक प्रोग्राम लिखते हैं, मैं एक एप्लेट लिखना चाहता हूं, जो मूल रूप से हम एक संदेश हैलो दुनिया प्रदर्शित करेंगे जो हमने पहले से ही सीखा है कि कैसे एक हैलो सभी को स्क्रीन पर सही विंडो में दिखाया जा सकता है, कमांड विंडो , सही कमाण्ड।
लेकिन, यहाँ यह एक एप्लेट के माध्यम से प्रदर्शित करेगा;
इसका मतलब है, खिड़की पर और खिड़की के भीतर स्ट्रिंग होगी।
अब, यहां कार्यक्रम का बहुत छोटा रूप है और यहां वास्तव में जहां कमांड रखा जा सकता है।
तो, यह प्रोग्राम के बारे में मूल रूप से कमांड है।
इसलिए, कि आप आमतौर पर जब भी लिखते हैं, तो प्रोग्राम को अधिक से अधिक कमांड डालते हैं, ताकि आप बाद में समझ सकें या कोई भी आपके प्रोग्राम को समझ सके, इसलिए कमांड और ये दो आवश्यक आयात हैं जो मैंने आपको बताया कि जावा में बहुत सारे पैकेज हैं।
यदि आप कुछ पैकेज या पैकेज का उपयोग करना चाहते हैं, तो उन्हें पहले आयात किया जाना चाहिए।
इसलिए, यहां आयात कमांड मूल रूप से उन सभी पैकेजों को आयात करने के लिए है, जिन्हें आप अपने प्रोग्राम में उपयोग करना चाहते हैं।
जावा एप्लेट प्रोग्रामिंग के लिए दो पैकेज बहुत आवश्यक होते हैं एक को java.applet और दूसरे को java.awt कहा जाता है।
तो, यहां आप देख सकते हैं कि कैसे दो पैकेज जावा डॉट एपलेट और java.awt आयात कर सकते हैं।
और अगर मैं पैकेजों के नाम के बाद फिर से लिखता हूं, तो java.applet या java.awt एक विशेष नाम यह वास्तव में एक विशेष वर्ग है, जावा डॉट एपलेट में कई कक्षाएं हैं, लेकिन मैं केवल एक विशेष वर्ग का उपयोग करना चाहता हूं, इसलिए डॉट एप्लेट का उल्लेख कर सकते हैं।
इसी तरह, awt में मैं केवल एक पैकेज क्लास का उल्लेख करना चाहता हूँ, इसलिए मैं ग्राफिक का उपयोग करता हूँ।
इस प्रकार, मैं यहाँ पैकेज आयात कर सकता हूँ हमने आयातित दो पैकेज और डॉट एप्लेट का उपयोग किया है और फिर उस पैकेज एप्लेट क्लास और फिर ग्राफिक्स वर्ग में दो वर्गों डॉट डॉट।
तो, यह इम्पोर्ट स्टेटमेंट के बारे में है, फिर क्लास की परिभाषा होगी जैसा कि मैंने आपको बताया था कि यहाँ क्लास की परिभाषा भी है, यहाँ जिस क्लास की मैंने चर्चा की है उसका नाम यहाँ है।
कक्षा के नाम का अर्थ है यह वह कार्यक्रम है जिसे हम लिखने जा रहे हैं;
इसका मतलब है, यहाँ एक एपलेट प्रोग्राम है, जिसका नाम हेल्लो वर्ल्ड है, लेकिन यहाँ एक चीज़ जिसका हमने उपयोग किया है, वह यह है कि यह देखें कि यह हमेशा एक मानक वाक्यविन्यास है, यदि आप एक एप्लेट लिखते हैं, तो एप्लेट क्लास जो आप लिख रहे हैं, जिसका अर्थ है कि यह विस्तार करना चाहिए एक पैकेज क्लास कॉल एप्लेट।
तो, यह मानक सिंटैक्स है जो आपको करना है।
तो, यह मूल रूप से आपके एप्लेट कार्यक्रमों के नए वर्ग को परिभाषित कर रहा है।
अब, आप हमारे द्वारा उपयोग किए जाने वाले सरल अनुप्रयोग, साधारण वर्ग हैलो वर्ल्ड a p p और फिर इस अधिकार के भीतर के अंतर को पा सकते हैं, लेकिन यहां हमें यह करना होगा।
और फिर ये मूल रूप से दूसरे ब्रेसिज़ के समापन और मेल खाते हैं
यह दर्शाता है कि आप जो भी कोड शामिल करना चाहते हैं, वह कोड इंगित करता है कि डेटा क्या हैं और आप जिन तरीकों को शामिल करना चाहते हैं, उन्हें समापन और शुरुआत कोष्ठक के भीतर संलग्न किया जाना चाहिए।
अब, इस कार्यक्रम में, हमारे पास केवल एक ही है जिसे फ़ंक्शन कहा जाता है, जिसे घोषित किया जाता है, निश्चित रूप से एक विधि है इसलिए यह विधि नहीं है।
तो, विधि का नाम पेंट है, मैंने यहां एक विधि घोषित की है सार्वजनिक शून्य पेंट मैं इस बारे में चर्चा करूंगा कि इस पर बाद में आप का क्या अर्थ है बस इसे ले लो ठीक है, यह वाक्यविन्यास है जिसे आपको अपनाते समय पालन करना होगा पेंट के तरीके लिखना।
तो, पेंट करें और फिर इस तर्क का भी आपको उल्लेख करना होगा।
इसलिए, यहां हम एक विधि घोषित करते हैं जिसे पेंट विधि और इस पद्धति को स्क्रीन पर प्रदर्शित करने के लिए इस प्रकार के सिंटैक्स का उपयोग करते हैं:
g.drawstring ()।
तो, यह विधि मूल रूप से ग्राफिक्स वर्ग में घोषित की जाती है;
तो, यह विधि मूल रूप से ग्राफिक्स वर्ग में घोषित की जाती है;
और फिर यह स्थान इंगित करता है कि एप्लेट में यह कहां छपेगा, कार्टेशियन स्थान में मूल रूप से 150 150 का अर्थ है x स्थान और y स्थान का समन्वय।
तो, कि अगर एप्लेट 1000 से 1000 सही है, अगर यह 1000 क्रॉस 1000 पिक्सेल है, तो 150 और 150 है।
तो, यहाँ जी डॉट स्ट्रिंग प्रदर्शित किया जाएगा, यह यहाँ एक अवधारणा है।
तो, यह मूल रूप से सरल एक एपलेट है जिसे आप लिख सकते हैं कि एप्लेट पर एक स्ट्रिंग हैलो दुनिया प्रदर्शित होगी।
अब, देखते हैं कि इन एपलेट को कैसे चलाया जाता है, बेशक, एडिटिंग एडिटर आ एडिटर कहते हैं कि नोटपैड ++ और फिर इसे कैसे आकार में संपादित किया जा सकता है और फिर संकलन और अंत में, इसे निष्पादित किया जा सकता है।
तो, आप इस कार्यक्रम को हैलो वर्ल्ड डॉट जावा फ़ाइल के रूप में सहेज सकते हैं और;
जाहिर है, आपकी कार्य निर्देशिका में आप इसे सहेज सकते हैं और फिर संकलन कर सकते हैं, हमने जावा एप्लिकेशन को संकलित करने के लिए Javac संकलक का उपयोग किया है, यहाँ भी आपके द्वारा उपयोग किए जाने वाले जावा एप्लेट को संकलित करने के लिए मान्य है।
जवैक कमांड।
तो, और फिर आप फ़ाइल के नाम को Javac लिखें, जिसे आप इस मामले में हैलो वर्ल्ड डॉट जावा संकलित करना चाहते हैं।
तो, यह इन जावा फाइल को क्लास फाइल में संकलित करेगा।
अब, मैं चल रहा हूं चर्चा करने के लिए मतलब है कि मैं इस वर्ग फ़ाइल को कैसे निष्पादित करूं।
यहाँ एप्लिकेशन से एप्लेट के चलने में अंतर है, एप्लेट के मामले में, एप्लिकेशन के मामले में हम जावा कमांड का उपयोग करते हैं, मूल रूप से दुभाषिया है जो मूल रूप से आपके प्रोग्राम को एग्जीक्यूटिव करता है, लेकिन इस मामले में जावा हम इसका उपयोग नहीं कर सकते हैं, क्या हम एपलेट व्यूअर का उपयोग कर सकते हैं जावा के बजाय हमें एप्लेट व्यूअर का उपयोग करना चाहिए।
लेकिन एप्लेट व्यूअर केवल एक HTML फाइल ही चला सकता है, इसका मतलब है कि आपके द्वारा बनाई गई क्लास फाइल को HTML फाइल में स्टोर किया जाना चाहिए।
अब, यहाँ एक HTML फ़ाइल का विशिष्ट रूप है जो मुझे नहीं पता है कि क्या आप HTML फ़ाइल और फिर HTML टैग और सब कुछ के बारे में जानते हैं।
लेकिन, यदि आप नहीं जानते हैं कि यह पूरी तरह से चिंता का विषय नहीं है, तो आप इसे जल्द ही सीखेंगे जब आप कई अन्य एप्लेट्स सीखेंगे और फिर इसे चलाएंगे।
एक बेसिक सिंटैक्स है जिसे आपको अपनी एचटीएमएल फाइल में एंबेड करने के लिए बेसिक स्ट्रक्चर को फॉलो करना चाहिए।
और यहाँ मूल रूप से HTML फ़ाइल जैसा दिखता है।
तो, यह टैग की शुरुआत है यह टैग का अंत है क्योंकि HTML निर्माण है, ये शरीर हैं;
इसका मतलब है कि, यह HTML का एक निकाय है और यहाँ वाक्यविन्यास है जिसे आपको एमबीटी या डॉट क्लास फ़ाइल का पालन करना चाहिए।
तो, एप्लेट कोड और फिर हैलो वर्ल्ड डॉट क्लास, यह वह फाइल है जिसे आपने बनाया है, जिसका मतलब है कि मैं आपके जावा एप्लेट प्रोग्राम को लिखकर संकलित कर रहा हूं।
और यह अवधारणा है कि आप कितने बड़े एपलेट को प्रदर्शित करना चाहते हैं।
तो, यह 300 300 इंगित करता है कि यदि आपकी कुल स्क्रीन का आकार 1000 से 1000 है, तो इस 1000 से 1000 के भाग पर 300 से 300 तक आपके एप्लेट को देखने के लिए ले जाएगा, मेरा मतलब है कि अपने एप्लेट को आपके कंप्यूटर स्क्रीन पर प्रदर्शित करें।
तो, 300 बाई 300 एप्लेट्स का आकार है जो प्रदर्शित किया जाएगा।
तो, आपको एक HTML फाइल लिखना होगा और फिर इस कोड को HTML फाइल में लिखना होगा और इस प्रोग्राम को सेव करना होगा।
अब, जब आप इस कार्यक्रम को सहेज रहे हैं, तो आप इस HTML के लिए फ़ाइल का नाम दे सकते हैं, उस HTML फ़ाइल का नाम कुछ भी हो सकता है फ़ाइल का नाम कुछ भी हो सकता है, लेकिन एक्सटेंशन HTML होना चाहिए।
तो, यहाँ मूल रूप से यह एक HTML फ़ाइल में सन्निहित एप्लेट है और फिर हमें प्रोग्राम फ़ाइल नाम के समान नाम देता है जिसका अर्थ है हैलो दुनिया, लेकिन इस मामले में मैंने उदाहरण के लिए नाम दिया है, हेल जावा।
तो, इस मामले में प्रोग्राम का नाम हैलो जावा डॉट एचटीएमएल के रूप में दिया गया है।
मैंने आपको इस कार्यक्रम को चलाने के लिए कहा था, आपको एपलेट दर्शक का उपयोग करना चाहिए।
इसलिए, एप्लेट व्यूअर को कमांड के रूप में उपयोग करें और फिर आप प्रोग्राम को एप्लेट व्यूअर के रूप में चलाएं।
आउटपुट इस तरह दिखेगा।
तो, हैलो वर्ल्ड यह वह स्ट्रिंग है जिसे यह यहां प्रिंट करेगा और यह 300 क्रॉस 300 आकार है और, यह बिंदु का एक स्थान (150, 150) है, जहां यह पाठ को चित्रित करना शुरू कर देगा।
तो, आपने सीखा है कि एक सरल एपलेट कैसे बनाया जा सकता है और फिर उसी को निष्पादित किया जा सकता है।
इसलिए, मुझे आपको सलाह देनी चाहिए कि प्रोग्राम लिखने के पहले अनुभव के रूप में ऐपलेट प्रोग्रामिंग का परीक्षण करें।
और कई और चीजें शामिल हैं जब आप एप्लेट प्रोग्रामिंग लिख रहे हैं, तो मैं सिर्फ यह बताने की कोशिश करूंगा कि मैं यहां कुछ महत्वपूर्ण चीजों का उल्लेख करूंगा, कई और चीजों पर चर्चा की जाएगी, जब विवरण में एप्लेट पर चर्चा होगी।
इसलिए, एक एप्लेट को लिखने के लिए बहुत सारे अन्य की आवश्यकता होती है, जिसका अर्थ है कि कई और चीजों के लिए जोखिम।
तो, यह समय लगेगा और हम इसे धीरे-धीरे सीखेंगे, एप्लेट के बारे में और अधिक जानकारी जानने से पहले, मैं बस एक संक्षिप्त अवलोकन करना चाहता हूं कि सामान्य रूप से एप्लेट की संरचना कैसी होती है।
इसलिए, आमतौर पर हमने जो संरचना सीखी है, वह मूल रूप से जावा सिंटैक्स में एक कार्यक्रम लिख रही है।
तो, अनिवार्य रूप से जब आप एप्लेट प्रोग्रामिंग के साथ काम कर रहे हैं, तो तीन चीजें हैं।
तो, पहली बात यह है कि आपका प्रोग्राम कुछ जावा सिंटैक्स के बाद लिखना चाहिए और फिर प्रोग्राम इस तरह दिखेगा।
और फिर दूसरी चीज जो आपको HTML फ़ाइल का उपयोग करके प्रोग्राम को एम्बेड करना है जो इस रूप में दिखती है।
तो, ये दो चीजें हैं जो स्पष्ट स्थिति हैं जिनका आपको पालन करना होगा।
और फिर एक एपलेट दर्शक का उपयोग करके इस तरह की चीजों को चलाना और यह इस तरह दिखेगा
आउटपुट।
तो, ये तीन चीजें हैं।
तो, अब तक जावा एप्लेट प्रोग्रामिंग उन मूल कदमों से चिंतित है जिनका आपको पालन करना चाहिए।
अब, इस मूल कदम के अलावा और भी कई चीजें शामिल हैं, जबकि आपको अपना जावा एपलेट विकसित करना होगा।
और फिर मूल रूप से एक पूर्ण जावा प्रोग्राम जावा एपलेट आप इस तरह से कैसे दिखते हैं।
क्या मूल रूप से कई और चीजें शामिल हैं, मैं वहां मौजूद महत्वपूर्ण चीजों को उजागर करना चाहता हूं।
इसलिए, जब आप एक जावा एप्लेट लिखते हैं, तो सबसे पहले आपको इनपुट लिखना चाहिए, जैसा कि मैंने आपको हमारे कार्यक्रम में बताया था, जिसे हमने अभी अनुभव किया है।
तो, वहाँ मूल रूप से जावा डॉट एप्लेट डॉट एप्लेट क्लास आयात करते हैं और फिर जावा डॉट ओटी डॉट ग्राफिक क्लास ये चीजें हैं।
तो, यह वहाँ आयात अनुभाग है जिसमें आपको यह उल्लेख करना होगा कि वे कौन सी चीजें हैं जिन्हें आपको आयात करना है।
और मैं चाहता हूं कि इनपुट एपलेट वर्ग का मुख्य निकाय है, मुख्य शरीर के रूप में पहले हमें एप्लेट के नामकरण के साथ शुरू करना होगा, इसलिए उस नाम को आपको अपना एक नाम देना होगा।
और ये वो चीजें हैं जो आपको हमेशा पब्लिक क्लास को ठीक करनी होती हैं जो आपको हमेशा देनी होती हैं, कोई और चीज नहीं है जिसे आप लिख सकते हैं अगर आप नहीं लिखेंगे तो कंप्लेन एरर होगा।
इसलिए, बिना किसी झिझक के आप उस सार्वजनिक वर्ग को सही ठहराते हैं और फिर अपनी कक्षा का नाम देते हैं और फिर, आपकी कक्षा को एप्लेट का विस्तार करना चाहिए, यह भी एक और विस्तार है।
तो, यह आपका अपना है और यह मानक है जिसे आपको हमेशा पालन करना है और फिर, उस कोड के बारे में जो आप अपने प्रोग्राम में उपयोग करना चाहते हैं, आपको उसके भीतर लिखना चाहिए
कोष्ठक शुरू करना और फिर बंद करना।
इसलिए, मैं कह सकता हूं कि ये दूसरा भाग हैं।
और फिर इस हिस्से के भीतर उन्हें घोषित करने के लिए कुछ चर की आवश्यकता हो सकती है।
इसलिए, यदि आपको अपने एपलेट प्रोग्रामिंग में कुछ चर की आवश्यकता है, तो आप इन सभी चीजों को यहां परिभाषित करते हैं।
और फिर आपके एप्लेट को बनाने के लिए आवश्यक विभिन्न विधियों का उल्लेख करना चाहिए।
इसलिए, सभी चार भाग एक साथ हैं, जो आपको जावा में एप्लेट लिखते समय सोचना है।
इसलिए, अलग-अलग हिस्सों के बारे में हम एक-एक करके चर्चा करेंगे, लेकिन आज के व्याख्यान में हम बुनियादी चीजों के बारे में चर्चा करने की कोशिश करेंगे और मुख्य रूप से अलग-अलग तरीके क्या हो सकते हैं, यहाँ मैं फिर से एक बात का उल्लेख करना चाहता हूँ कि कोई भी तरीका होना चाहिए वहाँ शामिल नहीं हैं, कुछ निश्चित परिभाषित तरीके हैं, आप केवल उनका उपयोग कर सकते हैं।
हालाँकि, जो विधियाँ आप उन्हें भर सकते हैं, जिनका अर्थ है कि विधियाँ नियत हैं, लेकिन वे निकाय हैं जिन्हें आप कुछ कोड के साथ लिख सकते हैं जो आपके एप्लेट के लिए आवश्यक हैं।
तो, ये चीजें अब वहां हैं, आइए देखें कि इस एप्लेट प्रोग्रामिंग में अलग-अलग तरीके क्या हैं, जाहिर है, जिस पद्धति पर हमने अपने एपलेट्स के साथ पहले ही चर्चा की है, केवल एक ही विधि का नाम पेंट है।
तो, यह विधि है कि आप इस विधि का नाम नहीं बदल सकते हैं, किसी भी तरह से आप अपने नाम के किसी अन्य तरीके को वहां नहीं लिख सकते हैं।
तो, यह एक फिक्स विधि है जिसे आपको पेंट के साथ उपयोग करना है।
इस पेंट विधि के अलावा कुछ और तरीके हैं, जिनकी आवश्यकता है
अपने प्रोग्राम जावा एप्लेट में लिखे जा सकते हैं उदाहरण के लिए तरीकों को यहां कहा जाता है, हमने तीन तरीकों को सूचीबद्ध किया है जो एक init है, दूसरा शुरू होता है और फिर बंद हो जाता है।
तो, सभी एक साथ केवल 5 तरीके जिन्हें आप अपने एप्लेट में उपयोग कर सकते हैं।
तो, पांच विधियों का अपना अर्थ है, प्रारंभ विधि मूल रूप से एप्लेट चलाना शुरू करने के लिए है, कभी-कभी हमें एप्लेट दृश्य को नियंत्रित करना होता है।
तो, उस स्थिति में यदि आप नियंत्रण करना चाहते हैं तो आप शुरू करें,
कभी-कभी आपको एप्लेट को भी बंद करना पड़ता है जो एक प्रोग्राम में होते हैं आप 3 4 एप्लेट का उपयोग कर सकते हैं।
इसलिए, कभी-कभी हमने एक एपलेट को दूसरे के करीब और इस तरह से शुरू किया है।
तो, उस स्थिति में आप स्टार्ट स्टॉप और क्लोज विधि का उपयोग करते हैं और फिर पेंट विधि का इस्तेमाल कर चुके हैं।
और यदि आप अपने प्रोग्राम से एप्लेट हटाना चाहते हैं तो विधि को नष्ट कर दें।
इसलिए, आप नष्ट विधि का उपयोग कर सकते हैं जब वे चल रहे हों।
तो, नष्ट एक कार्यक्रम के निष्पादन में हमेशा के लिए एप्लेट दृश्य को मार देगा।
तो, ये अलग-अलग विधियाँ हैं, और, मैं सिर्फ एक विधि पर प्रकाश डालूंगा या समझाऊंगा।
तो, आइए इनिट विधि को देखें कि इसे आपके एप्लेट प्रोग्रामिंग में कैसे पुन: कॉन्फ़िगर किया जा सकता है।
अब, हम निम्न कोड को देखते हैं ये आयात अनुभाग हैं जो हमने पहले ही इसके बारे में सीखा है।
और फिर यह ऐपलेट का नाम है जिसे हैलो दुनिया कहा जाता है और हमारे पहले के कार्यक्रम में यह कोड नहीं था।
अब, मैं इस कोड का उपयोग करना चाहता हूं जहां यह कोड कोड का यह हिस्सा पहले से ही था।
तो, अब यह ठीक है कि आइए देखें कि इस कोड का [imp / effect] क्या प्रभाव है, इसलिए यहाँ मूल रूप से एक विधि है जिसे मैंने इनको मूल रूप से कॉल करने का एक और तरीका बताया है एक विधि है जिसे awt में परिभाषित किया गया है यह पहले से ही है ।
तो, यह आकार बदलने की विधि मैं एक 200 200 पर कॉल करता हूं जो इस बारे में विचार है।
इसलिए, यदि आप अपने HTML में जिस एप्लेट के आकार का उल्लेख करते हैं, आप ध्यान दें कि HTML में हम आमतौर पर उपयोग करते हैं
आपके एप्लेट दृश्य का आकार 300 300 क्या होना चाहिए, लेकिन सीपीयू कॉल और इनिट विधि के बाद आकार के साथ 200 * 200।
तो, एक एप्लेट का आकार स्वचालित रूप से 200 * 200 दृश्य में बदल जाएगा।
इसलिए, आकार बदलने के बारे में विचार है।
अब, आउटपुट को इनिट विधि के माध्यम से उपयोग करने पर आउटपुट देखें और यदि आप इसका उपयोग नहीं करते हैं तो यह आपके लिए कैसे काम करेगा।
तो, यहाँ विधि किसी भी आकार के बिना है।
तो, यह प्रोग्राम है यह एप्लेट है 300 और 300s डिफ़ॉल्ट आकार है जो हमने उल्लेख किया है और फिर आउटपुट इस तरह दिखेगा।
तो, यहाँ मूल रूप से 300 बाई 300 बिना किसी आकार के एप्लेट है।
लेकिन, यदि आप आकार परिवर्तन विधि का उपयोग करते हैं, जिसका अर्थ है कि इन कोड का उपयोग किया जाता है और फिर से आप एप्लेट का उपयोग करते हैं, तो यह HTML फ़ाइल है, फिर एप्लेट जो छोटे आकार के साथ दिखाई देगा।
तो, आकार बदलें मूल रूप से एक प्रोग्रामर को एप्लेट के आकार को नियंत्रित करने की अनुमति देगा क्योंकि यह वहां है।
तो, यह init विधि के init पद्धति के उपयोग का एक उदाहरण है, init विधि का एक और उपयोग है।
तो, उस एप्लेट को हम एक एप्लेट में इनपुट कैसे दे सकते हैं, क्योंकि एप्लेट चलने के दौरान यह मूल रूप से HTML के माध्यम से होता है और फिर एप्लेट को इनपुट कैसे दिया जाता है।
तो, एक एप्लेट पर इनपुट यदि आप देना चाहते हैं तो आपको HTML के माध्यम से ही देना चाहिए।
और xyw और h को पास करने के लिए चार पैरामीटर की आवश्यकता होती है।
और फिर हम एप्लेट से ही मूल्य xywh प्राप्त करना चाहते हैं।
तो, इसके लिए हम init मेथड लिख सकते हैं।
तो, यह एक init मेथड है जिसे हमने यहाँ लिखा है और फिर init मेथड में कोड है।
यह आमतौर पर मेरा मतलब है कि कुछ कोड की आवश्यकता है, यहां यह विचार है कि यह है
कहते हैं कि एक पूर्णांक गुजर रहा है, यह घोषित है कि यह पहले से ही जावा डॉट लाइन पैकेज में है मूल रूप से यह उस मूल्य को पारित करेगा जो एप्लेट में है और फिर पूर्णांक के रूप में संग्रहीत होता है।
तो, यह जावा में मानक सिंटैक्स है।
और पैरामीटर प्राप्त करें मूल रूप से HTML कोड से एक मूल्य मिलता है।
तो, यह एक पैरामीटर पैरामीटर है और फिर उस पैरामीटर को जहां HTML कोड में, इसे x मान के रूप में लिखा जाता है।
तो, HTML कोड में अगर कुछ निश्चित पैरामीटर हैं जो x Val, y val, w val, h val के रूप में परिभाषित हैं, तो उन्हें अच्छी तरह से HTML फ़ाइल प्रक्रिया से पुनर्प्राप्त किया जा सकता है और उन्हें इस मामले में एक xywh के रूप में एक इनपुट के रूप में संग्रहीत किया जा सकता है। पैरामीटर एप्लेट।
तो, यह इस बारे में विचार है कि एप्लेट को इनपुट कैसे दिया जा सकता है।
अब, देखते हैं कि यह प्रोग्राम आपका नया एप्लेट प्रोग्राम है जहाँ यह HTML फ़ाइल से xywh को पढ़ेगा और फिर यह एक आयत खींचेगा।
अब, देखते हैं कि इस मामले में HTML फ़ाइल कैसी होगी।
तो, उनकी HTML फ़ाइल में क्या बदलाव है।
तो, यहाँ HTML कोड पहले के HTML बॉडी टैग और सब कुछ के समान होगा, केवल यहाँ जो कोड आवश्यक है, मूल रूप से एप्लेट कोड यह कोड है जिसे निष्पादित करने की आवश्यकता है और आप डॉट क्लास को डॉट क्लास भी लिख सकते हैं।
और फिर यह एक चौड़ाई और ऊंचाई है जो आपने उस खिड़की के आकार को निर्दिष्ट किया है और यहां परम नाम x वैल और यह मान 20 के बराबर है;
इसका मतलब है, आप यह कहना चाहते हैं कि यह एक पैरामीटर नाम x मान है जिसका मान 20 है यह एक विशिष्ट HTML कोड है जो क्रमशः x मान पर 40% 40 y मूल्य w मान h मान के लिए है।
तो, यह HTML कोड है जिसे आपको मूल्यों को पारित करने के लिए लिखना है, एक HTML से ऐपलेट कोड तक यह है।
इसलिए, जब ये HTML कोड हो जाता है, तो आप इस कोड को हमेशा की तरह एपलेट व्यूअर एपलेट व्यूअर का उपयोग करके चलाते हैं।
तो, एप्लेट व्यूअर को यहां चलाया जा सकता है और यदि आप एपलेट दर्शक का उपयोग करके यह HTML कोड चलाते हैं, तो यह एप्लेट को इस तरह प्रदर्शित करेगा।
तो, यह आयत को आकर्षित करेगा जो xy इस एक के साथ समन्वय करता है और w यह एक है और h यह एक है।
इसलिए, एप्लेट तैयार किया जाएगा।
अब हम उसी प्रोग्राम को चलाते हैं, लेकिन हम डिफरेंट वैल्यू को बदलते हैं।
इसलिए, यदि आप मूल्य को बदलना चाहते हैं, तो निश्चित रूप से आपको वहाँ HTML फ़ाइल पर बातचीत करनी होगी।
तो, HTML फ़ाइल में यहां 20 40 150 लिखा है, यदि आप अलग-अलग मूल्य देते हैं, तो तदनुसार अलग आयताकार तैयार किया जाएगा।
अब, देखते हैं कि नई HTML फ़ाइल किस प्रकार नए मानों के साथ हो सकती है और फिर संबंधित HTML खींची जा सकती है।
तो, यहाँ फिर से मैंने इस मामले में अलग-अलग मान ३० १३ के साथ यहां HTML फाइल को फिर से लिखा है और फिर इसी तरह के एप्लेट्स इस तरह दिखेंगे।
तो, आप परिवर्तन को बदल सकते हैं, जबकि आप इसे स्वाद लेते हैं और फिर विभिन्न मूल्यों को लिख रहे हैं और फिर आप एपलेट दर्शक के माध्यम से चला सकते हैं, आप यह देख पाएंगे कि यह कैसे अलग आकार है।
अब, अगर मैं आपसे यह पूछूं कि आयत बनाने के अलावा कैसे, अगर मैं यहाँ एक संदेश छापना चाहता हूँ कि यह मेरी आयत है, तो आप यह कैसे कर सकते हैं, आपको विशेष रूप से यहाँ कुछ भी करने की ज़रूरत नहीं है वह चीज जिसका आपको उपयोग करना है जो आप पेंट विधि में उपयोग करते हैं जैसे कुछ और मूल्य।
तो, उदाहरण के लिए, पेंट विधि में यहाँ पेंट विधि उदाहरण के लिए, यहाँ सही है।
यदि आप एप्लेट पर एक संदेश खींचना चाहते हैं, तो आप क्या कर सकते हैं कि जी ड्रॉअर के बजाय आप जी डॉट ड्रा स्ट्रिंग का उपयोग करें और फिर आप जो भी स्ट्रिंग करना चाहते हैं उसे टाइप कर सकते हैं, आप बस इस एक का उपयोग करें ।
तो, पेंट विधि में इस तरह से आप जो भी सामग्री करना चाहते हैं उसे प्रदर्शित करने के लिए अपने स्वयं के तरीकों को जोड़ सकते हैं।
तो, यह वह तरीका है जिससे एप्लेट को विकसित किया जा सकता है और इस बारे में एक मूल विचार है कि एप्लेट को कैसे विकसित किया जा सकता है और, तब आप इसे HTML का उपयोग करके निष्पादित कर सकते हैं।
तो, यहाँ हमारा उद्देश्य था कि कैसे एप्लेट लिखें और फिर स्क्रीन ओके पर उसी को प्रदर्शित किया जा सकता है।
तो, हम अब एप्लेट के बारे में सीख चुके हैं;
जाहिर है, मेरा मतलब है कि आवेदन और एप्लेट के बीच कुछ अंतर हैं।
और पहली नज़र के रूप में उनके पास दो अलग-अलग संरचनाएँ हैं और जैसा कि आप देख रहे हैं कि ये एक सामान्य एप्लेट की संरचना हैं जैसे कि और यहाँ एक एप्लेट की संरचना है और यह एक अनुप्रयोग की संरचना है।
और आवेदन के मामले में आपको एक वर्ग को मुख्य वर्ग और मुख्य विधि में कॉल करने की घोषणा करनी चाहिए, लेकिन आप मामले के एप्लेट में देख सकते हैं कि कोई मुख्य विधि नहीं है।
अब जाहिर है, इसका निहितार्थ बाद में इस बारे में सीखना होगा।
और फिर इसलिए, यह एक महत्वपूर्ण बात है कि आवेदन के मामले में एक वर्ग है, जिसमें मुख्य विधि शामिल है, लेकिन एप्लेट के मामले में मुख्य विधि की कोई आवश्यकता नहीं है।
और एक और अंतर यह है कि एक एप्लिकेशन किसी भी उपयोगकर्ता परिभाषित विधि को शामिल कर सकता है;
इसका मतलब है, उपयोगकर्ता विधि का कुछ नाम दे सकता है और फिर इसका उपयोग कर सकता है।
लेकिन, कुछ विशिष्ट विधियों के अलावा एप्लेट के मामले में उपयोगकर्ता कोई भी तरीका नहीं दे सकता है।
तो, ये दोनों के अलावा महत्वपूर्ण अंतर हैं, कुछ और अंतर हैं, कुछ और अंतर भी हैं।
इसलिए, नामकरण और मुख्य वर्ग के अलावा और ऐपलेट को HTML पेज में एम्बेड करने के लिए जिन मुख्य विधियों की आवश्यकता होती है, वे इसे निष्पादित करने की कोशिश करते हैं, जबकि एक आवेदन की आवश्यकता नहीं होती है।
और इसलिए, अब तक इनपुट आउटपुट का संबंध है;
जाहिर है, एप्लिकेशन किसी भी स्रोत से किसी भी इनपुट को फ़ाइल से कीबोर्ड से या जो कुछ भी है उसे पढ़ने की अनुमति देगा, लेकिन जैसा कि आप एप्लेट के मामले में देखते हैं कि इस तरह का इनपुट प्रत्यक्ष इनपुट संभव नहीं है।
यदि आप कोई इनपुट देना चाहते हैं, तो आपको सभी इनपुट को HTML फ़ाइल के माध्यम से देना चाहिए।
और उन दो चीजों के बीच कुछ और अधिक मुख्य अंतर जो एप्लेट अन्य एप्लेट या अन्य ब्राउजर या अन्य मशीन से संवाद नहीं कर सकता है।
जबकि, अनुप्रयोग संचार कर सकेगा;
जाहिर है, नेटवर्क प्रोग्रामिंग इंटरनेट प्रोग्रामिंग के लिए ठीक हो तो JDBC:
जावा डेटा बेस कनेक्टिविटी और अन्य जगहों पर, लेकिन एप्लेट ऐसा नहीं कर सकता।
और एप्लेट किसी भी अन्य भाषा या स्थानीय कंप्यूटर से किसी भी अन्य अनुप्रयोग में लिखे गए प्रोग्राम को भी नहीं चला सकता है।
इसलिए, जबकि, एप्लिकेशन ऐसा कर सकता है और, एप्लेट भी किसी अन्य प्रोग्रामिंग भाषाओं में लिखे गए प्रोग्राम प्रोग्रामिंग भाषाओं के साथ इंटरफेस करने में सक्षम नहीं है।
तो, ये अंतर हैं;
जाहिर है, कारण हैं कि ये सभी अंतर क्यों हैं।
ये सभी अंतर हैं क्योंकि इन दोनों कार्यक्रमों का उद्देश्य अलग-अलग है, यही कारण है कि डेवलपर हमारे लिए अंतर बनाता है और निश्चित रूप से इन सभी सवालों के जवाब पर इन सभी सवालों का जवाब देता है कि ऐसा क्यों हो सकता है, एप्लेट्स में कई प्रतिबंध हैं समय के कारण
और फिर स्पष्ट रूप से एक और सवाल यह है कि क्या हम एक साथ निर्माण और आवेदन और एप्लेट कर सकते हैं।
इसलिए;
जाहिर है, आपका विचार क्या है कि कोई भी एप्लेट और एप्लिकेशन दो अलग-अलग इकाई नहीं हैं, जिन्हें एक साथ नहीं बनाया जा सकता है।
वैसे भी, हम अगले व्याख्यान में इन सभी चीजों और कई अन्य चीजों पर चर्चा करेंगे।
धन्यवाद।
देवांश समता विभाग के कंप्यूटर विज्ञान और इंजीनियरिंग भारतीय प्रौद्योगिकी संस्थान, खड़गपुर लेक्चर - 50 JDBC - I अब में जावा प्रोग्रामिंग, हम JDBC के बारे में सीखना शुरू करेंगे।
JDBC का पूर्ण रूप जावा डेटाबेस कनेक्टिविटी है और इन अवधारणाओं को आज सहित 6 सत्रों में कवर किया जाएगा।
इसलिए, सबसे पहले, हम वास्तव में ऐसा करेंगे, जहाँ तक JDBC का संबंध है, वहाँ तीन चीजें सीखी जानी हैं।
सबसे पहले डेटाबेस मैनेजमेंट सिस्टम और फिर कैसे डेटाबेस मैनेजमेंट सिस्टम को कनेक्ट किया जा सकता है।
और, यह स्वयं को JDBC ड्राइवर कहा जाता है और फिर अंत में, जावा एप्लिकेशन जो मूल रूप से एक प्रोग्रामर को एक डेटाबेस से एक समापन बिंदु के रूप में कनेक्ट करने में मदद करेगा।
तो, तीन चीजें हैं इसलिए, डेटाबेस प्रबंधन प्रणाली का संबंध है कई उपकरण हैं कई पैकेज ज्ञात हैं।
इस पाठ्यक्रम में, हम एक सिस्टम को कवर करेंगे जो मूल रूप से प्रोग्रामर को डेटाबेस बनाए रखने में मदद करता है जिसे MySQL कहा जाता है।
इसलिए, हम MySQL पर चर्चा करेंगे और MySQL एक डेटाबेस मैनेजमेंट सिस्टम है और फिर हम चर्चा करेंगे कि इन MySQL को कैसे स्थापित किया जा सकता है।
यदि आप इस MySQL के लिए नए हैं तो यह सभी जानकारी आपके सीखने के लिए अत्यधिक आवश्यक है।
इसलिए, मुझे ठीक से पता नहीं है कि आप SQL या MySQL से परिचित हैं या बल्कि रिलेशनल डेटाबेस मैनेजमेंट सिस्टम से किसी से परिचित हैं।
वैसे भी, यह देखते हुए कि आपके पास डेटाबेस प्रबंधन प्रणाली से निपटने के बारे में कोई पृष्ठभूमि ज्ञान नहीं है।
इसलिए, मैं SQL आधारित डेटाबेस प्रबंधन प्रणाली का त्वरित दौरा करूंगा जो कि एक बहुत लोकप्रिय है MySQL।
इसलिए, इस सत्र में, हम यह जानने का प्रयास करेंगे कि MySQL कैसे स्थापित किया जा सकता है।
और फिर अंत में, हम इस MySQL का उपयोग करते हुए देखेंगे यदि एक बार आपकी मशीन सफलतापूर्वक स्थापित हो जाती है तो हम किसी कार्य से संबंधित डेटाबेस प्रबंधन प्रणाली को कैसे प्रबंधित कर सकते हैं।
अर्थात्, हम एक डेटाबेस प्रबंधन डेटाबेस कैसे बना सकते हैं, हम एक डेटाबेस के तहत एक तालिका कैसे बना सकते हैं और फिर आप डेटाबेस के विभिन्न कार्यों को कैसे पूरा कर सकते हैं।
अब ऐसा है, पहले MySQL यह वास्तव में क्या है।
तो, यह एक बहुत लोकप्रिय सॉफ्टवेयर है जिसे आप आमतौर पर डेटाबेस प्रबंधन प्रणाली के लिए जानते हैं जो एक भाषा को संभालने के लिए प्रदान की गई है।
यह बहुत लोकप्रिय है और एक मानक भाषा है जिसे संरचित क्वेरी भाषा कहा जाता है।
हम आमतौर पर इस भाषा को चौथी पीढ़ी की भाषा कहते हैं, अगर हम C, C ++, Java सेट करते हैं तो वे तीसरी पीढ़ी की भाषा हैं।
बेशक भाषा, लेकिन बात यह है कि यह एक निश्चित वाक्यविन्यास का अनुसरण करता है यही कारण है कि कभी-कभी इसे भाषा कहा जाता है, लेकिन वास्तव में SQL जावा, सी, सी ++ जैसी भाषा नहीं है।
वैसे भी, SQL प्रोग्रामिंग जो कुछ भी है हम इसे अंग्रेजी में सिंटैक्स की तरह कर सकते हैं।
और यह आजकल मूल रूप से एक वास्तविक मानक है;
हर डेटाबेस मैनेजमेंट सिस्टम इंजीनियर SQL आधारित सिस्टम को प्राथमिकता देता है।
और, SQL बेस सिस्टम का मूल रूप से पालन किया जाता है, रिलेशनल डेटाबेस मैनेजमेंट सिस्टम, ऑब्जेक्ट-ओरिएंटेड डेटाबेस मैनेजमेंट सिस्टम के रूप में कई प्रकार के डेटाबेस मैनेजमेंट सिस्टम हैं;
SQL वास्तव में है, ar elational database management सिस्टम।
अब, रिलेशनल डेटाबेस मैनेजमेंट सिस्टम के बारे में, हम इसके बारे में कुछ बातों पर चर्चा करेंगे, इस बारे में कुछ मुख्य बातें।
अब, SQL मूल रूप से बहुत सरल है और इसका उपयोग करना आसान है और इसीलिए यह चौथी पीढ़ी की भाषा है;
वास्तव में 3 जीएल और 4 जीएल के बीच का अंतर।
तीसरी पीढ़ी और चौथी पीढ़ी की भाषाएं यह हैं कि तीसरी पीढ़ी की भाषा मूल रूप से अवधारणा कैसे करें;
इसका मतलब है कि यदि आप एक निश्चित समस्या को हल करना चाहते हैं तो यह कैसे
समस्या हल हो सकती है।
फिर हमें इसके बारे में एक विवरण लिखना होगा, लेकिन जबकि, चौथी पीढ़ी की भाषा के रूप में, यह क्या करना है।
बस आप यह बताएं कि आपके पास क्या है तो स्वचालित रूप से SQL प्रोसेसर आपके किन पहलुओं का ध्यान रखेगा और फिर समस्या का समाधान करेगा।
आपको प्रोग्रामिंग के बारे में बहुत सारे विवरण लिखने की ज़रूरत नहीं है।
तो, यही कारण है कि SQL मूल रूप से एक हल्की अवधारणा है।
अब, इस SQL ​​का उपयोग करके हम कई काम कर सकते हैं, जिस पर हम चर्चा करने जा रहे हैं और दूसरी बात यह है कि जो भी वाक्यविन्यास आप लिख सकते हैं वह मूल रूप से अंग्रेजी में है।
और आप अंग्रेजी में जानते हैं, दो प्रकार के वर्ण हैं:
लोअर केस और अपर केस।
एसक्यूएल अंतर नहीं करता है कि आपने निचले मामले और ऊपरी मामले में टाइप किया है या नहीं;
इसका मतलब है कि यह असंवेदनशील है।
अब, SQL के कई लाभकारी हैं और कई उपकरण हैं जो मूल रूप से SQL की अवधारणा का लाभ उठाते हैं।
और, जैसा कि मैं जानता हूं कि एसक्यूएल संरचित क्वेरी लैंग्वेज है जो हमने पिछली स्लाइड्स में सीखी है।
MySQL एक विशिष्ट एप्लिकेशन है जो एक उपकरण है जो मूल रूप से मोंटी विडेनियस द्वारा विकसित किया गया है और यह मूल रूप से माय, माय उसकी बेटी का नाम है।
तो, यही कारण है कि MySQL उन्होंने अपनी शौकीन बेटी के बारे में नाम दिया।
इसलिए, MySQL तो, ऐसा नहीं है कि MySQL का मतलब है कि यह मेरा SQL है, ऐसा नहीं है और फिर यह मूल रूप से SQL आपके पीसी, लैपटॉप जैसी अकेली मशीन में स्थापित किया जा सकता है, जो भी यहां है।
और, फिर एक बार जब आप इसे स्थापित कर लेते हैं तो आप अपने डेटाबेस को बहुत आसानी से बनाए रख सकते हैं।
और जैसा कि आप जानते हैं कि यह संरचित क्वेरी भाषा प्रदान करता है और संरचना क्वेरी भाषा एक वास्तविक मानक बन जाती है।
इसका मतलब है कि आप इसका परीक्षण कर सकते हैं, आप इसका उपयोग कर सकते हैं, आप किसी भी समस्या को हल कर सकते हैं और फिर एक बार जब आप इसे MySQL का उपयोग कर लेते हैं, तो अंत में, आप किसी अन्य सिस्टम पर तैनात कर सकते हैं, जो मूल रूप से SQL के बारे में एक इंटरफ़ेस है।
तो, यही इन चीजों की सुंदरता है।
तो, MySQL शुरू में Oracle Corporation द्वारा विकसित, वितरित और समर्थित है।
जैसा कि आप जानते हैं कि Oracle डेटाबेस मैनेजमेंट सिस्टम के क्षेत्र में एक संयुक्त खिलाड़ी है।
अब, मैं सबसे पहले जल्दी से बताऊंगा कि MySQL को आपकी मशीन में कैसे स्थापित किया जा सकता है।
अब, आप डाउनलोड कर सकते हैं एसक्यूएल का एक बहुत ही जाने वाला संसाधन मूल रूप से कई चीजें हैं, यदि आप अपाचे सर्वर रखना चाहते हैं या यदि आप पीएचपी में कुछ विकसित करना चाहते हैं।
PHP वेब प्रोग्रामिंग के लिए प्रोग्रामिंग भाषा का एक और प्रकार है जिसे इसे कहा जाता है
हाइपरटेक्स्ट प्री-प्रोसेसर।
और, MySQL वे मूल रूप से एक साथ बंडल किए गए हैं और कई स्रोत हैं जिनके लिए उदाहरण के लिए, यहां XAMPP, WAMP सर्वर वगैरह।
तो, उन सभी चीजों को आप उस लिंक से डाउनलोड कर सकते हैं जो मैंने विंडोज के लिए एक्सएएमपीपी के लिए दी है, मैंने विंडोज़ के लिए डब्ल्यूएएमपी के लिए भी इसी तरह लिंक दिए हैं, दूसरा लिंक जिसका आप अनुसरण कर सकते हैं।
तो, ये अच्छी तरह से ज्ञात लिंक हैं और निश्चित रूप से, यह वास्तव में मुफ्त स्रोत है;
आपको कुछ भी भुगतान करने की आवश्यकता नहीं है, आप इसे स्वतंत्र रूप से खुला स्रोत डाउनलोड कर सकते हैं।
अब, मैं आपको बता रहा हूं कि आप कैसे अपने MySQL सॉफ्टवेयर को डाउनलोड करने के लिए दूसरे स्रोत का अनुसरण कर सकते हैं।
इसलिए, अगर कोई लिंक है जैसा कि मैंने यहां दिया है, तो देव mysql.com डाउनलोड करें।
तो, इस लिंक से आप जा सकते हैं और इस लिंक में, आप MySQL समुदाय सर्वर पा सकते हैं।
तो, आप बस इस लिंक पर क्लिक करें तो यह आपके सामने होगा, यह आपको MySQL समुदाय सर्वर में संरेखित करेगा।
आप इस लिंक को खोलते हैं और फिर अंत में, आप पा सकते हैं कि कई ऐसे हैं जिन्हें सॉफ्टवेयर मुफ्त डाउनलोड करने के लिए उपलब्ध है।
और, जिसमें से हमें स्थापना के बिना चयन करना है और एक संग्रह संस्करण है।
और, फिर सीधे भी आप उस लिंक का अनुसरण कर सकते हैं जिस पर आप सॉफ्टवेयर डाउनलोड कर सकते हैं।
मैंने सॉफ्टवेयर के लिए और 64 बिट्स मशीन के लिए यहां उल्लेख किया है, अगर हमारे पास 64-बिट मशीन है तो यह आसान है।
और, नवीनतम संस्करण जो मैंने यहां MySQL 8.0 0.13 के रूप में उल्लेख किया है, यह वर्तमान संस्करण है।
तो, आप इसे डाउनलोड कर सकते हैं और यदि यह संस्करण बदल रहा है तो आप फिर से नए संस्करण को डाउनलोड कर सकते हैं और आप इसे वहां जो कुछ भी है उसे फिर से स्थापित कर सकते हैं।
इसलिए,
यह एक प्रकार का संस्करण है जिसे आप कर सकते हैं और यह एक ज़िप फ़ाइल के रूप में डाउनलोड किया जाएगा।
तो, आपको इस फ़ाइल को अनज़िप करना होगा।
तो, इस बारे में क्या विचार है कि आप कहाँ स्थापित करना चाहते हैं जो आपको तय करना है।
इसलिए, यदि आपको लगता है कि आप C ड्राइव में और MySQL के नाम से इंस्टॉल करना चाहते हैं।
तो, फिर आपको फ़ाइल को निकालना चाहिए;
मेरा मतलब है, ज़िप फ़ाइल जिसे आपने डाउनलोड किया है वह सभी फ़ाइलों को निकालने के लिए है;
मेरा मतलब है कि वास्तव में सी ड्राइव में फ़ाइलों को खोलना।
और, फिर आपको फ़ोल्डर का नाम बदलना चाहिए अन्यथा यदि आप सीधे इंस्टॉल करना शुरू करते हैं तो यह वास्तव में यहां MySQL संस्करण का नाम लेगा और फिर उदाहरण के लिए विंडोज MySQL 8.0.13 के बजाय विंडो 64।
इसलिए, आप इस फ़ाइल का नाम बदलकर MySQL कर सकते हैं और इस फ़ोल्डर का नाम बदलकर MySQL कर सकते हैं।
फिर भी MySQL हो सकता है, MySQL कहीं भी स्थापित किया जा सकता है, लेकिन मूल चरण समान हैं।
तो, अब आपको बैकअप और रीइंस्टॉल को आसान बनाने के लिए फ़ोल्डर को किसी अन्य ड्राइव पर रखना होगा;
वास्तव में, जैसा कि आप जानते हैं कि MySQL एक डेटाबेस रिपॉजिटरी का रखरखाव करता है।
तो, डेटा रिपॉजिटरी जिसके लिए आपको अलग से एक निर्देशिका बनानी होगी;
डिफ़ॉल्ट रूप से, यह उसी तरह निर्देशिका होना चाहिए जैसे कि MySQL स्थापित है।
इसलिए, बेहतर यह है कि निर्देशिका को डी ड्राइव में उदाहरण के लिए किसी अन्य ड्राइव में बनाए रखा जा सकता है।
तो, डिफ़ॉल्ट नाम वह डेटा है जो आपको करना है आपको इसे बदलना नहीं चाहिए।
उदाहरण के लिए, मैंने यहां भेजा है कि डी कोलोन डी डेटा निर्देशिका ड्राइव है जहां हम MySQL सर्वर के तहत सभी डेटा भंडार को बनाए रखना चाहते हैं।
और इसलिए, हम उन सभी सामग्रियों को कॉपी कर सकते हैं जो उस फ़ोल्डर के बाद एक बार MySQL है जो आप उस D डेटा पर जा सकते हैं।
तो, कुछ ऐसी सिस्टम फाइल होती है, आप सभी सिस्टम फाइल को नई बनाई गई डायरेक्टरी में ले जाते हैं, जो आपने बनाई है कि हमने अभी सिर्फ डी ड्राइव में किया है और फिर आपके पास दो फोल्डर हैं।
तो, आपको एक फ़ोल्डर को निकालना चाहिए।
तो, C तो MySQL डेटा कि फ़ोल्डर को हटा दिया जाना चाहिए।
तो, इसका केवल एक अस्तित्व होना चाहिए।
तो, यह मूल रूप से कॉन्फ़िगरेशन है कुछ और कॉन्फ़िगरेशन भी हैं जो आपको करना है
ठीक समझो।
इसलिए, कुछ और कॉन्फ़िगरेशन की आवश्यकता है, यहां मैंने बिल्कुल उल्लेख किया है कि कॉन्फ़िगरेशन क्या हैं और आपको विचार करना चाहिए।
बात यह है कि, यदि आप चाहते हैं;
बात यह है कि, यदि आप चाहते हैं;
और, फिर आप इसे पहली बार चला सकते हैं यदि आप इसे चलाना चाहते हैं, तो आपको इस कमांड को वास्तव में C कोलोन MySQL बिन mysql.exe पर आज़माना चाहिए।
तो, यह मूल रूप से पहली बार MySQL सर्वर को चलाने के लिए है।
और, इस चीज़ के लिए आप बस स्टार्ट, रन कमांड पर जाएँ और फिर कमांड का पालन करते हुए आप इसे इनिशियलाइज़ेशन के लिए कर सकते हैं।
और फिर यहाँ पर वो पासवर्ड जिसे वो आपसे पूछेंगे, आप उदाहरण के लिए कुछ पासवर्ड दे सकते हैं, यहाँ यह पासवर्ड है जिसे आप सेट कर सकते हैं और फिर रूट पासवर्ड की तरह है।
तो, आप रूट पासवर्ड या अनुमान पासवर्ड दे सकते हैं जो कुछ भी है और फिर आप पासवर्ड को बाद के चरण में भी बदल सकते हैं।
इसलिए, वह विकल्प वहां है मैं आपको बताऊंगा कि बाद में चरण में पासवर्ड कैसे बदला जा सकता है।
तो, ये चीजें हैं जो आपको करनी चाहिए, सबसे पहले, आईएनआई फ़ाइल और फिर आपको पहली बार SQL सर्वर चलाना होगा और फिर पासवर्ड बदलना होगा।
तो, ये हैं कि आप इन चीजों को करते हैं तो आपका अगला कदम मूल रूप से क्लासपैथ सेट करना है।
ताकि, आप इस प्रोग्राम को किसी अन्य डायरेक्टरी जैसे से चला सकें।
तो, यहाँ मूल रूप से है कि आप यह कैसे कर सकते हैं।
तो, यह मूल रूप से आपको विंडोज सेवा बनाने के लिए बुला रहा है।
कमांड प्रॉम्प्ट से विंडो सेवा करने के लिए, आपको फिर से जाना होगा।
और, फिर कमांड प्रॉम्प्ट में, आपको इस कमांड सीडी MySQL बिन और फिर MySQL इंस्टॉल लिखना होगा।
और, यह भी इस तरह से किया जा सकता है नियंत्रण पैनल आपको इस वातावरण में जाना होगा।
और, फिर एक प्रशासनिक उपकरण है जिसे हमें इसे चुनना है और फिर सेवाओं और डबल क्लिक से आप उस सेवा के तहत देख सकते हैं जिसे आप MySQL पहले से ही उपलब्ध हैं।
तो, आपको डबल क्लिक करना होगा और डबल क्लिक के तहत स्टार्टअप प्रकार यह मूल रूप से स्वचालित का चयन करना है।
इसलिए, यह मूल रूप से सुनिश्चित करेगा कि सिस्टम को बूट करते ही आप इस MySQL सर्वर को चला सकते हैं;
इसका मतलब है, आप बस सिस्टम पर स्वचालित रूप से MySQL आपकी सेवा करने के लिए तैयार हैं।
फिर आपको MySQL से कमांड पर जाना होगा और फिर आप इसका उपयोग जिस भी तरीके से करना चाहते हैं, कर सकते हैं।
तो, ये विभिन्न प्रक्रियाएं हैं जो बहुत आवश्यक हैं अब तक MySQL सेवा की स्थापना का संबंध है।
अब, मैं इस बारे में चर्चा करूंगा कि MySQL स्टेटमेंट्स कैसे हो सकते हैं, SQL स्टेटमेंट्स वास्तव में क्या हैं।
ताकि, आप MySQL सर्वर से निष्पादित कर सकें।
अब, अलग-अलग कथन हैं और पहला कथन जो आप कर सकते हैं वह मूल रूप से एक वक्तव्य है।
मैं कह सकता हूं कि यह शो कमांड है, यह मूल रूप से आप या तो छोटे अक्षर या कैपिटल लेटर में टाइप कर सकते हैं यह कोई मुद्दा नहीं है।
और फिर डेटाबेस दिखाएं;
इसका मतलब है कि अगर यह वास्तव में पूर्ण आदेश है;
यह मूल रूप से आपको बताएगा कि वर्तमान में MySQL के तहत उपलब्ध डेटाबेस क्या है।
तो, मूल रूप से यह कमांड है, मैं आपको केवल यह बता रहा हूं कि अलग-अलग कमांड क्या हैं जो आपको पहली बार ठीक सीखना चाहिए।
तो, यह एक पहली कमांड है जिसके बारे में आप सोच सकते हैं और फिर अगला कमांड जिसे आप क्रिएट डेटाबेस के बारे में सोच सकते हैं।
इसलिए, जैसा कि आप यहाँ देखते हैं, आप एक डेटाबेस कैसे बना सकते हैं, बनाएँ डेटाबेस कमांड है और फिर आपको अपने डेटाबेस का नाम देना होगा।
उदाहरण के लिए, मैंने डेटाबेस परीक्षण का नाम दिया है, इसका मतलब है कि प्रत्येक डेटाबेस को विशिष्ट रूप से एक नाम से पहचाना जाना चाहिए;
अनूठा नाम।
और, यह नाम आवश्यक है और प्रत्येक उपयोगकर्ता को इस बारे में जानना चाहिए कि वास्तव में डेटाबेस क्या है।
इसका तात्पर्य है कि MySQL सर्वर एक ही सर्वर या एक ही मशीन में कई डेटाबेस को बनाए रख सकता है।
तो, यही कारण है कि अलग-अलग और एक डेटाबेस के तहत बहुत सारे टेबल हैं जो वहां होंगे।
तो, यह है कि आपको पहले एक डेटाबेस बनाना है और इसका मतलब यह है।
अब, मान लीजिए कि पहले से ही एक डेटाबेस है जिसका एक ही नाम है तो निश्चित रूप से यह एक त्रुटि की रिपोर्ट करेगा।
इसलिए, कि आप डेटाबेस निर्माण सफल नहीं है, कृपया कुछ अलग नाम के साथ प्रयास करें।
तो, यह दूसरी कमांड के बारे में एक विचार है जो मूल रूप से हम कैसे हैं
अपने खुद के डेटाबेस बना सकते हैं और फिर अंत में, आपको परीक्षण को प्रारंभ करना होगा।
तो, इन बातों के लिए, कमांड का उपयोग कमांड है।
इसलिए, उपयोग करें और फिर डेटाबेस का नाम दें जिसका अर्थ है, यह डेटाबेस इसलिए, अब आपके काम के लिए सक्रिय है।
तो, ये तीन कमांड हैं जो बहुत शुरुआत हैं।
इसलिए, यदि आप अपना खुद का एक डेटाबेस बनाना चाहते हैं जो नया है और फिर आप बस इसे कर सकते हैं और फिर अंत में, उपयोग कमांड का उपयोग करके इसे सक्रिय कर सकते हैं।
और फिर कई अन्य कमांड हैं जो मूल रूप से उपयोगी हैं।
तो, आपने अब तक एक डेटाबेस बनाया है जो एक नाम है और इस डेटाबेस के तहत, हम तालिकाओं को बनाए रखना चाहते हैं।
तो, पहले मैं आपको बताऊंगा कि एक टेबल कैसे बनाया जा सकता है।
अब, जैसा कि आप जानते हैं कि एक तालिका मूल रूप से इस तरह दिखती है, एक तालिका का अपना नाम है।
तो, एक नाम होना चाहिए और कुछ कॉलम होंगे, ये कॉलम कॉल विशेषताएं हैं।
तो, यह विशेषताएँ हैं और फिर प्रत्येक पंक्ति में एक रिकॉर्ड होगा।
इसलिए, प्रत्येक पंक्ति में एक रिकॉर्ड होगा।
अब इसलिए, विशेषताएँ और फिर तालिका नाम पहली चीज है जिसे आपको यह सुनिश्चित करना चाहिए कि जब भी आपको एक तालिका बनानी हो।
और, यह कमांड मूल रूप से एक टेबल बनाता है एक कमांड है जो मूल रूप से आपको बताता है कि वास्तव में क्या तरीका है जिससे आप अपनी खुद की टेबल बना सकते हैं।
तो, कॉलम यह है कि आपको पहले टेबल का नाम देना होगा।
तो, यह कमांड टेबल है और यह टेबल का नाम है जिसे आपको निर्दिष्ट करना है।
इसलिए, मेरी तालिका का नाम इस तरह से एनपीटीईएल डेटा कह सकता है और जो कुछ भी है और फिर सभी कॉलम नाम है, मान लीजिए कि यह एक कॉलम है
तो, शायद रोल नंबर रोल कहो और यह एक और कॉलम है, एक नाम कहो और यह एक और कॉलम कहता है कि निशान है और यह एक और कॉलम कहता है ग्रेड और यह हमारा कुल है जो भी ऐसा है, ये कॉलम नाम हैं।
जैसा कि आप यहां देख रहे हैं कि मैं एक तालिका और तालिका का नाम बनाने की प्रक्रिया में हूं, इस मामले में, जावाकोर्स है और मैंने यहां चार कॉलम बनाए हैं रोल, नाम, मार्क्स और ग्रेड।
तो रोल, नाम, मार्क्स और ग्रेड इसलिए, पांच कॉलम नहीं हैं।
और फिर हमें प्रत्येक विशेषताओं के लिए निर्दिष्ट करना होगा कि इसका प्रकार क्या है।
जैसा कि आप रोल कॉलम के लिए यहां देख रहे हैं, जिसका मतलब है कि विशेषताएँ प्रकार पूर्णांक है और मैं उल्लेख करता हूं कि यह प्राथमिक कुंजी है, अगर आपको पता है कि एक कुंजी अद्वितीय होना चाहिए सभी मान हैं तो यह प्राथमिक कुंजी है।
तो, यह कॉलम अद्वितीय मान यूनिट कॉलम वाले सभी रिकॉर्ड को सम्‍मिलित करेगा।
तो, सभी मान इस तरह से अद्वितीय हैं, इसे प्राथमिक कुंजी कहा जाता है और फिर नाम मूल रूप से एक चरित्र है एक वर्चर है जो इसके लिए एक वाक्यविन्यास है।
तो, कि SQL इसके बारे में समझ सकता है और 30 मूल रूप से अधिकतम स्ट्रिंग है।
इसका मतलब है कि, आप इस कॉलम में अधिकतम 30 अक्षरों का नाम स्टोर कर सकते हैं, नाम।
और फिर, मार्क्स फिर से इंटीजर हैं और यह अशक्त नहीं है;
इसका मतलब है, यदि आप किसी भी अशक्त में प्रवेश करते हैं तो आप इसे शून्य नहीं कर पाएंगे।
और प्राथमिक कुंजी भी अशक्त नहीं है;
इसका मतलब है, कोई भी रिकॉर्ड जिसे आप दर्ज कर सकते हैं जिसके लिए इस तत्व का अशक्त मूल्य है, शून्य मान का अर्थ है कोई मूल्य ठीक नहीं है।
इसलिए, पूर्णांक का निशान भी ऐसा होना चाहिए, जिस पर आपने यहां चर्चा नहीं की है और ग्रेड भी दो वर्णों का एक स्ट्रिंग है।
तो, इस तरह से हम एक तालिका को परिभाषित करते हैं और यह कमांड है, यदि यह कमांड SQL सर्वर को जारी करता है तो SQL सर्वर सक्रिय डेटाबेस के तहत एक टेबल बनाएगा जो इस मामले में परीक्षण है।
तो, यह पूरा करता है कि डेटाबेस कैसे बनाया जा सकता है।
और फिर, यदि आप वास्तव में डेटाबेस को जानना चाहते हैं जो आपने बनाया है तो इसका विवरण क्या है।
इसलिए, विवरण को कमांड द्वारा प्राप्त किया जा सकता है, जिसे DESC कहा जाता है, यह मूल रूप से संक्षिप्त रूप है SQL कभी-कभी आपको शॉर्ट-फॉर्म विवरण देने की अनुमति देता है;
विवरण का संक्षिप्त रूप।
